{"version":3,"file":"shadowmap-multiframe-example.js","mappings":"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","sources":["webpack:///webpack/universalModuleDefinition","webpack:///./example.ts","webpack:///./data/mesh-shadowed-multiframe.frag","webpack:///./data/mesh-shadowed.vert","webpack:///./data/shadow-multiframe.frag","webpack:///./data/shadow.vert","webpack:///external umd \"gloperate\"","webpack:///webpack/bootstrap","webpack:///./shadowmap-multiframe-example.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gloperate\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gloperate\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"gloperate\")) : factory(root[\"gloperate\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__4160__) => {\nreturn ","\n/* spellchecker: disable */\n\nimport {\n    Canvas,\n    Initializable,\n    LoadingStatus,\n    Renderer,\n    viewer,\n} from 'webgl-operate';\n\n/* spellchecker: enable */\n\n\nexport abstract class Example extends Initializable {\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected showSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'inline';\n    }\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected hideSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'none';\n    }\n\n    protected expose(): void {\n\n        (window as any)['canvas'] = this.canvas;\n        (window as any)['context'] = this.canvas.context;\n        (window as any)['controller'] = this.canvas.controller;\n\n        (window as any)['renderer'] = this.renderer;\n    }\n\n    initialize(element: HTMLCanvasElement | string): boolean {\n        const result = this.onInitialize(element);\n\n        this.renderer.loadingStatus$.subscribe((status: LoadingStatus) => {\n            if (status === LoadingStatus.Finished) {\n                this.hideSpinner();\n            } else if (status === LoadingStatus.Started) {\n                this.showSpinner();\n            }\n        });\n\n        this.expose();\n\n        return result;\n    }\n\n    uninitialize(): void {\n        this.onUninitialize();\n    }\n\n    abstract onInitialize(element: HTMLCanvasElement | string): boolean;\n\n    abstract onUninitialize(): void;\n\n    abstract get renderer(): Renderer;\n\n    abstract get canvas(): Canvas;\n\n    enableFullscreenOnCtrlClick(): void {\n\n        const e = this.canvas.element;\n        e.addEventListener('click', (event) => {\n            if (event.ctrlKey) { viewer.Fullscreen.toggle(e); }\n        });\n    }\n}\n","module.exports = \"\\nprecision lowp float;\\n\\n#if __VERSION__ == 100\\n\\n    #ifdef GL_OES_standard_derivatives\\n        #extension GL_OES_standard_derivatives : enable\\n    #endif\\n\\n#endif\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n\\nuniform vec2 u_lightNearFar;\\nuniform mat4 u_lightViewProjection;\\nuniform vec3 u_lightPosition;\\n\\nuniform bool u_colored;\\n\\nuniform sampler2D u_shadowMap;\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n#else\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\nvarying vec2 v_uv;\\n\\n\\n\\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\\n{\\n    vec4 transformed = shadowViewProjection * worldPosition;\\n    return transformed.xy / transformed.w * 0.5 + 0.5;\\n}\\n\\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\\n}\\n\\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\\n{\\n    float depth = texture(depths, uv).r;\\n    return step(compare + offset, depth);\\n}\\n\\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n\\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\\n    float moment = depth * depth + 0.25 * dot(df, df);\\n\\n    return vec2(depth, moment);\\n}\\n\\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    float p = 0.0;\\n\\n    // Surface is fully lit, as the current fragment is before the light occluder\\n    if (compare <= moments.x)\\n        p = 1.0;\\n\\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\\n    // How likely this pixel is to be lit (p_max)\\n    float variance = moments.y - (moments.x * moments.x);\\n    variance = max(variance, minVariance);\\n\\n    float d = compare - moments.x;\\n    float p_max = variance / (variance + d*d);\\n\\n    // Correct light bleeding\\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\\n\\n    return max(p, p_max);\\n}\\n\\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    vec2 moments = texture(depths, uv).rg;\\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\\n}\\n\\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    return exp(exponent * depth);\\n}\\n\\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\\n{\\n    float expDepth = texture(depths, uv).r;\\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\\n}\\n\\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\\n{\\n    depth = depth * 2.0 - 1.0;\\n    float pos =  exp( exponents.x * depth);\\n    float neg = -exp(-exponents.y * depth);\\n    return vec2(pos, neg);\\n}\\n\\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\\n}\\n\\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\\n{\\n    vec4 moments = texture(depths, uv);\\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\\n    vec2 minVariance = depthScale * depthScale;\\n    return min(\\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\\n    );\\n}\\n\\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\\n// {\\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\\n\\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\\n//   if (visibility < 1.0)\\n//   {\\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\\n//   }\\n\\n//   return finalColor;\\n// }\\n\\n\\n\\nconst vec4 shadowColor = vec4(0.494, 0.753, 0.933, 1.0);\\nconst float shadowBias = -0.002;\\n\\n\\nvoid main(void)\\n{\\n    float light_depth = SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar);\\n    vec2 shadow_uv = SMCoordinates(v_vertex, u_lightViewProjection);\\n    float visibility = SMCompare(u_shadowMap, shadow_uv, light_depth, shadowBias);\\n\\n    if (any(greaterThan(shadow_uv, vec2(1.0))) || any(lessThan(shadow_uv, vec2(0.0)))) {\\n        visibility = 1.0;\\n    }\\n\\n    vec4 color = vec4(1.0);\\n    if (u_colored) {\\n        color = vec4(0.8 + (v_vertex.xyz * 0.2 - 0.1), 1.0);\\n    }\\n\\n    fragColor = mix(shadowColor * color, color, visibility);\\n}\\n\"","module.exports = \"\\nprecision lowp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else\\n    #define varying out\\n#endif\\n\\n\\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\\n}\\n\\n\\n\\n#if __VERSION__ == 100\\n    attribute vec3 a_vertex;\\n    attribute vec2 a_texCoord;\\n#else\\n    layout(location = 0) in vec3 a_vertex;\\n    layout(location = 1) in vec2 a_texCoord;\\n#endif\\n\\n\\nuniform mat4 u_viewProjection;\\nuniform mat4 u_model;\\n\\nuniform vec2 u_ndcOffset;\\n\\n\\nvarying vec4 v_vertex;\\nvarying vec2 v_uv;\\n\\n\\nvoid main()\\n{\\n    v_vertex = u_model * vec4(a_vertex, 1.0);\\n    v_uv = a_texCoord;\\n\\n    vec4 vertex = u_viewProjection *  v_vertex;\\n    ndcOffset(vertex, u_ndcOffset);\\n\\n    gl_Position = vertex;\\n}\\n\"","module.exports = \"\\n#if __VERSION__ == 100\\n\\n    #ifdef GL_OES_standard_derivatives\\n        #extension GL_OES_standard_derivatives : enable\\n    #endif\\n\\n#endif\\n\\nprecision highp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n\\nuniform vec2 u_lightNearFar;\\nuniform vec3 u_lightPosition;\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n#else\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\n\\n\\n\\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\\n{\\n    vec4 transformed = shadowViewProjection * worldPosition;\\n    return transformed.xy / transformed.w * 0.5 + 0.5;\\n}\\n\\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\\n}\\n\\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\\n{\\n    float depth = texture(depths, uv).r;\\n    return step(compare + offset, depth);\\n}\\n\\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n\\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\\n    float moment = depth * depth + 0.25 * dot(df, df);\\n\\n    return vec2(depth, moment);\\n}\\n\\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    float p = 0.0;\\n\\n    // Surface is fully lit, as the current fragment is before the light occluder\\n    if (compare <= moments.x)\\n        p = 1.0;\\n\\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\\n    // How likely this pixel is to be lit (p_max)\\n    float variance = moments.y - (moments.x * moments.x);\\n    variance = max(variance, minVariance);\\n\\n    float d = compare - moments.x;\\n    float p_max = variance / (variance + d*d);\\n\\n    // Correct light bleeding\\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\\n\\n    return max(p, p_max);\\n}\\n\\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    vec2 moments = texture(depths, uv).rg;\\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\\n}\\n\\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    return exp(exponent * depth);\\n}\\n\\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\\n{\\n    float expDepth = texture(depths, uv).r;\\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\\n}\\n\\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\\n{\\n    depth = depth * 2.0 - 1.0;\\n    float pos =  exp( exponents.x * depth);\\n    float neg = -exp(-exponents.y * depth);\\n    return vec2(pos, neg);\\n}\\n\\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\\n}\\n\\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\\n{\\n    vec4 moments = texture(depths, uv);\\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\\n    vec2 minVariance = depthScale * depthScale;\\n    return min(\\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\\n    );\\n}\\n\\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\\n// {\\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\\n\\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\\n//   if (visibility < 1.0)\\n//   {\\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\\n//   }\\n\\n//   return finalColor;\\n// }\\n\\n\\nvoid main(void)\\n{\\n    fragColor = vec4(SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 0.0, 1.0);\\n}\\n\"","module.exports = \"\\nprecision highp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else\\n    #define varying out\\n#endif\\n\\n\\n\\nuniform mat4 u_lightViewProjection;\\nuniform mat4 u_model;\\n\\n\\n#if __VERSION__ == 100\\n    attribute vec3 a_vertex;\\n#else\\n    layout(location = 0) in vec3 a_vertex;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\n\\n\\nvoid main()\\n{\\n    v_vertex = u_model * vec4(a_vertex, 1.0);\\n    gl_Position = u_lightViewProjection * v_vertex;\\n}\\n\"","module.exports = __WEBPACK_EXTERNAL_MODULE__4160__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n/* spellchecker: disable */\n\nimport { mat4, vec2, vec3 } from 'webgl-operate';\n\nimport {\n    AccumulatePass,\n    AntiAliasingKernel,\n    BlitPass,\n    Camera,\n    Canvas,\n    Context,\n    CuboidGeometry,\n    DefaultFramebuffer,\n    EventProvider,\n    Framebuffer,\n    Invalidate,\n    Navigation,\n    NdcFillingTriangle,\n    PlaneGeometry,\n    Program,\n    Renderbuffer,\n    Renderer,\n    Shader,\n    ShadowPass,\n    Texture2D,\n    Wizard,\n} from 'webgl-operate';\n\nimport { Example } from './example';\n\n/* spellchecker: enable */\n\n// tslint:disable:max-classes-per-file\n\n\nclass ShadowMapMultiframeRenderer extends Renderer {\n\n    protected _cuboids: Array<CuboidGeometry>;\n    protected _plane: PlaneGeometry;\n    protected _ndcTriangle: NdcFillingTriangle;\n\n    protected _defaultFBO: DefaultFramebuffer;\n    protected _colorRenderTexture: Texture2D;\n    protected _depthRenderbuffer: Renderbuffer;\n    protected _intermediateFBO: Framebuffer;\n\n    protected _navigation: Navigation;\n\n    protected _camera: Camera;\n    protected _light: Camera;\n    protected _lightSamples: Array<vec3>;\n\n    protected _ndcOffsetKernel: AntiAliasingKernel;\n    protected _uNdcOffset: WebGLUniformLocation;\n\n    protected _program: Program;\n    protected _uViewProjection: WebGLUniformLocation;\n    protected _uModel: WebGLUniformLocation;\n    protected _uColored: WebGLUniformLocation;\n    protected _uLightViewProjection: WebGLUniformLocation;\n    protected _uLightPosition: WebGLUniformLocation;\n\n    protected _shadowProgram: Program;\n    protected _uModelS: WebGLUniformLocation;\n    protected _uLightViewProjectionS: WebGLUniformLocation;\n    protected _uLightPositionS: WebGLUniformLocation;\n\n    protected _shadowPass: ShadowPass;\n    protected _accumulate: AccumulatePass;\n    protected _blit: BlitPass;\n\n\n    protected onInitialize(context: Context, callback: Invalidate,\n        eventProvider: EventProvider): boolean {\n\n        context.enable(['ANGLE_instanced_arrays', 'OES_standard_derivatives',\n            'WEBGL_color_buffer_float', 'OES_texture_float', 'OES_texture_float_linear']);\n\n        this._defaultFBO = new DefaultFramebuffer(context, 'DefaultFBO');\n        this._defaultFBO.initialize();\n        this._defaultFBO.bind();\n\n        const gl = context.gl as WebGLRenderingContext;\n        const gl2facade = this._context.gl2facade;\n\n        this._cuboids = new Array(4);\n        for (let i = 0; i < this._cuboids.length; ++i) {\n            this._cuboids[i] = new CuboidGeometry(context, 'cube', true, [0.25, 0.5 + 0.5 * i, 2.0]);\n            this._cuboids[i].initialize();\n        }\n\n        this._plane = new PlaneGeometry(context, 'plane');\n        this._plane.initialize();\n        this._plane.scale = vec2.fromValues(100, 100);\n\n        this._ndcTriangle = new NdcFillingTriangle(this._context);\n        this._ndcTriangle.initialize();\n\n\n        if (this._camera === undefined) {\n            this._camera = new Camera();\n            this._camera.center = vec3.fromValues(0.0, 0.75, 0.0);\n            this._camera.up = vec3.fromValues(0.0, 1.0, 0.0);\n            this._camera.eye = vec3.fromValues(1.8, 2.6, 3.4);\n            this._camera.near = 2.0;\n            this._camera.far = 11.0;\n        }\n\n        if (this._light === undefined) {\n            this._light = new Camera();\n            this._light.center = vec3.fromValues(0.0, 0.0, 0.0);\n            this._light.up = vec3.fromValues(0.0, 1.0, 0.0);\n            this._light.eye = vec3.fromValues(-3.0, 5.0, 4.0);\n            this._light.near = 3.0;\n            this._light.far = 20.0;\n        }\n\n\n        this._colorRenderTexture = new Texture2D(this._context, 'ColorRenderTexture');\n        this._depthRenderbuffer = new Renderbuffer(this._context, 'DepthRenderbuffer');\n        this._intermediateFBO = new Framebuffer(this._context, 'IntermediateFBO');\n\n        const vert = new Shader(context, gl.VERTEX_SHADER, 'mesh-shadowed.vert');\n        vert.initialize(require('./data/mesh-shadowed.vert'));\n        const frag = new Shader(context, gl.FRAGMENT_SHADER, 'mesh-shadowed.frag');\n        frag.initialize(require('./data/mesh-shadowed-multiframe.frag'));\n\n        this._program = new Program(context, 'MeshShadowedProgram');\n        this._program.initialize([vert, frag], false);\n\n        this._program.attribute('a_vertex', this._cuboids[0].vertexLocation);\n        this._program.attribute('a_texCoord', this._cuboids[0].uvCoordLocation);\n        this._program.link();\n        this._program.bind();\n\n        gl.uniform2f(this._program.uniform('u_lightNearFar'), this._light.near, this._light.far);\n        gl.uniform1i(this._program.uniform('u_shadowMap'), 0);\n\n        this._uViewProjection = this._program.uniform('u_viewProjection');\n        this._uModel = this._program.uniform('u_model');\n        this._uLightViewProjection = this._program.uniform('u_lightViewProjection');\n        this._uLightPosition = this._program.uniform('u_lightPosition');\n        this._uNdcOffset = this._program.uniform('u_ndcOffset');\n\n        this._uColored = this._program.uniform('u_colored');\n\n        const shadowVert = new Shader(context, gl.VERTEX_SHADER, 'shadow.vert');\n        shadowVert.initialize(require('./data/shadow.vert'));\n        const shadowFrag = new Shader(context, gl.FRAGMENT_SHADER, 'shadow.frag');\n        shadowFrag.initialize(require('./data/shadow-multiframe.frag'));\n\n        this._shadowProgram = new Program(context);\n        this._shadowProgram.initialize([shadowVert, shadowFrag], false);\n        this._shadowProgram.attribute('a_vertex', this._cuboids[0].vertexLocation);\n        this._shadowProgram.link();\n        this._shadowProgram.bind();\n\n        gl.uniform2f(this._shadowProgram.uniform('u_lightNearFar'), this._light.near, this._light.far);\n\n        this._uModelS = this._shadowProgram.uniform('u_model');\n        this._uLightViewProjectionS = this._shadowProgram.uniform('u_lightViewProjection');\n        this._uLightPositionS = this._shadowProgram.uniform('u_lightPosition');\n\n\n        this._navigation = new Navigation(callback, eventProvider);\n        this._navigation.camera = this._camera;\n\n\n        this._accumulate = new AccumulatePass(context);\n        this._accumulate.initialize(this._ndcTriangle);\n        this._accumulate.precision = this._framePrecision;\n        this._accumulate.texture = this._colorRenderTexture;\n\n\n        this._blit = new BlitPass(this._context);\n        this._blit.initialize(this._ndcTriangle);\n        this._blit.readBuffer = gl2facade.COLOR_ATTACHMENT0;\n        this._blit.drawBuffer = gl.BACK;\n        this._blit.target = this._defaultFBO;\n\n        this._shadowPass = new ShadowPass(context);\n        this._shadowPass.initialize(ShadowPass.ShadowMappingType.HardLinear, [1024, 1024]);\n\n        this.finishLoading();\n\n        return true;\n    }\n\n    protected onUninitialize(): void {\n        super.uninitialize();\n\n        this._defaultFBO.uninitialize();\n\n        for (const cuboid of this._cuboids) {\n            cuboid.uninitialize();\n        }\n        this._plane.uninitialize();\n        this._ndcTriangle.uninitialize();\n\n        this._shadowPass.uninitialize();\n    }\n\n    protected onDiscarded(): void {\n        this._altered.alter('canvasSize');\n        this._altered.alter('clearColor');\n        this._altered.alter('frameSize');\n    }\n\n    protected onUpdate(): boolean {\n        this._navigation.update();\n        return this._camera.altered;\n    }\n\n    protected onPrepare(): void {\n        const gl = this._context.gl;\n        const gl2facade = this._context.gl2facade;\n\n        if (!this._intermediateFBO.initialized) {\n            this._colorRenderTexture.initialize(this._frameSize[0], this._frameSize[1],\n                this._context.isWebGL2 ? gl.RGBA8 : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n            this._depthRenderbuffer.initialize(this._frameSize[0], this._frameSize[1], gl.DEPTH_COMPONENT16);\n            this._intermediateFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._colorRenderTexture]\n                , [gl.DEPTH_ATTACHMENT, this._depthRenderbuffer]]);\n            this._intermediateFBO.clearColor([1.0, 1.0, 1.0, 1.0]);\n        }\n\n        if (this._altered.frameSize) {\n            this._intermediateFBO.resize(this._frameSize[0], this._frameSize[1]);\n            this._camera.viewport = [this._frameSize[0], this._frameSize[1]];\n        }\n        if (this._altered.canvasSize) {\n            this._camera.aspect = this._canvasSize[0] / this._canvasSize[1];\n        }\n\n        if (this._altered.clearColor) {\n            this._defaultFBO.clearColor(this._clearColor);\n        }\n\n        if (this._altered.multiFrameNumber) {\n            this._ndcOffsetKernel = new AntiAliasingKernel(this._multiFrameNumber);\n\n            // /* Create light samples along circle around eye (light position). */\n\n            const n = vec3.sub(vec3.create(), this._light.eye, this._light.center);\n            vec3.normalize(n, n);\n\n            const u = vec3.cross(vec3.create(), n, vec3.fromValues(0.0, 1.0, 0.0));\n            const v = vec3.cross(vec3.create(), n, u);\n\n            this._lightSamples = new Array<vec3>(this._multiFrameNumber);\n            for (let i = 0; i < this._multiFrameNumber; ++i) {\n                const p = vec3.clone(this._light.eye);\n\n                const r = Math.random() * 0.25; // Math.sqrt(i / this._multiFrameNumber);\n                const theta = Math.random() * Math.PI * 2.0;\n\n                vec3.scaleAndAdd(p, p, u, r * Math.cos(theta));\n                vec3.scaleAndAdd(p, p, v, r * Math.sin(theta));\n\n                this._lightSamples[i] = p;\n            }\n\n            this._lightSamples.sort((a: vec3, b: vec3) =>\n                vec3.sqrDist(a, this._light.eye) - vec3.sqrDist(b, this._light.eye));\n        }\n\n        this._accumulate.update();\n\n        this._altered.reset();\n        this._camera.altered = false;\n    }\n\n    protected onFrame(frameNumber: number): void {\n        const gl = this._context.gl as WebGLRenderingContext;\n\n\n        this._light.eye = this._lightSamples[frameNumber];\n\n        this._shadowPass.frame(() => {\n            gl.enable(gl.DEPTH_TEST);\n            this._shadowProgram.bind();\n            gl.uniformMatrix4fv(this._uLightViewProjectionS, false, this._light.viewProjection);\n            gl.uniform3fv(this._uLightPositionS, this._light.eye);\n            this.drawCuboids(this._uModelS);\n            this._shadowProgram.unbind();\n            gl.disable(gl.DEPTH_TEST);\n        });\n\n        this._intermediateFBO.bind();\n        this._intermediateFBO.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);\n\n\n        gl.viewport(0, 0, this._frameSize[0], this._frameSize[1]);\n\n        const ndcOffset = this._ndcOffsetKernel.get(frameNumber);\n        ndcOffset[0] = 2.0 * ndcOffset[0] / this._frameSize[0];\n        ndcOffset[1] = 2.0 * ndcOffset[1] / this._frameSize[1];\n\n\n        gl.enable(gl.DEPTH_TEST);\n        gl.enable(gl.CULL_FACE);\n\n        this._program.bind();\n        gl.uniformMatrix4fv(this._uViewProjection, false, this._camera.viewProjection);\n        gl.uniformMatrix4fv(this._uLightViewProjection, false, this._light.viewProjection);\n        gl.uniform3fv(this._uLightPosition, this._light.eye);\n        gl.uniform2fv(this._uNdcOffset, ndcOffset);\n\n        this._shadowPass.shadowMapTexture.bind(gl.TEXTURE0);\n\n        gl.uniform1i(this._uColored, Number(true));\n        this.drawCuboids(this._uModel);\n\n        gl.uniform1i(this._uColored, Number(false));\n        this.drawPlane(this._uModel);\n\n        this._program.unbind();\n        this._shadowPass.shadowMapTexture.unbind();\n\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.CULL_FACE);\n\n        this._accumulate.frame(frameNumber);\n    }\n\n    protected onSwap(): void {\n        this._blit.framebuffer = this._accumulate.framebuffer ?\n            this._accumulate.framebuffer : this._blit.framebuffer = this._intermediateFBO;\n        this._blit.frame();\n    }\n\n    protected drawCuboids(model: WebGLUniformLocation): void {\n        const gl = this._context.gl;\n\n        const M = mat4.create();\n        for (let i = 0; i < this._cuboids.length; ++i) {\n\n            const x = i * 0.5 - 0.75;\n            const y = this._cuboids[i].extent[1] * 0.5;\n\n            mat4.fromTranslation(M, vec3.fromValues(-x, y, 0.0));\n            gl.uniformMatrix4fv(model, false, M);\n\n            this._cuboids[i].bind();\n            this._cuboids[i].draw();\n        }\n    }\n\n    protected drawPlane(model: WebGLUniformLocation): void {\n        const gl = this._context.gl;\n\n        gl.uniformMatrix4fv(model, false, this._plane.transformation);\n        this._plane.bind();\n        this._plane.draw();\n    }\n\n}\n\nexport class ShadowMapMultiframeExample extends Example {\n\n    private _canvas: Canvas;\n    private _renderer: ShadowMapMultiframeRenderer;\n\n    onInitialize(element: HTMLCanvasElement | string): boolean {\n\n        this._canvas = new Canvas(element);\n        this._canvas.framePrecision = Wizard.Precision.half;\n        this._canvas.frameScale = [1.0, 1.0];\n\n        this._canvas.clearColor.fromHex('ffffff');\n        this._canvas.controller.multiFrameNumber = 128;\n\n        this._renderer = new ShadowMapMultiframeRenderer();\n        this._canvas.renderer = this._renderer;\n\n        return true;\n    }\n\n    onUninitialize(): void {\n        this._canvas.dispose();\n        (this._renderer as Renderer).uninitialize();\n    }\n\n    get canvas(): Canvas {\n        return this._canvas;\n    }\n\n    get renderer(): ShadowMapMultiframeRenderer {\n        return this._renderer;\n    }\n\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__4160__","Example","Initializable","showSpinner","document","getElementsByClassName","item","style","display","hideSpinner","expose","window","this","canvas","context","controller","renderer","initialize","element","result","onInitialize","loadingStatus$","subscribe","status","LoadingStatus","Finished","Started","uninitialize","onUninitialize","enableFullscreenOnCtrlClick","e","addEventListener","event","ctrlKey","viewer","Fullscreen","toggle","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","ShadowMapMultiframeRenderer","Renderer","callback","eventProvider","enable","_defaultFBO","DefaultFramebuffer","bind","gl","gl2facade","_context","_cuboids","Array","length","CuboidGeometry","_plane","PlaneGeometry","scale","vec2","fromValues","_ndcTriangle","NdcFillingTriangle","_camera","Camera","center","vec3","up","eye","near","far","_light","_colorRenderTexture","Texture2D","_depthRenderbuffer","Renderbuffer","_intermediateFBO","Framebuffer","vert","Shader","VERTEX_SHADER","frag","FRAGMENT_SHADER","_program","Program","attribute","vertexLocation","uvCoordLocation","link","uniform2f","uniform","uniform1i","_uViewProjection","_uModel","_uLightViewProjection","_uLightPosition","_uNdcOffset","_uColored","shadowVert","shadowFrag","_shadowProgram","_uModelS","_uLightViewProjectionS","_uLightPositionS","_navigation","Navigation","camera","_accumulate","AccumulatePass","precision","_framePrecision","texture","_blit","BlitPass","readBuffer","COLOR_ATTACHMENT0","drawBuffer","BACK","target","_shadowPass","ShadowPass","ShadowMappingType","HardLinear","finishLoading","super","cuboid","onDiscarded","_altered","alter","onUpdate","update","altered","onPrepare","initialized","_frameSize","isWebGL2","RGBA8","RGBA","UNSIGNED_BYTE","DEPTH_COMPONENT16","DEPTH_ATTACHMENT","clearColor","frameSize","resize","viewport","canvasSize","aspect","_canvasSize","_clearColor","multiFrameNumber","_ndcOffsetKernel","AntiAliasingKernel","_multiFrameNumber","n","sub","create","normalize","u","cross","v","_lightSamples","p","clone","r","Math","random","theta","PI","scaleAndAdd","cos","sin","sort","b","sqrDist","reset","onFrame","frameNumber","frame","DEPTH_TEST","uniformMatrix4fv","viewProjection","uniform3fv","drawCuboids","unbind","disable","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","ndcOffset","get","CULL_FACE","uniform2fv","shadowMapTexture","TEXTURE0","Number","drawPlane","onSwap","framebuffer","model","M","mat4","x","y","extent","fromTranslation","draw","transformation","ShadowMapMultiframeExample","_canvas","Canvas","framePrecision","Wizard","Precision","half","frameScale","fromHex","_renderer","dispose"],"sourceRoot":""}