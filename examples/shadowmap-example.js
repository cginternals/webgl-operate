!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n(require("gloperate"));else if("function"==typeof define&&define.amd)define(["gloperate"],n);else{var t="object"==typeof exports?n(require("gloperate")):n(e.gloperate);for(var i in t)("object"==typeof exports?exports:e)[i]=t[i]}}(self,(function(e){return(()=>{var n={4558:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Example=void 0;const i=t(4160);class o extends i.Initializable{showSpinner(){document.getElementsByClassName("spinner").item(0).style.display="inline"}hideSpinner(){document.getElementsByClassName("spinner").item(0).style.display="none"}expose(){window.canvas=this.canvas,window.context=this.canvas.context,window.controller=this.canvas.controller,window.renderer=this.renderer}initialize(e){const n=this.onInitialize(e);return this.renderer.loadingStatus$.subscribe((e=>{e===i.LoadingStatus.Finished?this.hideSpinner():e===i.LoadingStatus.Started&&this.showSpinner()})),this.expose(),n}uninitialize(){this.onUninitialize()}enableFullscreenOnCtrlClick(){const e=this.canvas.element;e.addEventListener("click",(n=>{n.ctrlKey&&i.viewer.Fullscreen.toggle(e)}))}}n.Example=o},5247:e=>{e.exports="\nprecision lowp float;\n\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform mat4 u_lightViewProjection;\nuniform vec3 u_lightPosition;\n\nuniform bool u_colored;\n\nuniform sampler2D u_shadowMap;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec4 v_vertex;\nvarying vec2 v_uv;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\n\nconst vec4 shadowColor = vec4(0.494, 0.753, 0.933, 1.0);\n\nconst vec2 shadowExponents = vec2(30.0, 10.0);\nconst float shadowLightBleedingReduction = 0.1;\n\n\nvoid main(void)\n{\n    float light_depth = SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar);\n    vec2 shadow_uv = SMCoordinates(v_vertex, u_lightViewProjection);\n\n    // float visibility = SMCompare(u_shadowMap, shadow_uv, light_depth, shadowBias);\n    // float visibility = ESMCompare(u_shadowMap, shadow_uv, light_depth, shadowExponent);\n    // float visibility = VSMCompare(u_shadowMap, shadow_uv, light_depth, shadowMinVariance, shadowLightBleedingReduction);\n    float visibility = EVSMCompare(u_shadowMap, shadow_uv, light_depth, shadowExponents, shadowLightBleedingReduction);\n\n    if (any(greaterThan(shadow_uv, vec2(1.0))) || any(lessThan(shadow_uv, vec2(0.0)))) {\n        visibility = 1.0;\n    }\n\n    vec4 color = vec4(1.0);\n    if (u_colored) {\n        color = vec4(0.8 + (v_vertex.xyz * 0.2 - 0.1), 1.0);\n    }\n\n    fragColor = mix(shadowColor * color, color, visibility);\n}\n"},1626:e=>{e.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\n\n#if __VERSION__ == 100\n    attribute vec3 a_vertex;\n    attribute vec2 a_texCoord;\n#else\n    layout(location = 0) in vec3 a_vertex;\n    layout(location = 1) in vec2 a_texCoord;\n#endif\n\n\nuniform mat4 u_viewProjection;\nuniform mat4 u_model;\n\nuniform vec2 u_ndcOffset;\n\n\nvarying vec4 v_vertex;\nvarying vec2 v_uv;\n\n\nvoid main()\n{\n    v_vertex = u_model * vec4(a_vertex, 1.0);\n    v_uv = a_texCoord;\n\n    vec4 vertex = u_viewProjection *  v_vertex;\n    ndcOffset(vertex, u_ndcOffset);\n\n    gl_Position = vertex;\n}\n"},5058:e=>{e.exports="\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform vec3 u_lightPosition;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec4 v_vertex;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\n\nconst float shadowExponent = 80.0;\nconst vec2 shadowExponents = vec2(30.0, 10.0);\n\n\nvoid main(void)\n{\n    //fragColor = vec4(SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 0.0, 1.0);\n    //fragColor = vec4(ESMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar, shadowExponent), 0.0, 0.0, 1.0);\n    //fragColor = vec4(VSMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 1.0);\n    fragColor = EVSMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar, shadowExponents);\n}\n"},2391:e=>{e.exports="\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\nuniform mat4 u_lightViewProjection;\nuniform mat4 u_model;\n\n\n#if __VERSION__ == 100\n    attribute vec3 a_vertex;\n#else\n    layout(location = 0) in vec3 a_vertex;\n#endif\n\n\nvarying vec4 v_vertex;\n\n\nvoid main()\n{\n    v_vertex = u_model * vec4(a_vertex, 1.0);\n    gl_Position = u_lightViewProjection * v_vertex;\n}\n"},4160:n=>{"use strict";n.exports=e}},t={};function i(e){var o=t[e];if(void 0!==o)return o.exports;var a=t[e]={exports:{}};return n[e](a,a.exports,i),a.exports}var o={};return(()=>{"use strict";var e=o;Object.defineProperty(e,"__esModule",{value:!0}),e.ShadowMapExample=void 0;const n=i(4160),t=i(4160),a=i(4558);class r extends t.Renderer{onInitialize(e,o,a){e.enable(["ANGLE_instanced_arrays","OES_standard_derivatives","WEBGL_color_buffer_float","OES_texture_float","OES_texture_float_linear"]),this._defaultFBO=new t.DefaultFramebuffer(e,"DefaultFBO"),this._defaultFBO.initialize(),this._defaultFBO.bind();const r=e.gl;this._cuboids=new Array(4);for(let n=0;n<this._cuboids.length;++n)this._cuboids[n]=new t.CuboidGeometry(e,"cube",!0,[.25,.5+.5*n,2]),this._cuboids[n].initialize();this._plane=new t.PlaneGeometry(e,"plane"),this._plane.initialize(),this._plane.scale=n.vec2.fromValues(5,5),void 0===this._camera&&(this._camera=new t.Camera,this._camera.center=n.vec3.fromValues(0,.75,0),this._camera.up=n.vec3.fromValues(0,1,0),this._camera.eye=n.vec3.fromValues(1.8,2.6,3.4),this._camera.near=2,this._camera.far=11),void 0===this._light&&(this._light=new t.Camera,this._light.center=n.vec3.fromValues(0,.75,0),this._light.up=n.vec3.fromValues(0,1,0),this._light.eye=n.vec3.fromValues(-3,5,4),this._light.fovy=30,this._light.near=4,this._light.far=20);const s=new t.Shader(e,r.VERTEX_SHADER,"mesh-shadowed.vert");s.initialize(i(1626));const l=new t.Shader(e,r.FRAGMENT_SHADER,"mesh-shadowed.frag");l.initialize(i(5247)),this._program=new t.Program(e,"MeshShadowedProgram"),this._program.initialize([s,l],!1),this._program.attribute("a_vertex",this._cuboids[0].vertexLocation),this._program.attribute("a_texCoord",this._cuboids[0].uvCoordLocation),this._program.link(),this._program.bind(),r.uniform2f(this._program.uniform("u_lightNearFar"),this._light.near,this._light.far),r.uniformMatrix4fv(this._program.uniform("u_lightViewProjection"),!1,this._light.viewProjection),r.uniform3fv(this._program.uniform("u_lightPosition"),this._light.eye),r.uniform1i(this._program.uniform("u_shadowMap"),0),this._uViewProjection=this._program.uniform("u_viewProjection"),this._uModel=this._program.uniform("u_model"),this._uColored=this._program.uniform("u_colored");const h=new t.Shader(e,r.VERTEX_SHADER,"shadow.vert");h.initialize(i(2391));const d=new t.Shader(e,r.FRAGMENT_SHADER,"shadow.frag");return d.initialize(i(5058)),this._shadowProgram=new t.Program(e),this._shadowProgram.initialize([h,d],!1),this._shadowProgram.attribute("a_vertex",this._cuboids[0].vertexLocation),this._shadowProgram.link(),this._shadowProgram.bind(),r.uniform2f(this._shadowProgram.uniform("u_lightNearFar"),this._light.near,this._light.far),r.uniformMatrix4fv(this._shadowProgram.uniform("u_lightViewProjection"),!1,this._light.viewProjection),r.uniform3fv(this._shadowProgram.uniform("u_lightPosition"),this._light.eye),this._uModelS=this._shadowProgram.uniform("u_model"),this._navigation=new t.Navigation(o,a),this._navigation.camera=this._camera,this._shadowPass=new t.ShadowPass(e),this._shadowPass.initialize(t.ShadowPass.ShadowMappingType.HardLinear,[1024,1024],[1024,1024]),this._debugPass=new t.DebugPass(e),this._debugPass.initialize(),this._debugPass.framebuffer=this._shadowPass.shadowMapFBO,this._debugPass.readBuffer=r.COLOR_ATTACHMENT0,this._debugPass.target=this._defaultFBO,this._debugPass.drawBuffer=r.BACK,this.finishLoading(),!0}onUninitialize(){super.uninitialize(),this._defaultFBO.uninitialize();for(const e of this._cuboids)e.uninitialize();this._plane.uninitialize(),this._shadowPass.uninitialize()}onDiscarded(){this._altered.alter("canvasSize"),this._altered.alter("clearColor"),this._altered.alter("frameSize")}onUpdate(){return this._navigation.update(),this._camera.altered}onPrepare(){this._altered.frameSize&&(this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),this._altered.canvasSize&&(this._camera.aspect=this._canvasSize[0]/this._canvasSize[1],this._debugPass.dstBounds=n.vec4.fromValues(.813*this._canvasSize[0],this._canvasSize[1]*(1-.187*this._camera.aspect),.992*this._canvasSize[0],this._canvasSize[1]*(1-.008*this._camera.aspect))),this._altered.clearColor&&this._defaultFBO.clearColor(this._clearColor),this._camera.altered&&(this._debugPass.far=this._camera.far,this._debugPass.near=this._camera.near),this._camera.altered=!1,this._altered.reset()}onFrame(e){const n=this._context.gl;this._shadowPass.frame((()=>{n.enable(n.DEPTH_TEST),this._shadowProgram.bind(),this.drawCuboids(this._uModelS),this._shadowProgram.unbind(),n.disable(n.DEPTH_TEST)})),this._defaultFBO.bind(),this._defaultFBO.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT,!0,!1),n.viewport(0,0,this._frameSize[0],this._frameSize[1]),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),this._program.bind(),n.uniformMatrix4fv(this._uViewProjection,!1,this._camera.viewProjection),this._shadowPass.shadowMapTexture.bind(n.TEXTURE0),n.uniform1i(this._uColored,Number(!0)),this.drawCuboids(this._uModel),n.uniform1i(this._uColored,Number(!1)),n.uniformMatrix4fv(this._uModel,!1,this._plane.transformation),this._plane.bind(),this._plane.draw(),this._program.unbind(),this._shadowPass.shadowMapTexture.unbind(),n.disable(n.DEPTH_TEST),n.disable(n.CULL_FACE)}onSwap(){this._debugPass.frame()}drawCuboids(e){const t=this._context.gl,i=n.mat4.create();for(let o=0;o<this._cuboids.length;++o){const a=.5*o-.75,r=.5*this._cuboids[o].extent[1];n.mat4.fromTranslation(i,n.vec3.fromValues(-a,r,0)),t.uniformMatrix4fv(e,!1,i),this._cuboids[o].bind(),this._cuboids[o].draw()}}drawPlane(e){}}class s extends a.Example{onInitialize(e){return this._canvas=new t.Canvas(e),this._canvas.controller.multiFrameNumber=1,this._canvas.framePrecision=t.Wizard.Precision.byte,this._canvas.frameScale=[1,1],this._canvas.clearColor.fromHex("ffffff"),this._renderer=new r,this._canvas.renderer=this._renderer,!0}onUninitialize(){this._canvas.dispose(),this._renderer.uninitialize()}get canvas(){return this._canvas}get renderer(){return this._renderer}}e.ShadowMapExample=s})(),o})()}));
//# sourceMappingURL=shadowmap-example.js.map