!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("gloperate"));else if("function"==typeof define&&define.amd)define(["gloperate"],t);else{var n="object"==typeof exports?t(require("gloperate")):t(e.gloperate);for(var i in n)("object"==typeof exports?exports:e)[i]=n[i]}}(self,(function(e){return(()=>{var t={4558:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Example=void 0;const i=n(4160);class o extends i.Initializable{showSpinner(){document.getElementsByClassName("spinner").item(0).style.display="inline"}hideSpinner(){document.getElementsByClassName("spinner").item(0).style.display="none"}expose(){window.canvas=this.canvas,window.context=this.canvas.context,window.controller=this.canvas.controller,window.renderer=this.renderer}initialize(e){const t=this.onInitialize(e);return this.renderer.loadingStatus$.subscribe((e=>{e===i.LoadingStatus.Finished?this.hideSpinner():e===i.LoadingStatus.Started&&this.showSpinner()})),this.expose(),t}uninitialize(){this.onUninitialize()}enableFullscreenOnCtrlClick(){const e=this.canvas.element;e.addEventListener("click",(t=>{t.ctrlKey&&i.viewer.Fullscreen.toggle(e)}))}}t.Example=o},8111:e=>{e.exports="\nprecision lowp float;\n\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform mat4 u_lightViewProjection;\nuniform vec3 u_lightPosition;\n\nuniform bool u_colored;\n\nuniform sampler2D u_shadowMap;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec4 v_vertex;\nvarying vec2 v_uv;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\n\nconst vec4 shadowColor = vec4(0.494, 0.753, 0.933, 1.0);\nconst float shadowBias = -0.002;\n\n\nvoid main(void)\n{\n    float light_depth = SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar);\n    vec2 shadow_uv = SMCoordinates(v_vertex, u_lightViewProjection);\n    float visibility = SMCompare(u_shadowMap, shadow_uv, light_depth, shadowBias);\n\n    if (any(greaterThan(shadow_uv, vec2(1.0))) || any(lessThan(shadow_uv, vec2(0.0)))) {\n        visibility = 1.0;\n    }\n\n    vec4 color = vec4(1.0);\n    if (u_colored) {\n        color = vec4(0.8 + (v_vertex.xyz * 0.2 - 0.1), 1.0);\n    }\n\n    fragColor = mix(shadowColor * color, color, visibility);\n}\n"},1626:e=>{e.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\n\n#if __VERSION__ == 100\n    attribute vec3 a_vertex;\n    attribute vec2 a_texCoord;\n#else\n    layout(location = 0) in vec3 a_vertex;\n    layout(location = 1) in vec2 a_texCoord;\n#endif\n\n\nuniform mat4 u_viewProjection;\nuniform mat4 u_model;\n\nuniform vec2 u_ndcOffset;\n\n\nvarying vec4 v_vertex;\nvarying vec2 v_uv;\n\n\nvoid main()\n{\n    v_vertex = u_model * vec4(a_vertex, 1.0);\n    v_uv = a_texCoord;\n\n    vec4 vertex = u_viewProjection *  v_vertex;\n    ndcOffset(vertex, u_ndcOffset);\n\n    gl_Position = vertex;\n}\n"},819:e=>{e.exports="\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform vec3 u_lightPosition;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec4 v_vertex;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\nvoid main(void)\n{\n    fragColor = vec4(SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 0.0, 1.0);\n}\n"},2391:e=>{e.exports="\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\nuniform mat4 u_lightViewProjection;\nuniform mat4 u_model;\n\n\n#if __VERSION__ == 100\n    attribute vec3 a_vertex;\n#else\n    layout(location = 0) in vec3 a_vertex;\n#endif\n\n\nvarying vec4 v_vertex;\n\n\nvoid main()\n{\n    v_vertex = u_model * vec4(a_vertex, 1.0);\n    gl_Position = u_lightViewProjection * v_vertex;\n}\n"},4160:t=>{"use strict";t.exports=e}},n={};function i(e){var o=n[e];if(void 0!==o)return o.exports;var r=n[e]={exports:{}};return t[e](r,r.exports,i),r.exports}var o={};return(()=>{"use strict";var e=o;Object.defineProperty(e,"__esModule",{value:!0}),e.ShadowMapMultiframeExample=void 0;const t=i(4160),n=i(4160),r=i(4558);class a extends n.Renderer{onInitialize(e,o,r){e.enable(["ANGLE_instanced_arrays","OES_standard_derivatives","WEBGL_color_buffer_float","OES_texture_float","OES_texture_float_linear"]),this._defaultFBO=new n.DefaultFramebuffer(e,"DefaultFBO"),this._defaultFBO.initialize(),this._defaultFBO.bind();const a=e.gl,s=this._context.gl2facade;this._cuboids=new Array(4);for(let t=0;t<this._cuboids.length;++t)this._cuboids[t]=new n.CuboidGeometry(e,"cube",!0,[.25,.5+.5*t,2]),this._cuboids[t].initialize();this._plane=new n.PlaneGeometry(e,"plane"),this._plane.initialize(),this._plane.scale=t.vec2.fromValues(100,100),this._ndcTriangle=new n.NdcFillingTriangle(this._context),this._ndcTriangle.initialize(),void 0===this._camera&&(this._camera=new n.Camera,this._camera.center=t.vec3.fromValues(0,.75,0),this._camera.up=t.vec3.fromValues(0,1,0),this._camera.eye=t.vec3.fromValues(1.8,2.6,3.4),this._camera.near=2,this._camera.far=11),void 0===this._light&&(this._light=new n.Camera,this._light.center=t.vec3.fromValues(0,0,0),this._light.up=t.vec3.fromValues(0,1,0),this._light.eye=t.vec3.fromValues(-3,5,4),this._light.near=3,this._light.far=20),this._colorRenderTexture=new n.Texture2D(this._context,"ColorRenderTexture"),this._depthRenderbuffer=new n.Renderbuffer(this._context,"DepthRenderbuffer"),this._intermediateFBO=new n.Framebuffer(this._context,"IntermediateFBO");const l=new n.Shader(e,a.VERTEX_SHADER,"mesh-shadowed.vert");l.initialize(i(1626));const h=new n.Shader(e,a.FRAGMENT_SHADER,"mesh-shadowed.frag");h.initialize(i(8111)),this._program=new n.Program(e,"MeshShadowedProgram"),this._program.initialize([l,h],!1),this._program.attribute("a_vertex",this._cuboids[0].vertexLocation),this._program.attribute("a_texCoord",this._cuboids[0].uvCoordLocation),this._program.link(),this._program.bind(),a.uniform2f(this._program.uniform("u_lightNearFar"),this._light.near,this._light.far),a.uniform1i(this._program.uniform("u_shadowMap"),0),this._uViewProjection=this._program.uniform("u_viewProjection"),this._uModel=this._program.uniform("u_model"),this._uLightViewProjection=this._program.uniform("u_lightViewProjection"),this._uLightPosition=this._program.uniform("u_lightPosition"),this._uNdcOffset=this._program.uniform("u_ndcOffset"),this._uColored=this._program.uniform("u_colored");const c=new n.Shader(e,a.VERTEX_SHADER,"shadow.vert");c.initialize(i(2391));const d=new n.Shader(e,a.FRAGMENT_SHADER,"shadow.frag");return d.initialize(i(819)),this._shadowProgram=new n.Program(e),this._shadowProgram.initialize([c,d],!1),this._shadowProgram.attribute("a_vertex",this._cuboids[0].vertexLocation),this._shadowProgram.link(),this._shadowProgram.bind(),a.uniform2f(this._shadowProgram.uniform("u_lightNearFar"),this._light.near,this._light.far),this._uModelS=this._shadowProgram.uniform("u_model"),this._uLightViewProjectionS=this._shadowProgram.uniform("u_lightViewProjection"),this._uLightPositionS=this._shadowProgram.uniform("u_lightPosition"),this._navigation=new n.Navigation(o,r),this._navigation.camera=this._camera,this._accumulate=new n.AccumulatePass(e),this._accumulate.initialize(this._ndcTriangle),this._accumulate.precision=this._framePrecision,this._accumulate.texture=this._colorRenderTexture,this._blit=new n.BlitPass(this._context),this._blit.initialize(this._ndcTriangle),this._blit.readBuffer=s.COLOR_ATTACHMENT0,this._blit.drawBuffer=a.BACK,this._blit.target=this._defaultFBO,this._shadowPass=new n.ShadowPass(e),this._shadowPass.initialize(n.ShadowPass.ShadowMappingType.HardLinear,[1024,1024]),this.finishLoading(),!0}onUninitialize(){super.uninitialize(),this._defaultFBO.uninitialize();for(const e of this._cuboids)e.uninitialize();this._plane.uninitialize(),this._ndcTriangle.uninitialize(),this._shadowPass.uninitialize()}onDiscarded(){this._altered.alter("canvasSize"),this._altered.alter("clearColor"),this._altered.alter("frameSize")}onUpdate(){return this._navigation.update(),this._camera.altered}onPrepare(){const e=this._context.gl,i=this._context.gl2facade;if(this._intermediateFBO.initialized||(this._colorRenderTexture.initialize(this._frameSize[0],this._frameSize[1],this._context.isWebGL2?e.RGBA8:e.RGBA,e.RGBA,e.UNSIGNED_BYTE),this._depthRenderbuffer.initialize(this._frameSize[0],this._frameSize[1],e.DEPTH_COMPONENT16),this._intermediateFBO.initialize([[i.COLOR_ATTACHMENT0,this._colorRenderTexture],[e.DEPTH_ATTACHMENT,this._depthRenderbuffer]]),this._intermediateFBO.clearColor([1,1,1,1])),this._altered.frameSize&&(this._intermediateFBO.resize(this._frameSize[0],this._frameSize[1]),this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),this._altered.canvasSize&&(this._camera.aspect=this._canvasSize[0]/this._canvasSize[1]),this._altered.clearColor&&this._defaultFBO.clearColor(this._clearColor),this._altered.multiFrameNumber){this._ndcOffsetKernel=new n.AntiAliasingKernel(this._multiFrameNumber);const e=t.vec3.sub(t.vec3.create(),this._light.eye,this._light.center);t.vec3.normalize(e,e);const i=t.vec3.cross(t.vec3.create(),e,t.vec3.fromValues(0,1,0)),o=t.vec3.cross(t.vec3.create(),e,i);this._lightSamples=new Array(this._multiFrameNumber);for(let e=0;e<this._multiFrameNumber;++e){const n=t.vec3.clone(this._light.eye),r=.25*Math.random(),a=Math.random()*Math.PI*2;t.vec3.scaleAndAdd(n,n,i,r*Math.cos(a)),t.vec3.scaleAndAdd(n,n,o,r*Math.sin(a)),this._lightSamples[e]=n}this._lightSamples.sort(((e,n)=>t.vec3.sqrDist(e,this._light.eye)-t.vec3.sqrDist(n,this._light.eye)))}this._accumulate.update(),this._altered.reset(),this._camera.altered=!1}onFrame(e){const t=this._context.gl;this._light.eye=this._lightSamples[e],this._shadowPass.frame((()=>{t.enable(t.DEPTH_TEST),this._shadowProgram.bind(),t.uniformMatrix4fv(this._uLightViewProjectionS,!1,this._light.viewProjection),t.uniform3fv(this._uLightPositionS,this._light.eye),this.drawCuboids(this._uModelS),this._shadowProgram.unbind(),t.disable(t.DEPTH_TEST)})),this._intermediateFBO.bind(),this._intermediateFBO.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT,!0,!1),t.viewport(0,0,this._frameSize[0],this._frameSize[1]);const n=this._ndcOffsetKernel.get(e);n[0]=2*n[0]/this._frameSize[0],n[1]=2*n[1]/this._frameSize[1],t.enable(t.DEPTH_TEST),t.enable(t.CULL_FACE),this._program.bind(),t.uniformMatrix4fv(this._uViewProjection,!1,this._camera.viewProjection),t.uniformMatrix4fv(this._uLightViewProjection,!1,this._light.viewProjection),t.uniform3fv(this._uLightPosition,this._light.eye),t.uniform2fv(this._uNdcOffset,n),this._shadowPass.shadowMapTexture.bind(t.TEXTURE0),t.uniform1i(this._uColored,Number(!0)),this.drawCuboids(this._uModel),t.uniform1i(this._uColored,Number(!1)),this.drawPlane(this._uModel),this._program.unbind(),this._shadowPass.shadowMapTexture.unbind(),t.disable(t.DEPTH_TEST),t.disable(t.CULL_FACE),this._accumulate.frame(e)}onSwap(){this._blit.framebuffer=this._accumulate.framebuffer?this._accumulate.framebuffer:this._blit.framebuffer=this._intermediateFBO,this._blit.frame()}drawCuboids(e){const n=this._context.gl,i=t.mat4.create();for(let o=0;o<this._cuboids.length;++o){const r=.5*o-.75,a=.5*this._cuboids[o].extent[1];t.mat4.fromTranslation(i,t.vec3.fromValues(-r,a,0)),n.uniformMatrix4fv(e,!1,i),this._cuboids[o].bind(),this._cuboids[o].draw()}}drawPlane(e){this._context.gl.uniformMatrix4fv(e,!1,this._plane.transformation),this._plane.bind(),this._plane.draw()}}class s extends r.Example{onInitialize(e){return this._canvas=new n.Canvas(e),this._canvas.framePrecision=n.Wizard.Precision.half,this._canvas.frameScale=[1,1],this._canvas.clearColor.fromHex("ffffff"),this._canvas.controller.multiFrameNumber=128,this._renderer=new a,this._canvas.renderer=this._renderer,!0}onUninitialize(){this._canvas.dispose(),this._renderer.uninitialize()}get canvas(){return this._canvas}get renderer(){return this._renderer}}e.ShadowMapMultiframeExample=s})(),o})()}));
//# sourceMappingURL=shadowmap-multiframe-example.js.map