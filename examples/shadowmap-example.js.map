{"version":3,"file":"shadowmap-example.js","mappings":"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","sources":["webpack:///webpack/universalModuleDefinition","webpack:///./example.ts","webpack:///./data/mesh-shadowed.frag","webpack:///./data/mesh-shadowed.vert","webpack:///./data/shadow.frag","webpack:///./data/shadow.vert","webpack:///external umd \"gloperate\"","webpack:///webpack/bootstrap","webpack:///./shadowmap-example.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gloperate\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gloperate\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"gloperate\")) : factory(root[\"gloperate\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function(__WEBPACK_EXTERNAL_MODULE__160__) {\nreturn ","\n/* spellchecker: disable */\n\nimport {\n    Canvas,\n    Initializable,\n    LoadingStatus,\n    Renderer,\n    viewer,\n} from 'webgl-operate';\n\n/* spellchecker: enable */\n\n\nexport abstract class Example extends Initializable {\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected showSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'inline';\n    }\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected hideSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'none';\n    }\n\n    protected expose(): void {\n\n        (window as any)['canvas'] = this.canvas;\n        (window as any)['context'] = this.canvas.context;\n        (window as any)['controller'] = this.canvas.controller;\n\n        (window as any)['renderer'] = this.renderer;\n    }\n\n    initialize(element: HTMLCanvasElement | string): boolean {\n        const result = this.onInitialize(element);\n\n        this.renderer.loadingStatus$.subscribe((status: LoadingStatus) => {\n            if (status === LoadingStatus.Finished) {\n                this.hideSpinner();\n            } else if (status === LoadingStatus.Started) {\n                this.showSpinner();\n            }\n        });\n\n        this.expose();\n\n        return result;\n    }\n\n    uninitialize(): void {\n        this.onUninitialize();\n    }\n\n    abstract onInitialize(element: HTMLCanvasElement | string): boolean;\n\n    abstract onUninitialize(): void;\n\n    abstract get renderer(): Renderer;\n\n    abstract get canvas(): Canvas;\n\n    enableFullscreenOnCtrlClick(): void {\n\n        const e = this.canvas.element;\n        e.addEventListener('click', (event) => {\n            if (event.ctrlKey) { viewer.Fullscreen.toggle(e); }\n        });\n    }\n}\n","module.exports = \"\\nprecision lowp float;\\n\\n#if __VERSION__ == 100\\n\\n    #ifdef GL_OES_standard_derivatives\\n        #extension GL_OES_standard_derivatives : enable\\n    #endif\\n\\n#endif\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n\\nuniform vec2 u_lightNearFar;\\nuniform mat4 u_lightViewProjection;\\nuniform vec3 u_lightPosition;\\n\\nuniform bool u_colored;\\n\\nuniform sampler2D u_shadowMap;\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n#else\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\nvarying vec2 v_uv;\\n\\n\\n\\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\\n{\\n    vec4 transformed = shadowViewProjection * worldPosition;\\n    return transformed.xy / transformed.w * 0.5 + 0.5;\\n}\\n\\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\\n}\\n\\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\\n{\\n    float depth = texture(depths, uv).r;\\n    return step(compare + offset, depth);\\n}\\n\\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n\\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\\n    float moment = depth * depth + 0.25 * dot(df, df);\\n\\n    return vec2(depth, moment);\\n}\\n\\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    float p = 0.0;\\n\\n    // Surface is fully lit, as the current fragment is before the light occluder\\n    if (compare <= moments.x)\\n        p = 1.0;\\n\\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\\n    // How likely this pixel is to be lit (p_max)\\n    float variance = moments.y - (moments.x * moments.x);\\n    variance = max(variance, minVariance);\\n\\n    float d = compare - moments.x;\\n    float p_max = variance / (variance + d*d);\\n\\n    // Correct light bleeding\\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\\n\\n    return max(p, p_max);\\n}\\n\\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    vec2 moments = texture(depths, uv).rg;\\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\\n}\\n\\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    return exp(exponent * depth);\\n}\\n\\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\\n{\\n    float expDepth = texture(depths, uv).r;\\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\\n}\\n\\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\\n{\\n    depth = depth * 2.0 - 1.0;\\n    float pos =  exp( exponents.x * depth);\\n    float neg = -exp(-exponents.y * depth);\\n    return vec2(pos, neg);\\n}\\n\\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\\n}\\n\\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\\n{\\n    vec4 moments = texture(depths, uv);\\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\\n    vec2 minVariance = depthScale * depthScale;\\n    return min(\\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\\n    );\\n}\\n\\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\\n// {\\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\\n\\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\\n//   if (visibility < 1.0)\\n//   {\\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\\n//   }\\n\\n//   return finalColor;\\n// }\\n\\n\\n\\nconst vec4 shadowColor = vec4(0.494, 0.753, 0.933, 1.0);\\n\\nconst vec2 shadowExponents = vec2(30.0, 10.0);\\nconst float shadowLightBleedingReduction = 0.1;\\n\\n\\nvoid main(void)\\n{\\n    float light_depth = SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar);\\n    vec2 shadow_uv = SMCoordinates(v_vertex, u_lightViewProjection);\\n\\n    // float visibility = SMCompare(u_shadowMap, shadow_uv, light_depth, shadowBias);\\n    // float visibility = ESMCompare(u_shadowMap, shadow_uv, light_depth, shadowExponent);\\n    // float visibility = VSMCompare(u_shadowMap, shadow_uv, light_depth, shadowMinVariance, shadowLightBleedingReduction);\\n    float visibility = EVSMCompare(u_shadowMap, shadow_uv, light_depth, shadowExponents, shadowLightBleedingReduction);\\n\\n    if (any(greaterThan(shadow_uv, vec2(1.0))) || any(lessThan(shadow_uv, vec2(0.0)))) {\\n        visibility = 1.0;\\n    }\\n\\n    vec4 color = vec4(1.0);\\n    if (u_colored) {\\n        color = vec4(0.8 + (v_vertex.xyz * 0.2 - 0.1), 1.0);\\n    }\\n\\n    fragColor = mix(shadowColor * color, color, visibility);\\n}\\n\"","module.exports = \"\\nprecision lowp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else\\n    #define varying out\\n#endif\\n\\n\\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\\n}\\n\\n\\n\\n#if __VERSION__ == 100\\n    attribute vec3 a_vertex;\\n    attribute vec2 a_texCoord;\\n#else\\n    layout(location = 0) in vec3 a_vertex;\\n    layout(location = 1) in vec2 a_texCoord;\\n#endif\\n\\n\\nuniform mat4 u_viewProjection;\\nuniform mat4 u_model;\\n\\nuniform vec2 u_ndcOffset;\\n\\n\\nvarying vec4 v_vertex;\\nvarying vec2 v_uv;\\n\\n\\nvoid main()\\n{\\n    v_vertex = u_model * vec4(a_vertex, 1.0);\\n    v_uv = a_texCoord;\\n\\n    vec4 vertex = u_viewProjection *  v_vertex;\\n    ndcOffset(vertex, u_ndcOffset);\\n\\n    gl_Position = vertex;\\n}\\n\"","module.exports = \"\\n#if __VERSION__ == 100\\n\\n    #ifdef GL_OES_standard_derivatives\\n        #extension GL_OES_standard_derivatives : enable\\n    #endif\\n\\n#endif\\n\\nprecision highp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n\\nuniform vec2 u_lightNearFar;\\nuniform vec3 u_lightPosition;\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n#else\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\n\\n\\n\\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\\n{\\n    vec4 transformed = shadowViewProjection * worldPosition;\\n    return transformed.xy / transformed.w * 0.5 + 0.5;\\n}\\n\\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\\n}\\n\\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\\n{\\n    float depth = texture(depths, uv).r;\\n    return step(compare + offset, depth);\\n}\\n\\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n\\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\\n    float moment = depth * depth + 0.25 * dot(df, df);\\n\\n    return vec2(depth, moment);\\n}\\n\\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    float p = 0.0;\\n\\n    // Surface is fully lit, as the current fragment is before the light occluder\\n    if (compare <= moments.x)\\n        p = 1.0;\\n\\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\\n    // How likely this pixel is to be lit (p_max)\\n    float variance = moments.y - (moments.x * moments.x);\\n    variance = max(variance, minVariance);\\n\\n    float d = compare - moments.x;\\n    float p_max = variance / (variance + d*d);\\n\\n    // Correct light bleeding\\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\\n\\n    return max(p, p_max);\\n}\\n\\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\\n{\\n    vec2 moments = texture(depths, uv).rg;\\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\\n}\\n\\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    return exp(exponent * depth);\\n}\\n\\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\\n{\\n    float expDepth = texture(depths, uv).r;\\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\\n}\\n\\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\\n{\\n    depth = depth * 2.0 - 1.0;\\n    float pos =  exp( exponents.x * depth);\\n    float neg = -exp(-exponents.y * depth);\\n    return vec2(pos, neg);\\n}\\n\\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\\n{\\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\\n}\\n\\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\\n{\\n    vec4 moments = texture(depths, uv);\\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\\n    vec2 minVariance = depthScale * depthScale;\\n    return min(\\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\\n    );\\n}\\n\\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\\n// {\\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\\n\\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\\n//   if (visibility < 1.0)\\n//   {\\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\\n//   }\\n\\n//   return finalColor;\\n// }\\n\\n\\n\\nconst float shadowExponent = 80.0;\\nconst vec2 shadowExponents = vec2(30.0, 10.0);\\n\\n\\nvoid main(void)\\n{\\n    //fragColor = vec4(SMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 0.0, 1.0);\\n    //fragColor = vec4(ESMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar, shadowExponent), 0.0, 0.0, 1.0);\\n    //fragColor = vec4(VSMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar), 0.0, 1.0);\\n    fragColor = EVSMDepth(v_vertex.xyz, u_lightPosition, u_lightNearFar, shadowExponents);\\n}\\n\"","module.exports = \"\\nprecision highp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else\\n    #define varying out\\n#endif\\n\\n\\n\\nuniform mat4 u_lightViewProjection;\\nuniform mat4 u_model;\\n\\n\\n#if __VERSION__ == 100\\n    attribute vec3 a_vertex;\\n#else\\n    layout(location = 0) in vec3 a_vertex;\\n#endif\\n\\n\\nvarying vec4 v_vertex;\\n\\n\\nvoid main()\\n{\\n    v_vertex = u_model * vec4(a_vertex, 1.0);\\n    gl_Position = u_lightViewProjection * v_vertex;\\n}\\n\"","module.exports = __WEBPACK_EXTERNAL_MODULE__160__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nimport { mat4, vec2, vec3, vec4 } from 'webgl-operate';\n\nimport {\n    Camera,\n    Canvas,\n    Context,\n    CuboidGeometry,\n    DebugPass,\n    DefaultFramebuffer,\n    EventProvider,\n    Invalidate,\n    Navigation,\n    PlaneGeometry,\n    Program,\n    Renderer,\n    Shader,\n    ShadowPass,\n    Wizard,\n} from 'webgl-operate';\n\nimport { Example } from './example';\n\n// tslint:disable:max-classes-per-file\n\n\nclass ShadowMapRenderer extends Renderer {\n\n    protected _cuboids: Array<CuboidGeometry>;\n    protected _plane: PlaneGeometry;\n\n    protected _defaultFBO: DefaultFramebuffer;\n    protected _navigation: Navigation;\n\n    protected _camera: Camera;\n    protected _light: Camera;\n\n    protected _program: Program;\n    protected _uViewProjection: WebGLUniformLocation;\n    protected _uModel: WebGLUniformLocation;\n    protected _uColored: WebGLUniformLocation;\n\n    protected _shadowProgram: Program;\n    protected _uModelS: WebGLUniformLocation;\n\n    protected _shadowPass: ShadowPass;\n    protected _debugPass: DebugPass;\n\n    protected onInitialize(context: Context, callback: Invalidate,\n        eventProvider: EventProvider): boolean {\n\n        context.enable(['ANGLE_instanced_arrays', 'OES_standard_derivatives',\n            'WEBGL_color_buffer_float', 'OES_texture_float', 'OES_texture_float_linear']);\n\n        this._defaultFBO = new DefaultFramebuffer(context, 'DefaultFBO');\n        this._defaultFBO.initialize();\n        this._defaultFBO.bind();\n\n        const gl = context.gl as WebGLRenderingContext;\n\n\n        this._cuboids = new Array(4);\n        for (let i = 0; i < this._cuboids.length; ++i) {\n            this._cuboids[i] = new CuboidGeometry(context, 'cube', true, [0.25, 0.5 + 0.5 * i, 2.0]);\n            this._cuboids[i].initialize();\n        }\n\n        this._plane = new PlaneGeometry(context, 'plane');\n        this._plane.initialize();\n        this._plane.scale = vec2.fromValues(5.0, 5.0);\n\n        if (this._camera === undefined) {\n            this._camera = new Camera();\n            this._camera.center = vec3.fromValues(0.0, 0.75, 0.0);\n            this._camera.up = vec3.fromValues(0.0, 1.0, 0.0);\n            this._camera.eye = vec3.fromValues(1.8, 2.6, 3.4);\n            this._camera.near = 2.0;\n            this._camera.far = 11.0;\n        }\n\n        if (this._light === undefined) {\n            this._light = new Camera();\n            this._light.center = vec3.fromValues(0.0, 0.75, 0.0);\n            this._light.up = vec3.fromValues(0.0, 1.0, 0.0);\n            this._light.eye = vec3.fromValues(-3.0, 5.0, 4.0);\n            this._light.fovy = 30.0;\n            this._light.near = 4.0;\n            this._light.far = 20.0;\n        }\n\n        const vert = new Shader(context, gl.VERTEX_SHADER, 'mesh-shadowed.vert');\n        vert.initialize(require('./data/mesh-shadowed.vert'));\n        const frag = new Shader(context, gl.FRAGMENT_SHADER, 'mesh-shadowed.frag');\n        frag.initialize(require('./data/mesh-shadowed.frag'));\n\n        this._program = new Program(context, 'MeshShadowedProgram');\n        this._program.initialize([vert, frag], false);\n\n        this._program.attribute('a_vertex', this._cuboids[0].vertexLocation);\n        this._program.attribute('a_texCoord', this._cuboids[0].uvCoordLocation);\n        this._program.link();\n        this._program.bind();\n\n        gl.uniform2f(this._program.uniform('u_lightNearFar'), this._light.near, this._light.far);\n        gl.uniformMatrix4fv(this._program.uniform('u_lightViewProjection'), false, this._light.viewProjection);\n        gl.uniform3fv(this._program.uniform('u_lightPosition'), this._light.eye);\n\n        gl.uniform1i(this._program.uniform('u_shadowMap'), 0);\n\n        this._uViewProjection = this._program.uniform('u_viewProjection');\n        this._uModel = this._program.uniform('u_model');\n\n        this._uColored = this._program.uniform('u_colored');\n\n        const shadowVert = new Shader(context, gl.VERTEX_SHADER, 'shadow.vert');\n        shadowVert.initialize(require('./data/shadow.vert'));\n        const shadowFrag = new Shader(context, gl.FRAGMENT_SHADER, 'shadow.frag');\n        shadowFrag.initialize(require('./data/shadow.frag'));\n\n        this._shadowProgram = new Program(context);\n        this._shadowProgram.initialize([shadowVert, shadowFrag], false);\n        this._shadowProgram.attribute('a_vertex', this._cuboids[0].vertexLocation);\n        this._shadowProgram.link();\n        this._shadowProgram.bind();\n\n        gl.uniform2f(this._shadowProgram.uniform('u_lightNearFar'), this._light.near, this._light.far);\n        gl.uniformMatrix4fv(this._shadowProgram.uniform('u_lightViewProjection'), false, this._light.viewProjection);\n        gl.uniform3fv(this._shadowProgram.uniform('u_lightPosition'), this._light.eye);\n\n        this._uModelS = this._shadowProgram.uniform('u_model');\n\n\n        this._navigation = new Navigation(callback, eventProvider);\n        this._navigation.camera = this._camera;\n\n\n        this._shadowPass = new ShadowPass(context);\n        this._shadowPass.initialize(ShadowPass.ShadowMappingType.HardLinear,\n            [1024, 1024], [1024, 1024]);\n\n\n        this._debugPass = new DebugPass(context);\n        this._debugPass.initialize();\n\n        this._debugPass.framebuffer = this._shadowPass.shadowMapFBO;\n        this._debugPass.readBuffer = gl.COLOR_ATTACHMENT0;\n\n        this._debugPass.target = this._defaultFBO;\n        this._debugPass.drawBuffer = gl.BACK;\n\n\n        this.finishLoading();\n\n        return true;\n    }\n\n    protected onUninitialize(): void {\n        super.uninitialize();\n\n        this._defaultFBO.uninitialize();\n\n        for (const cuboid of this._cuboids) {\n            cuboid.uninitialize();\n        }\n        this._plane.uninitialize();\n\n        this._shadowPass.uninitialize();\n    }\n\n    protected onDiscarded(): void {\n        this._altered.alter('canvasSize');\n        this._altered.alter('clearColor');\n        this._altered.alter('frameSize');\n    }\n\n    protected onUpdate(): boolean {\n        this._navigation.update();\n        return this._camera.altered;\n    }\n\n    protected onPrepare(): void {\n        if (this._altered.frameSize) {\n            this._camera.viewport = [this._frameSize[0], this._frameSize[1]];\n        }\n        if (this._altered.canvasSize) {\n            this._camera.aspect = this._canvasSize[0] / this._canvasSize[1];\n\n            this._debugPass.dstBounds = vec4.fromValues(\n                this._canvasSize[0] * (1.0 - 0.187), this._canvasSize[1] * (1.0 - 0.187 * this._camera.aspect),\n                this._canvasSize[0] * (1.0 - 0.008), this._canvasSize[1] * (1.0 - 0.008 * this._camera.aspect));\n        }\n\n        if (this._altered.clearColor) {\n            this._defaultFBO.clearColor(this._clearColor);\n        }\n\n        if (this._camera.altered) {\n            this._debugPass.far = this._camera.far;\n            this._debugPass.near = this._camera.near;\n        }\n\n        this._camera.altered = false;\n        this._altered.reset();\n    }\n\n    protected onFrame(frameNumber: number): void {\n        const gl = this._context.gl as WebGLRenderingContext;\n\n        this._shadowPass.frame(() => {\n            gl.enable(gl.DEPTH_TEST);\n            this._shadowProgram.bind();\n            this.drawCuboids(this._uModelS);\n            this._shadowProgram.unbind();\n            gl.disable(gl.DEPTH_TEST);\n        });\n\n        this._defaultFBO.bind();\n        this._defaultFBO.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, true, false);\n\n        gl.viewport(0, 0, this._frameSize[0], this._frameSize[1]);\n\n        gl.enable(gl.DEPTH_TEST);\n        gl.enable(gl.CULL_FACE);\n\n        this._program.bind();\n        gl.uniformMatrix4fv(this._uViewProjection, false, this._camera.viewProjection);\n\n        this._shadowPass.shadowMapTexture.bind(gl.TEXTURE0);\n\n        gl.uniform1i(this._uColored, Number(true));\n        this.drawCuboids(this._uModel);\n\n        gl.uniform1i(this._uColored, Number(false));\n\n        gl.uniformMatrix4fv(this._uModel, false, this._plane.transformation);\n        this._plane.bind();\n        this._plane.draw();\n\n        this._program.unbind();\n        this._shadowPass.shadowMapTexture.unbind();\n\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.CULL_FACE);\n    }\n\n    protected onSwap(): void {\n        this._debugPass.frame();\n    }\n\n    protected drawCuboids(model: WebGLUniformLocation): void {\n        const gl = this._context.gl;\n\n        const M = mat4.create();\n        for (let i = 0; i < this._cuboids.length; ++i) {\n\n            const x = i * 0.5 - 0.75;\n            const y = this._cuboids[i].extent[1] * 0.5;\n\n            mat4.fromTranslation(M, vec3.fromValues(-x, y, 0.0));\n            gl.uniformMatrix4fv(model, false, M);\n\n            this._cuboids[i].bind();\n            this._cuboids[i].draw();\n        }\n    }\n\n    protected drawPlane(model: WebGLUniformLocation): void {\n\n    }\n\n}\n\nexport class ShadowMapExample extends Example {\n\n    private _canvas: Canvas;\n    private _renderer: ShadowMapRenderer;\n\n    onInitialize(element: HTMLCanvasElement | string): boolean {\n\n        this._canvas = new Canvas(element);\n        this._canvas.controller.multiFrameNumber = 1;\n        this._canvas.framePrecision = Wizard.Precision.byte;\n        this._canvas.frameScale = [1.0, 1.0];\n\n        this._canvas.clearColor.fromHex('ffffff');\n\n        this._renderer = new ShadowMapRenderer();\n        this._canvas.renderer = this._renderer;\n\n        return true;\n    }\n\n    onUninitialize(): void {\n        this._canvas.dispose();\n        (this._renderer as Renderer).uninitialize();\n    }\n\n    get canvas(): Canvas {\n        return this._canvas;\n    }\n\n    get renderer(): ShadowMapRenderer {\n        return this._renderer;\n    }\n\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__160__","Example","Initializable","showSpinner","document","getElementsByClassName","item","style","display","hideSpinner","expose","window","this","canvas","context","controller","renderer","initialize","element","result","onInitialize","loadingStatus$","subscribe","status","LoadingStatus","Finished","Started","uninitialize","onUninitialize","enableFullscreenOnCtrlClick","e","addEventListener","event","ctrlKey","viewer","Fullscreen","toggle","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","ShadowMapRenderer","Renderer","callback","eventProvider","enable","_defaultFBO","DefaultFramebuffer","bind","gl","_cuboids","Array","length","CuboidGeometry","_plane","PlaneGeometry","scale","vec2","fromValues","_camera","Camera","center","vec3","up","eye","near","far","_light","fovy","vert","Shader","VERTEX_SHADER","frag","FRAGMENT_SHADER","_program","Program","attribute","vertexLocation","uvCoordLocation","link","uniform2f","uniform","uniformMatrix4fv","viewProjection","uniform3fv","uniform1i","_uViewProjection","_uModel","_uColored","shadowVert","shadowFrag","_shadowProgram","_uModelS","_navigation","Navigation","camera","_shadowPass","ShadowPass","ShadowMappingType","HardLinear","_debugPass","DebugPass","framebuffer","shadowMapFBO","readBuffer","COLOR_ATTACHMENT0","target","drawBuffer","BACK","finishLoading","super","cuboid","onDiscarded","_altered","alter","onUpdate","update","altered","onPrepare","frameSize","viewport","_frameSize","canvasSize","aspect","_canvasSize","dstBounds","vec4","clearColor","_clearColor","reset","onFrame","frameNumber","_context","frame","DEPTH_TEST","drawCuboids","unbind","disable","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","CULL_FACE","shadowMapTexture","TEXTURE0","Number","transformation","draw","onSwap","model","M","mat4","create","x","y","extent","fromTranslation","drawPlane","ShadowMapExample","_canvas","Canvas","multiFrameNumber","framePrecision","Wizard","Precision","byte","frameScale","fromHex","_renderer","dispose"],"sourceRoot":""}