!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n(require("gloperate"));else if("function"==typeof define&&define.amd)define(["gloperate"],n);else{var t="object"==typeof exports?n(require("gloperate")):n(e.gloperate);for(var i in t)("object"==typeof exports?exports:e)[i]=t[i]}}(self,(e=>(()=>{var n={659:(e,n,t)=>{"use strict";t.r(n),t.d(n,{glMatrix:()=>i,mat2:()=>r,mat2d:()=>a,mat3:()=>o,mat4:()=>s,quat:()=>l,quat2:()=>h,vec2:()=>f,vec3:()=>c,vec4:()=>u});var i={};t.r(i),t.d(i,{ARRAY_TYPE:()=>d,EPSILON:()=>m,RANDOM:()=>p,equals:()=>M,setMatrixArrayType:()=>v,toRadian:()=>g});var r={};t.r(r),t.d(r,{LDU:()=>O,add:()=>z,adjoint:()=>R,clone:()=>x,copy:()=>S,create:()=>b,determinant:()=>F,equals:()=>G,exactEquals:()=>k,frob:()=>B,fromRotation:()=>D,fromScaling:()=>C,fromValues:()=>y,identity:()=>w,invert:()=>T,mul:()=>H,multiply:()=>E,multiplyScalar:()=>U,multiplyScalarAndAdd:()=>q,rotate:()=>N,scale:()=>A,set:()=>L,str:()=>V,sub:()=>j,subtract:()=>I,transpose:()=>P});var a={};t.r(a),t.d(a,{add:()=>ue,clone:()=>W,copy:()=>$,create:()=>X,determinant:()=>J,equals:()=>de,exactEquals:()=>me,frob:()=>ce,fromRotation:()=>re,fromScaling:()=>ae,fromTranslation:()=>oe,fromValues:()=>Q,identity:()=>K,invert:()=>Z,mul:()=>pe,multiply:()=>ee,multiplyScalar:()=>he,multiplyScalarAndAdd:()=>fe,rotate:()=>ne,scale:()=>te,set:()=>Y,str:()=>se,sub:()=>ve,subtract:()=>le,translate:()=>ie});var o={};t.r(o),t.d(o,{add:()=>Ge,adjoint:()=>Pe,clone:()=>Me,copy:()=>be,create:()=>_e,determinant:()=>Te,equals:()=>Xe,exactEquals:()=>je,frob:()=>ke,fromMat2d:()=>Ve,fromMat4:()=>ge,fromQuat:()=>Be,fromRotation:()=>De,fromScaling:()=>Ce,fromTranslation:()=>Ae,fromValues:()=>xe,identity:()=>we,invert:()=>Le,mul:()=>We,multiply:()=>Re,multiplyScalar:()=>qe,multiplyScalarAndAdd:()=>He,normalFromMat4:()=>Oe,projection:()=>ze,rotate:()=>Ee,scale:()=>Ne,set:()=>Se,str:()=>Ie,sub:()=>$e,subtract:()=>Ue,translate:()=>Fe,transpose:()=>ye});var s={};t.r(s),t.d(s,{add:()=>Vn,adjoint:()=>rn,clone:()=>Qe,copy:()=>Ye,create:()=>Ke,determinant:()=>an,equals:()=>kn,exactEquals:()=>In,frob:()=>Cn,fromQuat:()=>Pn,fromQuat2:()=>bn,fromRotation:()=>pn,fromRotationTranslation:()=>Mn,fromRotationTranslationScale:()=>yn,fromRotationTranslationScaleOrigin:()=>Ln,fromScaling:()=>dn,fromTranslation:()=>mn,fromValues:()=>Ze,fromXRotation:()=>vn,fromYRotation:()=>_n,fromZRotation:()=>gn,frustum:()=>Tn,getRotation:()=>wn,getScaling:()=>Sn,getTranslation:()=>xn,identity:()=>en,invert:()=>tn,lookAt:()=>Nn,mul:()=>Gn,multiply:()=>on,multiplyScalar:()=>On,multiplyScalarAndAdd:()=>zn,ortho:()=>En,perspective:()=>Rn,perspectiveFromFieldOfView:()=>Fn,rotate:()=>un,rotateX:()=>ln,rotateY:()=>hn,rotateZ:()=>fn,scale:()=>cn,set:()=>Je,str:()=>Dn,sub:()=>Un,subtract:()=>Bn,targetTo:()=>An,translate:()=>sn,transpose:()=>nn});var c={};t.r(c),t.d(c,{add:()=>Kn,angle:()=>yt,bezier:()=>vt,ceil:()=>Jn,clone:()=>Hn,copy:()=>Wn,create:()=>qn,cross:()=>mt,dist:()=>Dt,distance:()=>ot,div:()=>At,divide:()=>Zn,dot:()=>ft,equals:()=>Rt,exactEquals:()=>Tt,floor:()=>et,forEach:()=>Ot,fromValues:()=>Xn,hermite:()=>pt,inverse:()=>lt,len:()=>Vt,length:()=>jn,lerp:()=>dt,max:()=>tt,min:()=>nt,mul:()=>Nt,multiply:()=>Yn,negate:()=>ut,normalize:()=>ht,random:()=>_t,rotateX:()=>xt,rotateY:()=>St,rotateZ:()=>wt,round:()=>it,scale:()=>rt,scaleAndAdd:()=>at,set:()=>$n,sqrDist:()=>Ct,sqrLen:()=>Bt,squaredDistance:()=>st,squaredLength:()=>ct,str:()=>Pt,sub:()=>Et,subtract:()=>Qn,transformMat3:()=>Mt,transformMat4:()=>gt,transformQuat:()=>bt,zero:()=>Lt});var u={};t.r(u),t.d(u,{add:()=>qt,ceil:()=>Wt,clone:()=>It,copy:()=>Gt,create:()=>zt,cross:()=>ci,dist:()=>bi,distance:()=>ei,div:()=>Mi,divide:()=>Xt,dot:()=>si,equals:()=>vi,exactEquals:()=>pi,floor:()=>$t,forEach:()=>yi,fromValues:()=>kt,inverse:()=>ai,len:()=>Si,length:()=>ti,lerp:()=>ui,max:()=>Qt,min:()=>Kt,mul:()=>gi,multiply:()=>jt,negate:()=>ri,normalize:()=>oi,random:()=>li,round:()=>Yt,scale:()=>Zt,scaleAndAdd:()=>Jt,set:()=>Ut,sqrDist:()=>xi,sqrLen:()=>wi,squaredDistance:()=>ni,squaredLength:()=>ii,str:()=>di,sub:()=>_i,subtract:()=>Ht,transformMat4:()=>hi,transformQuat:()=>fi,zero:()=>mi});var l={};t.r(l),t.d(l,{add:()=>nr,calculateW:()=>Ci,clone:()=>Yi,conjugate:()=>Gi,copy:()=>Ji,create:()=>Li,dot:()=>rr,equals:()=>fr,exactEquals:()=>hr,exp:()=>Vi,fromEuler:()=>qi,fromMat3:()=>Ui,fromValues:()=>Zi,getAngle:()=>Fi,getAxisAngle:()=>Ri,identity:()=>Pi,invert:()=>ki,len:()=>sr,length:()=>or,lerp:()=>ar,ln:()=>Bi,mul:()=>tr,multiply:()=>Ei,normalize:()=>lr,pow:()=>Oi,random:()=>Ii,rotateX:()=>Ni,rotateY:()=>Ai,rotateZ:()=>Di,rotationTo:()=>mr,scale:()=>ir,set:()=>er,setAxes:()=>pr,setAxisAngle:()=>Ti,slerp:()=>zi,sqlerp:()=>dr,sqrLen:()=>ur,squaredLength:()=>cr,str:()=>Hi});var h={};t.r(h),t.d(h,{add:()=>Ir,clone:()=>_r,conjugate:()=>Xr,copy:()=>yr,create:()=>vr,dot:()=>qr,equals:()=>ea,exactEquals:()=>Jr,fromMat4:()=>wr,fromRotation:()=>Sr,fromRotationTranslation:()=>br,fromRotationTranslationValues:()=>Mr,fromTranslation:()=>xr,fromValues:()=>gr,getDual:()=>Rr,getReal:()=>Tr,getTranslation:()=>Nr,identity:()=>Lr,invert:()=>jr,len:()=>$r,length:()=>Wr,lerp:()=>Hr,mul:()=>Gr,multiply:()=>kr,normalize:()=>Yr,rotateAroundAxis:()=>zr,rotateByQuatAppend:()=>Br,rotateByQuatPrepend:()=>Or,rotateX:()=>Dr,rotateY:()=>Cr,rotateZ:()=>Vr,scale:()=>Ur,set:()=>Pr,setDual:()=>Er,setReal:()=>Fr,sqrLen:()=>Qr,squaredLength:()=>Kr,str:()=>Zr,translate:()=>Ar});var f={};t.r(f),t.d(f,{add:()=>oa,angle:()=>Da,ceil:()=>la,clone:()=>ta,copy:()=>ra,create:()=>na,cross:()=>La,dist:()=>Ua,distance:()=>_a,div:()=>Ga,divide:()=>ua,dot:()=>ya,equals:()=>Oa,exactEquals:()=>Ba,floor:()=>ha,forEach:()=>ja,fromValues:()=>ia,inverse:()=>Sa,len:()=>za,length:()=>Ma,lerp:()=>Pa,max:()=>ma,min:()=>fa,mul:()=>ka,multiply:()=>ca,negate:()=>xa,normalize:()=>wa,random:()=>Ta,rotate:()=>Aa,round:()=>da,scale:()=>pa,scaleAndAdd:()=>va,set:()=>aa,sqrDist:()=>qa,sqrLen:()=>Ha,squaredDistance:()=>ga,squaredLength:()=>ba,str:()=>Va,sub:()=>Ia,subtract:()=>sa,transformMat2:()=>Ra,transformMat2d:()=>Fa,transformMat3:()=>Ea,transformMat4:()=>Na,zero:()=>Ca});var m=1e-6,d="undefined"!=typeof Float32Array?Float32Array:Array,p=Math.random;function v(e){d=e}var _=Math.PI/180;function g(e){return e*_}function M(e,n){return Math.abs(e-n)<=m*Math.max(1,Math.abs(e),Math.abs(n))}function b(){var e=new d(4);return d!=Float32Array&&(e[1]=0,e[2]=0),e[0]=1,e[3]=1,e}function x(e){var n=new d(4);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n}function S(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e}function w(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e}function y(e,n,t,i){var r=new d(4);return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r}function L(e,n,t,i,r){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e}function P(e,n){if(e===n){var t=n[1];e[1]=n[2],e[2]=t}else e[0]=n[0],e[1]=n[2],e[2]=n[1],e[3]=n[3];return e}function T(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=t*a-r*i;return o?(o=1/o,e[0]=a*o,e[1]=-i*o,e[2]=-r*o,e[3]=t*o,e):null}function R(e,n){var t=n[0];return e[0]=n[3],e[1]=-n[1],e[2]=-n[2],e[3]=t,e}function F(e){return e[0]*e[3]-e[2]*e[1]}function E(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=t[0],c=t[1],u=t[2],l=t[3];return e[0]=i*s+a*c,e[1]=r*s+o*c,e[2]=i*u+a*l,e[3]=r*u+o*l,e}function N(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=Math.sin(t),c=Math.cos(t);return e[0]=i*c+a*s,e[1]=r*c+o*s,e[2]=i*-s+a*c,e[3]=r*-s+o*c,e}function A(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=t[0],c=t[1];return e[0]=i*s,e[1]=r*s,e[2]=a*c,e[3]=o*c,e}function D(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=t,e[2]=-t,e[3]=i,e}function C(e,n){return e[0]=n[0],e[1]=0,e[2]=0,e[3]=n[1],e}function V(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function B(e){return Math.hypot(e[0],e[1],e[2],e[3])}function O(e,n,t,i){return e[2]=i[2]/i[0],t[0]=i[0],t[1]=i[1],t[3]=i[3]-e[2]*t[1],[e,n,t]}function z(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e}function I(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e}function k(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]}function G(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=n[0],s=n[1],c=n[2],u=n[3];return Math.abs(t-o)<=m*Math.max(1,Math.abs(t),Math.abs(o))&&Math.abs(i-s)<=m*Math.max(1,Math.abs(i),Math.abs(s))&&Math.abs(r-c)<=m*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(a-u)<=m*Math.max(1,Math.abs(a),Math.abs(u))}function U(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e}function q(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e[3]=n[3]+t[3]*i,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var H=E,j=I;function X(){var e=new d(6);return d!=Float32Array&&(e[1]=0,e[2]=0,e[4]=0,e[5]=0),e[0]=1,e[3]=1,e}function W(e){var n=new d(6);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n}function $(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e}function K(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e}function Q(e,n,t,i,r,a){var o=new d(6);return o[0]=e,o[1]=n,o[2]=t,o[3]=i,o[4]=r,o[5]=a,o}function Y(e,n,t,i,r,a,o){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e[4]=a,e[5]=o,e}function Z(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=t*a-i*r;return c?(c=1/c,e[0]=a*c,e[1]=-i*c,e[2]=-r*c,e[3]=t*c,e[4]=(r*s-a*o)*c,e[5]=(i*o-t*s)*c,e):null}function J(e){return e[0]*e[3]-e[1]*e[2]}function ee(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=t[0],l=t[1],h=t[2],f=t[3],m=t[4],d=t[5];return e[0]=i*u+a*l,e[1]=r*u+o*l,e[2]=i*h+a*f,e[3]=r*h+o*f,e[4]=i*m+a*d+s,e[5]=r*m+o*d+c,e}function ne(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=Math.sin(t),l=Math.cos(t);return e[0]=i*l+a*u,e[1]=r*l+o*u,e[2]=i*-u+a*l,e[3]=r*-u+o*l,e[4]=s,e[5]=c,e}function te(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=t[0],l=t[1];return e[0]=i*u,e[1]=r*u,e[2]=a*l,e[3]=o*l,e[4]=s,e[5]=c,e}function ie(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=t[0],l=t[1];return e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=i*u+a*l+s,e[5]=r*u+o*l+c,e}function re(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=t,e[2]=-t,e[3]=i,e[4]=0,e[5]=0,e}function ae(e,n){return e[0]=n[0],e[1]=0,e[2]=0,e[3]=n[1],e[4]=0,e[5]=0,e}function oe(e,n){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=n[0],e[5]=n[1],e}function se(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"}function ce(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],1)}function ue(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e[4]=n[4]+t[4],e[5]=n[5]+t[5],e}function le(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e[4]=n[4]-t[4],e[5]=n[5]-t[5],e}function he(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e[4]=n[4]*t,e[5]=n[5]*t,e}function fe(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e[3]=n[3]+t[3]*i,e[4]=n[4]+t[4]*i,e[5]=n[5]+t[5]*i,e}function me(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]}function de(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=e[4],s=e[5],c=n[0],u=n[1],l=n[2],h=n[3],f=n[4],d=n[5];return Math.abs(t-c)<=m*Math.max(1,Math.abs(t),Math.abs(c))&&Math.abs(i-u)<=m*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(r-l)<=m*Math.max(1,Math.abs(r),Math.abs(l))&&Math.abs(a-h)<=m*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(o-f)<=m*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(s-d)<=m*Math.max(1,Math.abs(s),Math.abs(d))}var pe=ee,ve=le;function _e(){var e=new d(9);return d!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function ge(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[4],e[4]=n[5],e[5]=n[6],e[6]=n[8],e[7]=n[9],e[8]=n[10],e}function Me(e){var n=new d(9);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n}function be(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e}function xe(e,n,t,i,r,a,o,s,c){var u=new d(9);return u[0]=e,u[1]=n,u[2]=t,u[3]=i,u[4]=r,u[5]=a,u[6]=o,u[7]=s,u[8]=c,u}function Se(e,n,t,i,r,a,o,s,c,u){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e[4]=a,e[5]=o,e[6]=s,e[7]=c,e[8]=u,e}function we(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function ye(e,n){if(e===n){var t=n[1],i=n[2],r=n[5];e[1]=n[3],e[2]=n[6],e[3]=t,e[5]=n[7],e[6]=i,e[7]=r}else e[0]=n[0],e[1]=n[3],e[2]=n[6],e[3]=n[1],e[4]=n[4],e[5]=n[7],e[6]=n[2],e[7]=n[5],e[8]=n[8];return e}function Le(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=n[6],u=n[7],l=n[8],h=l*o-s*u,f=-l*a+s*c,m=u*a-o*c,d=t*h+i*f+r*m;return d?(d=1/d,e[0]=h*d,e[1]=(-l*i+r*u)*d,e[2]=(s*i-r*o)*d,e[3]=f*d,e[4]=(l*t-r*c)*d,e[5]=(-s*t+r*a)*d,e[6]=m*d,e[7]=(-u*t+i*c)*d,e[8]=(o*t-i*a)*d,e):null}function Pe(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=n[6],u=n[7],l=n[8];return e[0]=o*l-s*u,e[1]=r*u-i*l,e[2]=i*s-r*o,e[3]=s*c-a*l,e[4]=t*l-r*c,e[5]=r*a-t*s,e[6]=a*u-o*c,e[7]=i*c-t*u,e[8]=t*o-i*a,e}function Te(e){var n=e[0],t=e[1],i=e[2],r=e[3],a=e[4],o=e[5],s=e[6],c=e[7],u=e[8];return n*(u*a-o*c)+t*(-u*r+o*s)+i*(c*r-a*s)}function Re(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=n[8],f=t[0],m=t[1],d=t[2],p=t[3],v=t[4],_=t[5],g=t[6],M=t[7],b=t[8];return e[0]=f*i+m*o+d*u,e[1]=f*r+m*s+d*l,e[2]=f*a+m*c+d*h,e[3]=p*i+v*o+_*u,e[4]=p*r+v*s+_*l,e[5]=p*a+v*c+_*h,e[6]=g*i+M*o+b*u,e[7]=g*r+M*s+b*l,e[8]=g*a+M*c+b*h,e}function Fe(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=n[8],f=t[0],m=t[1];return e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=s,e[5]=c,e[6]=f*i+m*o+u,e[7]=f*r+m*s+l,e[8]=f*a+m*c+h,e}function Ee(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=n[8],f=Math.sin(t),m=Math.cos(t);return e[0]=m*i+f*o,e[1]=m*r+f*s,e[2]=m*a+f*c,e[3]=m*o-f*i,e[4]=m*s-f*r,e[5]=m*c-f*a,e[6]=u,e[7]=l,e[8]=h,e}function Ne(e,n,t){var i=t[0],r=t[1];return e[0]=i*n[0],e[1]=i*n[1],e[2]=i*n[2],e[3]=r*n[3],e[4]=r*n[4],e[5]=r*n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e}function Ae(e,n){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=n[0],e[7]=n[1],e[8]=1,e}function De(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=t,e[2]=0,e[3]=-t,e[4]=i,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ce(e,n){return e[0]=n[0],e[1]=0,e[2]=0,e[3]=0,e[4]=n[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ve(e,n){return e[0]=n[0],e[1]=n[1],e[2]=0,e[3]=n[2],e[4]=n[3],e[5]=0,e[6]=n[4],e[7]=n[5],e[8]=1,e}function Be(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=t+t,s=i+i,c=r+r,u=t*o,l=i*o,h=i*s,f=r*o,m=r*s,d=r*c,p=a*o,v=a*s,_=a*c;return e[0]=1-h-d,e[3]=l-_,e[6]=f+v,e[1]=l+_,e[4]=1-u-d,e[7]=m-p,e[2]=f-v,e[5]=m+p,e[8]=1-u-h,e}function Oe(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=n[6],u=n[7],l=n[8],h=n[9],f=n[10],m=n[11],d=n[12],p=n[13],v=n[14],_=n[15],g=t*s-i*o,M=t*c-r*o,b=t*u-a*o,x=i*c-r*s,S=i*u-a*s,w=r*u-a*c,y=l*p-h*d,L=l*v-f*d,P=l*_-m*d,T=h*v-f*p,R=h*_-m*p,F=f*_-m*v,E=g*F-M*R+b*T+x*P-S*L+w*y;return E?(E=1/E,e[0]=(s*F-c*R+u*T)*E,e[1]=(c*P-o*F-u*L)*E,e[2]=(o*R-s*P+u*y)*E,e[3]=(r*R-i*F-a*T)*E,e[4]=(t*F-r*P+a*L)*E,e[5]=(i*P-t*R-a*y)*E,e[6]=(p*w-v*S+_*x)*E,e[7]=(v*b-d*w-_*M)*E,e[8]=(d*S-p*b+_*g)*E,e):null}function ze(e,n,t){return e[0]=2/n,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/t,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Ie(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function ke(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Ge(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e[4]=n[4]+t[4],e[5]=n[5]+t[5],e[6]=n[6]+t[6],e[7]=n[7]+t[7],e[8]=n[8]+t[8],e}function Ue(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e[4]=n[4]-t[4],e[5]=n[5]-t[5],e[6]=n[6]-t[6],e[7]=n[7]-t[7],e[8]=n[8]-t[8],e}function qe(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e[4]=n[4]*t,e[5]=n[5]*t,e[6]=n[6]*t,e[7]=n[7]*t,e[8]=n[8]*t,e}function He(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e[3]=n[3]+t[3]*i,e[4]=n[4]+t[4]*i,e[5]=n[5]+t[5]*i,e[6]=n[6]+t[6]*i,e[7]=n[7]+t[7]*i,e[8]=n[8]+t[8]*i,e}function je(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]&&e[6]===n[6]&&e[7]===n[7]&&e[8]===n[8]}function Xe(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=e[4],s=e[5],c=e[6],u=e[7],l=e[8],h=n[0],f=n[1],d=n[2],p=n[3],v=n[4],_=n[5],g=n[6],M=n[7],b=n[8];return Math.abs(t-h)<=m*Math.max(1,Math.abs(t),Math.abs(h))&&Math.abs(i-f)<=m*Math.max(1,Math.abs(i),Math.abs(f))&&Math.abs(r-d)<=m*Math.max(1,Math.abs(r),Math.abs(d))&&Math.abs(a-p)<=m*Math.max(1,Math.abs(a),Math.abs(p))&&Math.abs(o-v)<=m*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(s-_)<=m*Math.max(1,Math.abs(s),Math.abs(_))&&Math.abs(c-g)<=m*Math.max(1,Math.abs(c),Math.abs(g))&&Math.abs(u-M)<=m*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(l-b)<=m*Math.max(1,Math.abs(l),Math.abs(b))}var We=Re,$e=Ue;function Ke(){var e=new d(16);return d!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function Qe(e){var n=new d(16);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n}function Ye(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],e}function Ze(e,n,t,i,r,a,o,s,c,u,l,h,f,m,p,v){var _=new d(16);return _[0]=e,_[1]=n,_[2]=t,_[3]=i,_[4]=r,_[5]=a,_[6]=o,_[7]=s,_[8]=c,_[9]=u,_[10]=l,_[11]=h,_[12]=f,_[13]=m,_[14]=p,_[15]=v,_}function Je(e,n,t,i,r,a,o,s,c,u,l,h,f,m,d,p,v){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e[4]=a,e[5]=o,e[6]=s,e[7]=c,e[8]=u,e[9]=l,e[10]=h,e[11]=f,e[12]=m,e[13]=d,e[14]=p,e[15]=v,e}function en(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function nn(e,n){if(e===n){var t=n[1],i=n[2],r=n[3],a=n[6],o=n[7],s=n[11];e[1]=n[4],e[2]=n[8],e[3]=n[12],e[4]=t,e[6]=n[9],e[7]=n[13],e[8]=i,e[9]=a,e[11]=n[14],e[12]=r,e[13]=o,e[14]=s}else e[0]=n[0],e[1]=n[4],e[2]=n[8],e[3]=n[12],e[4]=n[1],e[5]=n[5],e[6]=n[9],e[7]=n[13],e[8]=n[2],e[9]=n[6],e[10]=n[10],e[11]=n[14],e[12]=n[3],e[13]=n[7],e[14]=n[11],e[15]=n[15];return e}function tn(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=n[6],u=n[7],l=n[8],h=n[9],f=n[10],m=n[11],d=n[12],p=n[13],v=n[14],_=n[15],g=t*s-i*o,M=t*c-r*o,b=t*u-a*o,x=i*c-r*s,S=i*u-a*s,w=r*u-a*c,y=l*p-h*d,L=l*v-f*d,P=l*_-m*d,T=h*v-f*p,R=h*_-m*p,F=f*_-m*v,E=g*F-M*R+b*T+x*P-S*L+w*y;return E?(E=1/E,e[0]=(s*F-c*R+u*T)*E,e[1]=(r*R-i*F-a*T)*E,e[2]=(p*w-v*S+_*x)*E,e[3]=(f*S-h*w-m*x)*E,e[4]=(c*P-o*F-u*L)*E,e[5]=(t*F-r*P+a*L)*E,e[6]=(v*b-d*w-_*M)*E,e[7]=(l*w-f*b+m*M)*E,e[8]=(o*R-s*P+u*y)*E,e[9]=(i*P-t*R-a*y)*E,e[10]=(d*S-p*b+_*g)*E,e[11]=(h*b-l*S-m*g)*E,e[12]=(s*L-o*T-c*y)*E,e[13]=(t*T-i*L+r*y)*E,e[14]=(p*M-d*x-v*g)*E,e[15]=(l*x-h*M+f*g)*E,e):null}function rn(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=n[4],s=n[5],c=n[6],u=n[7],l=n[8],h=n[9],f=n[10],m=n[11],d=n[12],p=n[13],v=n[14],_=n[15];return e[0]=s*(f*_-m*v)-h*(c*_-u*v)+p*(c*m-u*f),e[1]=-(i*(f*_-m*v)-h*(r*_-a*v)+p*(r*m-a*f)),e[2]=i*(c*_-u*v)-s*(r*_-a*v)+p*(r*u-a*c),e[3]=-(i*(c*m-u*f)-s*(r*m-a*f)+h*(r*u-a*c)),e[4]=-(o*(f*_-m*v)-l*(c*_-u*v)+d*(c*m-u*f)),e[5]=t*(f*_-m*v)-l*(r*_-a*v)+d*(r*m-a*f),e[6]=-(t*(c*_-u*v)-o*(r*_-a*v)+d*(r*u-a*c)),e[7]=t*(c*m-u*f)-o*(r*m-a*f)+l*(r*u-a*c),e[8]=o*(h*_-m*p)-l*(s*_-u*p)+d*(s*m-u*h),e[9]=-(t*(h*_-m*p)-l*(i*_-a*p)+d*(i*m-a*h)),e[10]=t*(s*_-u*p)-o*(i*_-a*p)+d*(i*u-a*s),e[11]=-(t*(s*m-u*h)-o*(i*m-a*h)+l*(i*u-a*s)),e[12]=-(o*(h*v-f*p)-l*(s*v-c*p)+d*(s*f-c*h)),e[13]=t*(h*v-f*p)-l*(i*v-r*p)+d*(i*f-r*h),e[14]=-(t*(s*v-c*p)-o*(i*v-r*p)+d*(i*c-r*s)),e[15]=t*(s*f-c*h)-o*(i*f-r*h)+l*(i*c-r*s),e}function an(e){var n=e[0],t=e[1],i=e[2],r=e[3],a=e[4],o=e[5],s=e[6],c=e[7],u=e[8],l=e[9],h=e[10],f=e[11],m=e[12],d=e[13],p=e[14],v=e[15];return(n*o-t*a)*(h*v-f*p)-(n*s-i*a)*(l*v-f*d)+(n*c-r*a)*(l*p-h*d)+(t*s-i*o)*(u*v-f*m)-(t*c-r*o)*(u*p-h*m)+(i*c-r*s)*(u*d-l*m)}function on(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=n[8],f=n[9],m=n[10],d=n[11],p=n[12],v=n[13],_=n[14],g=n[15],M=t[0],b=t[1],x=t[2],S=t[3];return e[0]=M*i+b*s+x*h+S*p,e[1]=M*r+b*c+x*f+S*v,e[2]=M*a+b*u+x*m+S*_,e[3]=M*o+b*l+x*d+S*g,M=t[4],b=t[5],x=t[6],S=t[7],e[4]=M*i+b*s+x*h+S*p,e[5]=M*r+b*c+x*f+S*v,e[6]=M*a+b*u+x*m+S*_,e[7]=M*o+b*l+x*d+S*g,M=t[8],b=t[9],x=t[10],S=t[11],e[8]=M*i+b*s+x*h+S*p,e[9]=M*r+b*c+x*f+S*v,e[10]=M*a+b*u+x*m+S*_,e[11]=M*o+b*l+x*d+S*g,M=t[12],b=t[13],x=t[14],S=t[15],e[12]=M*i+b*s+x*h+S*p,e[13]=M*r+b*c+x*f+S*v,e[14]=M*a+b*u+x*m+S*_,e[15]=M*o+b*l+x*d+S*g,e}function sn(e,n,t){var i,r,a,o,s,c,u,l,h,f,m,d,p=t[0],v=t[1],_=t[2];return n===e?(e[12]=n[0]*p+n[4]*v+n[8]*_+n[12],e[13]=n[1]*p+n[5]*v+n[9]*_+n[13],e[14]=n[2]*p+n[6]*v+n[10]*_+n[14],e[15]=n[3]*p+n[7]*v+n[11]*_+n[15]):(i=n[0],r=n[1],a=n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=n[8],f=n[9],m=n[10],d=n[11],e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=s,e[5]=c,e[6]=u,e[7]=l,e[8]=h,e[9]=f,e[10]=m,e[11]=d,e[12]=i*p+s*v+h*_+n[12],e[13]=r*p+c*v+f*_+n[13],e[14]=a*p+u*v+m*_+n[14],e[15]=o*p+l*v+d*_+n[15]),e}function cn(e,n,t){var i=t[0],r=t[1],a=t[2];return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=n[3]*i,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=n[7]*r,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=n[11]*a,e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],e}function un(e,n,t,i){var r,a,o,s,c,u,l,h,f,d,p,v,_,g,M,b,x,S,w,y,L,P,T,R,F=i[0],E=i[1],N=i[2],A=Math.hypot(F,E,N);return A<m?null:(F*=A=1/A,E*=A,N*=A,r=Math.sin(t),o=1-(a=Math.cos(t)),s=n[0],c=n[1],u=n[2],l=n[3],h=n[4],f=n[5],d=n[6],p=n[7],v=n[8],_=n[9],g=n[10],M=n[11],b=F*F*o+a,x=E*F*o+N*r,S=N*F*o-E*r,w=F*E*o-N*r,y=E*E*o+a,L=N*E*o+F*r,P=F*N*o+E*r,T=E*N*o-F*r,R=N*N*o+a,e[0]=s*b+h*x+v*S,e[1]=c*b+f*x+_*S,e[2]=u*b+d*x+g*S,e[3]=l*b+p*x+M*S,e[4]=s*w+h*y+v*L,e[5]=c*w+f*y+_*L,e[6]=u*w+d*y+g*L,e[7]=l*w+p*y+M*L,e[8]=s*P+h*T+v*R,e[9]=c*P+f*T+_*R,e[10]=u*P+d*T+g*R,e[11]=l*P+p*T+M*R,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)}function ln(e,n,t){var i=Math.sin(t),r=Math.cos(t),a=n[4],o=n[5],s=n[6],c=n[7],u=n[8],l=n[9],h=n[10],f=n[11];return n!==e&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e[4]=a*r+u*i,e[5]=o*r+l*i,e[6]=s*r+h*i,e[7]=c*r+f*i,e[8]=u*r-a*i,e[9]=l*r-o*i,e[10]=h*r-s*i,e[11]=f*r-c*i,e}function hn(e,n,t){var i=Math.sin(t),r=Math.cos(t),a=n[0],o=n[1],s=n[2],c=n[3],u=n[8],l=n[9],h=n[10],f=n[11];return n!==e&&(e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e[0]=a*r-u*i,e[1]=o*r-l*i,e[2]=s*r-h*i,e[3]=c*r-f*i,e[8]=a*i+u*r,e[9]=o*i+l*r,e[10]=s*i+h*r,e[11]=c*i+f*r,e}function fn(e,n,t){var i=Math.sin(t),r=Math.cos(t),a=n[0],o=n[1],s=n[2],c=n[3],u=n[4],l=n[5],h=n[6],f=n[7];return n!==e&&(e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e[0]=a*r+u*i,e[1]=o*r+l*i,e[2]=s*r+h*i,e[3]=c*r+f*i,e[4]=u*r-a*i,e[5]=l*r-o*i,e[6]=h*r-s*i,e[7]=f*r-c*i,e}function mn(e,n){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function dn(e,n){return e[0]=n[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=n[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function pn(e,n,t){var i,r,a,o=t[0],s=t[1],c=t[2],u=Math.hypot(o,s,c);return u<m?null:(o*=u=1/u,s*=u,c*=u,i=Math.sin(n),a=1-(r=Math.cos(n)),e[0]=o*o*a+r,e[1]=s*o*a+c*i,e[2]=c*o*a-s*i,e[3]=0,e[4]=o*s*a-c*i,e[5]=s*s*a+r,e[6]=c*s*a+o*i,e[7]=0,e[8]=o*c*a+s*i,e[9]=s*c*a-o*i,e[10]=c*c*a+r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function vn(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=t,e[7]=0,e[8]=0,e[9]=-t,e[10]=i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function _n(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=0,e[2]=-t,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=t,e[9]=0,e[10]=i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function gn(e,n){var t=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=t,e[2]=0,e[3]=0,e[4]=-t,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Mn(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=i+i,c=r+r,u=a+a,l=i*s,h=i*c,f=i*u,m=r*c,d=r*u,p=a*u,v=o*s,_=o*c,g=o*u;return e[0]=1-(m+p),e[1]=h+g,e[2]=f-_,e[3]=0,e[4]=h-g,e[5]=1-(l+p),e[6]=d+v,e[7]=0,e[8]=f+_,e[9]=d-v,e[10]=1-(l+m),e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function bn(e,n){var t=new d(3),i=-n[0],r=-n[1],a=-n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=i*i+r*r+a*a+o*o;return h>0?(t[0]=2*(s*o+l*i+c*a-u*r)/h,t[1]=2*(c*o+l*r+u*i-s*a)/h,t[2]=2*(u*o+l*a+s*r-c*i)/h):(t[0]=2*(s*o+l*i+c*a-u*r),t[1]=2*(c*o+l*r+u*i-s*a),t[2]=2*(u*o+l*a+s*r-c*i)),Mn(e,n,t),e}function xn(e,n){return e[0]=n[12],e[1]=n[13],e[2]=n[14],e}function Sn(e,n){var t=n[0],i=n[1],r=n[2],a=n[4],o=n[5],s=n[6],c=n[8],u=n[9],l=n[10];return e[0]=Math.hypot(t,i,r),e[1]=Math.hypot(a,o,s),e[2]=Math.hypot(c,u,l),e}function wn(e,n){var t=new d(3);Sn(t,n);var i=1/t[0],r=1/t[1],a=1/t[2],o=n[0]*i,s=n[1]*r,c=n[2]*a,u=n[4]*i,l=n[5]*r,h=n[6]*a,f=n[8]*i,m=n[9]*r,p=n[10]*a,v=o+l+p,_=0;return v>0?(_=2*Math.sqrt(v+1),e[3]=.25*_,e[0]=(h-m)/_,e[1]=(f-c)/_,e[2]=(s-u)/_):o>l&&o>p?(_=2*Math.sqrt(1+o-l-p),e[3]=(h-m)/_,e[0]=.25*_,e[1]=(s+u)/_,e[2]=(f+c)/_):l>p?(_=2*Math.sqrt(1+l-o-p),e[3]=(f-c)/_,e[0]=(s+u)/_,e[1]=.25*_,e[2]=(h+m)/_):(_=2*Math.sqrt(1+p-o-l),e[3]=(s-u)/_,e[0]=(f+c)/_,e[1]=(h+m)/_,e[2]=.25*_),e}function yn(e,n,t,i){var r=n[0],a=n[1],o=n[2],s=n[3],c=r+r,u=a+a,l=o+o,h=r*c,f=r*u,m=r*l,d=a*u,p=a*l,v=o*l,_=s*c,g=s*u,M=s*l,b=i[0],x=i[1],S=i[2];return e[0]=(1-(d+v))*b,e[1]=(f+M)*b,e[2]=(m-g)*b,e[3]=0,e[4]=(f-M)*x,e[5]=(1-(h+v))*x,e[6]=(p+_)*x,e[7]=0,e[8]=(m+g)*S,e[9]=(p-_)*S,e[10]=(1-(h+d))*S,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function Ln(e,n,t,i,r){var a=n[0],o=n[1],s=n[2],c=n[3],u=a+a,l=o+o,h=s+s,f=a*u,m=a*l,d=a*h,p=o*l,v=o*h,_=s*h,g=c*u,M=c*l,b=c*h,x=i[0],S=i[1],w=i[2],y=r[0],L=r[1],P=r[2],T=(1-(p+_))*x,R=(m+b)*x,F=(d-M)*x,E=(m-b)*S,N=(1-(f+_))*S,A=(v+g)*S,D=(d+M)*w,C=(v-g)*w,V=(1-(f+p))*w;return e[0]=T,e[1]=R,e[2]=F,e[3]=0,e[4]=E,e[5]=N,e[6]=A,e[7]=0,e[8]=D,e[9]=C,e[10]=V,e[11]=0,e[12]=t[0]+y-(T*y+E*L+D*P),e[13]=t[1]+L-(R*y+N*L+C*P),e[14]=t[2]+P-(F*y+A*L+V*P),e[15]=1,e}function Pn(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=t+t,s=i+i,c=r+r,u=t*o,l=i*o,h=i*s,f=r*o,m=r*s,d=r*c,p=a*o,v=a*s,_=a*c;return e[0]=1-h-d,e[1]=l+_,e[2]=f-v,e[3]=0,e[4]=l-_,e[5]=1-u-d,e[6]=m+p,e[7]=0,e[8]=f+v,e[9]=m-p,e[10]=1-u-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Tn(e,n,t,i,r,a,o){var s=1/(t-n),c=1/(r-i),u=1/(a-o);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*c,e[6]=0,e[7]=0,e[8]=(t+n)*s,e[9]=(r+i)*c,e[10]=(o+a)*u,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*a*2*u,e[15]=0,e}function Rn(e,n,t,i,r){var a,o=1/Math.tan(n/2);return e[0]=o/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(a=1/(i-r),e[10]=(r+i)*a,e[14]=2*r*i*a):(e[10]=-1,e[14]=-2*i),e}function Fn(e,n,t,i){var r=Math.tan(n.upDegrees*Math.PI/180),a=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),s=Math.tan(n.rightDegrees*Math.PI/180),c=2/(o+s),u=2/(r+a);return e[0]=c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=u,e[6]=0,e[7]=0,e[8]=-(o-s)*c*.5,e[9]=(r-a)*u*.5,e[10]=i/(t-i),e[11]=-1,e[12]=0,e[13]=0,e[14]=i*t/(t-i),e[15]=0,e}function En(e,n,t,i,r,a,o){var s=1/(n-t),c=1/(i-r),u=1/(a-o);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*c,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(n+t)*s,e[13]=(r+i)*c,e[14]=(o+a)*u,e[15]=1,e}function Nn(e,n,t,i){var r,a,o,s,c,u,l,h,f,d,p=n[0],v=n[1],_=n[2],g=i[0],M=i[1],b=i[2],x=t[0],S=t[1],w=t[2];return Math.abs(p-x)<m&&Math.abs(v-S)<m&&Math.abs(_-w)<m?en(e):(l=p-x,h=v-S,f=_-w,r=M*(f*=d=1/Math.hypot(l,h,f))-b*(h*=d),a=b*(l*=d)-g*f,o=g*h-M*l,(d=Math.hypot(r,a,o))?(r*=d=1/d,a*=d,o*=d):(r=0,a=0,o=0),s=h*o-f*a,c=f*r-l*o,u=l*a-h*r,(d=Math.hypot(s,c,u))?(s*=d=1/d,c*=d,u*=d):(s=0,c=0,u=0),e[0]=r,e[1]=s,e[2]=l,e[3]=0,e[4]=a,e[5]=c,e[6]=h,e[7]=0,e[8]=o,e[9]=u,e[10]=f,e[11]=0,e[12]=-(r*p+a*v+o*_),e[13]=-(s*p+c*v+u*_),e[14]=-(l*p+h*v+f*_),e[15]=1,e)}function An(e,n,t,i){var r=n[0],a=n[1],o=n[2],s=i[0],c=i[1],u=i[2],l=r-t[0],h=a-t[1],f=o-t[2],m=l*l+h*h+f*f;m>0&&(l*=m=1/Math.sqrt(m),h*=m,f*=m);var d=c*f-u*h,p=u*l-s*f,v=s*h-c*l;return(m=d*d+p*p+v*v)>0&&(d*=m=1/Math.sqrt(m),p*=m,v*=m),e[0]=d,e[1]=p,e[2]=v,e[3]=0,e[4]=h*v-f*p,e[5]=f*d-l*v,e[6]=l*p-h*d,e[7]=0,e[8]=l,e[9]=h,e[10]=f,e[11]=0,e[12]=r,e[13]=a,e[14]=o,e[15]=1,e}function Dn(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Cn(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Vn(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e[4]=n[4]+t[4],e[5]=n[5]+t[5],e[6]=n[6]+t[6],e[7]=n[7]+t[7],e[8]=n[8]+t[8],e[9]=n[9]+t[9],e[10]=n[10]+t[10],e[11]=n[11]+t[11],e[12]=n[12]+t[12],e[13]=n[13]+t[13],e[14]=n[14]+t[14],e[15]=n[15]+t[15],e}function Bn(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e[4]=n[4]-t[4],e[5]=n[5]-t[5],e[6]=n[6]-t[6],e[7]=n[7]-t[7],e[8]=n[8]-t[8],e[9]=n[9]-t[9],e[10]=n[10]-t[10],e[11]=n[11]-t[11],e[12]=n[12]-t[12],e[13]=n[13]-t[13],e[14]=n[14]-t[14],e[15]=n[15]-t[15],e}function On(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e[4]=n[4]*t,e[5]=n[5]*t,e[6]=n[6]*t,e[7]=n[7]*t,e[8]=n[8]*t,e[9]=n[9]*t,e[10]=n[10]*t,e[11]=n[11]*t,e[12]=n[12]*t,e[13]=n[13]*t,e[14]=n[14]*t,e[15]=n[15]*t,e}function zn(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e[3]=n[3]+t[3]*i,e[4]=n[4]+t[4]*i,e[5]=n[5]+t[5]*i,e[6]=n[6]+t[6]*i,e[7]=n[7]+t[7]*i,e[8]=n[8]+t[8]*i,e[9]=n[9]+t[9]*i,e[10]=n[10]+t[10]*i,e[11]=n[11]+t[11]*i,e[12]=n[12]+t[12]*i,e[13]=n[13]+t[13]*i,e[14]=n[14]+t[14]*i,e[15]=n[15]+t[15]*i,e}function In(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]&&e[6]===n[6]&&e[7]===n[7]&&e[8]===n[8]&&e[9]===n[9]&&e[10]===n[10]&&e[11]===n[11]&&e[12]===n[12]&&e[13]===n[13]&&e[14]===n[14]&&e[15]===n[15]}function kn(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=e[4],s=e[5],c=e[6],u=e[7],l=e[8],h=e[9],f=e[10],d=e[11],p=e[12],v=e[13],_=e[14],g=e[15],M=n[0],b=n[1],x=n[2],S=n[3],w=n[4],y=n[5],L=n[6],P=n[7],T=n[8],R=n[9],F=n[10],E=n[11],N=n[12],A=n[13],D=n[14],C=n[15];return Math.abs(t-M)<=m*Math.max(1,Math.abs(t),Math.abs(M))&&Math.abs(i-b)<=m*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(r-x)<=m*Math.max(1,Math.abs(r),Math.abs(x))&&Math.abs(a-S)<=m*Math.max(1,Math.abs(a),Math.abs(S))&&Math.abs(o-w)<=m*Math.max(1,Math.abs(o),Math.abs(w))&&Math.abs(s-y)<=m*Math.max(1,Math.abs(s),Math.abs(y))&&Math.abs(c-L)<=m*Math.max(1,Math.abs(c),Math.abs(L))&&Math.abs(u-P)<=m*Math.max(1,Math.abs(u),Math.abs(P))&&Math.abs(l-T)<=m*Math.max(1,Math.abs(l),Math.abs(T))&&Math.abs(h-R)<=m*Math.max(1,Math.abs(h),Math.abs(R))&&Math.abs(f-F)<=m*Math.max(1,Math.abs(f),Math.abs(F))&&Math.abs(d-E)<=m*Math.max(1,Math.abs(d),Math.abs(E))&&Math.abs(p-N)<=m*Math.max(1,Math.abs(p),Math.abs(N))&&Math.abs(v-A)<=m*Math.max(1,Math.abs(v),Math.abs(A))&&Math.abs(_-D)<=m*Math.max(1,Math.abs(_),Math.abs(D))&&Math.abs(g-C)<=m*Math.max(1,Math.abs(g),Math.abs(C))}var Gn=on,Un=Bn;function qn(){var e=new d(3);return d!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Hn(e){var n=new d(3);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n}function jn(e){var n=e[0],t=e[1],i=e[2];return Math.hypot(n,t,i)}function Xn(e,n,t){var i=new d(3);return i[0]=e,i[1]=n,i[2]=t,i}function Wn(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e}function $n(e,n,t,i){return e[0]=n,e[1]=t,e[2]=i,e}function Kn(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}function Qn(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e}function Yn(e,n,t){return e[0]=n[0]*t[0],e[1]=n[1]*t[1],e[2]=n[2]*t[2],e}function Zn(e,n,t){return e[0]=n[0]/t[0],e[1]=n[1]/t[1],e[2]=n[2]/t[2],e}function Jn(e,n){return e[0]=Math.ceil(n[0]),e[1]=Math.ceil(n[1]),e[2]=Math.ceil(n[2]),e}function et(e,n){return e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1]),e[2]=Math.floor(n[2]),e}function nt(e,n,t){return e[0]=Math.min(n[0],t[0]),e[1]=Math.min(n[1],t[1]),e[2]=Math.min(n[2],t[2]),e}function tt(e,n,t){return e[0]=Math.max(n[0],t[0]),e[1]=Math.max(n[1],t[1]),e[2]=Math.max(n[2],t[2]),e}function it(e,n){return e[0]=Math.round(n[0]),e[1]=Math.round(n[1]),e[2]=Math.round(n[2]),e}function rt(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e}function at(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e}function ot(e,n){var t=n[0]-e[0],i=n[1]-e[1],r=n[2]-e[2];return Math.hypot(t,i,r)}function st(e,n){var t=n[0]-e[0],i=n[1]-e[1],r=n[2]-e[2];return t*t+i*i+r*r}function ct(e){var n=e[0],t=e[1],i=e[2];return n*n+t*t+i*i}function ut(e,n){return e[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e}function lt(e,n){return e[0]=1/n[0],e[1]=1/n[1],e[2]=1/n[2],e}function ht(e,n){var t=n[0],i=n[1],r=n[2],a=t*t+i*i+r*r;return a>0&&(a=1/Math.sqrt(a)),e[0]=n[0]*a,e[1]=n[1]*a,e[2]=n[2]*a,e}function ft(e,n){return e[0]*n[0]+e[1]*n[1]+e[2]*n[2]}function mt(e,n,t){var i=n[0],r=n[1],a=n[2],o=t[0],s=t[1],c=t[2];return e[0]=r*c-a*s,e[1]=a*o-i*c,e[2]=i*s-r*o,e}function dt(e,n,t,i){var r=n[0],a=n[1],o=n[2];return e[0]=r+i*(t[0]-r),e[1]=a+i*(t[1]-a),e[2]=o+i*(t[2]-o),e}function pt(e,n,t,i,r,a){var o=a*a,s=o*(2*a-3)+1,c=o*(a-2)+a,u=o*(a-1),l=o*(3-2*a);return e[0]=n[0]*s+t[0]*c+i[0]*u+r[0]*l,e[1]=n[1]*s+t[1]*c+i[1]*u+r[1]*l,e[2]=n[2]*s+t[2]*c+i[2]*u+r[2]*l,e}function vt(e,n,t,i,r,a){var o=1-a,s=o*o,c=a*a,u=s*o,l=3*a*s,h=3*c*o,f=c*a;return e[0]=n[0]*u+t[0]*l+i[0]*h+r[0]*f,e[1]=n[1]*u+t[1]*l+i[1]*h+r[1]*f,e[2]=n[2]*u+t[2]*l+i[2]*h+r[2]*f,e}function _t(e,n){n=n||1;var t=2*p()*Math.PI,i=2*p()-1,r=Math.sqrt(1-i*i)*n;return e[0]=Math.cos(t)*r,e[1]=Math.sin(t)*r,e[2]=i*n,e}function gt(e,n,t){var i=n[0],r=n[1],a=n[2],o=t[3]*i+t[7]*r+t[11]*a+t[15];return o=o||1,e[0]=(t[0]*i+t[4]*r+t[8]*a+t[12])/o,e[1]=(t[1]*i+t[5]*r+t[9]*a+t[13])/o,e[2]=(t[2]*i+t[6]*r+t[10]*a+t[14])/o,e}function Mt(e,n,t){var i=n[0],r=n[1],a=n[2];return e[0]=i*t[0]+r*t[3]+a*t[6],e[1]=i*t[1]+r*t[4]+a*t[7],e[2]=i*t[2]+r*t[5]+a*t[8],e}function bt(e,n,t){var i=t[0],r=t[1],a=t[2],o=t[3],s=n[0],c=n[1],u=n[2],l=r*u-a*c,h=a*s-i*u,f=i*c-r*s,m=r*f-a*h,d=a*l-i*f,p=i*h-r*l,v=2*o;return l*=v,h*=v,f*=v,m*=2,d*=2,p*=2,e[0]=s+l+m,e[1]=c+h+d,e[2]=u+f+p,e}function xt(e,n,t,i){var r=[],a=[];return r[0]=n[0]-t[0],r[1]=n[1]-t[1],r[2]=n[2]-t[2],a[0]=r[0],a[1]=r[1]*Math.cos(i)-r[2]*Math.sin(i),a[2]=r[1]*Math.sin(i)+r[2]*Math.cos(i),e[0]=a[0]+t[0],e[1]=a[1]+t[1],e[2]=a[2]+t[2],e}function St(e,n,t,i){var r=[],a=[];return r[0]=n[0]-t[0],r[1]=n[1]-t[1],r[2]=n[2]-t[2],a[0]=r[2]*Math.sin(i)+r[0]*Math.cos(i),a[1]=r[1],a[2]=r[2]*Math.cos(i)-r[0]*Math.sin(i),e[0]=a[0]+t[0],e[1]=a[1]+t[1],e[2]=a[2]+t[2],e}function wt(e,n,t,i){var r=[],a=[];return r[0]=n[0]-t[0],r[1]=n[1]-t[1],r[2]=n[2]-t[2],a[0]=r[0]*Math.cos(i)-r[1]*Math.sin(i),a[1]=r[0]*Math.sin(i)+r[1]*Math.cos(i),a[2]=r[2],e[0]=a[0]+t[0],e[1]=a[1]+t[1],e[2]=a[2]+t[2],e}function yt(e,n){var t=e[0],i=e[1],r=e[2],a=n[0],o=n[1],s=n[2],c=Math.sqrt(t*t+i*i+r*r)*Math.sqrt(a*a+o*o+s*s),u=c&&ft(e,n)/c;return Math.acos(Math.min(Math.max(u,-1),1))}function Lt(e){return e[0]=0,e[1]=0,e[2]=0,e}function Pt(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"}function Tt(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]}function Rt(e,n){var t=e[0],i=e[1],r=e[2],a=n[0],o=n[1],s=n[2];return Math.abs(t-a)<=m*Math.max(1,Math.abs(t),Math.abs(a))&&Math.abs(i-o)<=m*Math.max(1,Math.abs(i),Math.abs(o))&&Math.abs(r-s)<=m*Math.max(1,Math.abs(r),Math.abs(s))}var Ft,Et=Qn,Nt=Yn,At=Zn,Dt=ot,Ct=st,Vt=jn,Bt=ct,Ot=(Ft=qn(),function(e,n,t,i,r,a){var o,s;for(n||(n=3),t||(t=0),s=i?Math.min(i*n+t,e.length):e.length,o=t;o<s;o+=n)Ft[0]=e[o],Ft[1]=e[o+1],Ft[2]=e[o+2],r(Ft,Ft,a),e[o]=Ft[0],e[o+1]=Ft[1],e[o+2]=Ft[2];return e});function zt(){var e=new d(4);return d!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function It(e){var n=new d(4);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n}function kt(e,n,t,i){var r=new d(4);return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r}function Gt(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e}function Ut(e,n,t,i,r){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e}function qt(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e}function Ht(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e[2]=n[2]-t[2],e[3]=n[3]-t[3],e}function jt(e,n,t){return e[0]=n[0]*t[0],e[1]=n[1]*t[1],e[2]=n[2]*t[2],e[3]=n[3]*t[3],e}function Xt(e,n,t){return e[0]=n[0]/t[0],e[1]=n[1]/t[1],e[2]=n[2]/t[2],e[3]=n[3]/t[3],e}function Wt(e,n){return e[0]=Math.ceil(n[0]),e[1]=Math.ceil(n[1]),e[2]=Math.ceil(n[2]),e[3]=Math.ceil(n[3]),e}function $t(e,n){return e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1]),e[2]=Math.floor(n[2]),e[3]=Math.floor(n[3]),e}function Kt(e,n,t){return e[0]=Math.min(n[0],t[0]),e[1]=Math.min(n[1],t[1]),e[2]=Math.min(n[2],t[2]),e[3]=Math.min(n[3],t[3]),e}function Qt(e,n,t){return e[0]=Math.max(n[0],t[0]),e[1]=Math.max(n[1],t[1]),e[2]=Math.max(n[2],t[2]),e[3]=Math.max(n[3],t[3]),e}function Yt(e,n){return e[0]=Math.round(n[0]),e[1]=Math.round(n[1]),e[2]=Math.round(n[2]),e[3]=Math.round(n[3]),e}function Zt(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e}function Jt(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e[3]=n[3]+t[3]*i,e}function ei(e,n){var t=n[0]-e[0],i=n[1]-e[1],r=n[2]-e[2],a=n[3]-e[3];return Math.hypot(t,i,r,a)}function ni(e,n){var t=n[0]-e[0],i=n[1]-e[1],r=n[2]-e[2],a=n[3]-e[3];return t*t+i*i+r*r+a*a}function ti(e){var n=e[0],t=e[1],i=e[2],r=e[3];return Math.hypot(n,t,i,r)}function ii(e){var n=e[0],t=e[1],i=e[2],r=e[3];return n*n+t*t+i*i+r*r}function ri(e,n){return e[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e[3]=-n[3],e}function ai(e,n){return e[0]=1/n[0],e[1]=1/n[1],e[2]=1/n[2],e[3]=1/n[3],e}function oi(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=t*t+i*i+r*r+a*a;return o>0&&(o=1/Math.sqrt(o)),e[0]=t*o,e[1]=i*o,e[2]=r*o,e[3]=a*o,e}function si(e,n){return e[0]*n[0]+e[1]*n[1]+e[2]*n[2]+e[3]*n[3]}function ci(e,n,t,i){var r=t[0]*i[1]-t[1]*i[0],a=t[0]*i[2]-t[2]*i[0],o=t[0]*i[3]-t[3]*i[0],s=t[1]*i[2]-t[2]*i[1],c=t[1]*i[3]-t[3]*i[1],u=t[2]*i[3]-t[3]*i[2],l=n[0],h=n[1],f=n[2],m=n[3];return e[0]=h*u-f*c+m*s,e[1]=-l*u+f*o-m*a,e[2]=l*c-h*o+m*r,e[3]=-l*s+h*a-f*r,e}function ui(e,n,t,i){var r=n[0],a=n[1],o=n[2],s=n[3];return e[0]=r+i*(t[0]-r),e[1]=a+i*(t[1]-a),e[2]=o+i*(t[2]-o),e[3]=s+i*(t[3]-s),e}function li(e,n){var t,i,r,a,o,s;n=n||1;do{o=(t=2*p()-1)*t+(i=2*p()-1)*i}while(o>=1);do{s=(r=2*p()-1)*r+(a=2*p()-1)*a}while(s>=1);var c=Math.sqrt((1-o)/s);return e[0]=n*t,e[1]=n*i,e[2]=n*r*c,e[3]=n*a*c,e}function hi(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3];return e[0]=t[0]*i+t[4]*r+t[8]*a+t[12]*o,e[1]=t[1]*i+t[5]*r+t[9]*a+t[13]*o,e[2]=t[2]*i+t[6]*r+t[10]*a+t[14]*o,e[3]=t[3]*i+t[7]*r+t[11]*a+t[15]*o,e}function fi(e,n,t){var i=n[0],r=n[1],a=n[2],o=t[0],s=t[1],c=t[2],u=t[3],l=u*i+s*a-c*r,h=u*r+c*i-o*a,f=u*a+o*r-s*i,m=-o*i-s*r-c*a;return e[0]=l*u+m*-o+h*-c-f*-s,e[1]=h*u+m*-s+f*-o-l*-c,e[2]=f*u+m*-c+l*-s-h*-o,e[3]=n[3],e}function mi(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function di(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function pi(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]}function vi(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=n[0],s=n[1],c=n[2],u=n[3];return Math.abs(t-o)<=m*Math.max(1,Math.abs(t),Math.abs(o))&&Math.abs(i-s)<=m*Math.max(1,Math.abs(i),Math.abs(s))&&Math.abs(r-c)<=m*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(a-u)<=m*Math.max(1,Math.abs(a),Math.abs(u))}var _i=Ht,gi=jt,Mi=Xt,bi=ei,xi=ni,Si=ti,wi=ii,yi=function(){var e=zt();return function(n,t,i,r,a,o){var s,c;for(t||(t=4),i||(i=0),c=r?Math.min(r*t+i,n.length):n.length,s=i;s<c;s+=t)e[0]=n[s],e[1]=n[s+1],e[2]=n[s+2],e[3]=n[s+3],a(e,e,o),n[s]=e[0],n[s+1]=e[1],n[s+2]=e[2],n[s+3]=e[3];return n}}();function Li(){var e=new d(4);return d!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Pi(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}function Ti(e,n,t){t*=.5;var i=Math.sin(t);return e[0]=i*n[0],e[1]=i*n[1],e[2]=i*n[2],e[3]=Math.cos(t),e}function Ri(e,n){var t=2*Math.acos(n[3]),i=Math.sin(t/2);return i>m?(e[0]=n[0]/i,e[1]=n[1]/i,e[2]=n[2]/i):(e[0]=1,e[1]=0,e[2]=0),t}function Fi(e,n){var t=rr(e,n);return Math.acos(2*t*t-1)}function Ei(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=t[0],c=t[1],u=t[2],l=t[3];return e[0]=i*l+o*s+r*u-a*c,e[1]=r*l+o*c+a*s-i*u,e[2]=a*l+o*u+i*c-r*s,e[3]=o*l-i*s-r*c-a*u,e}function Ni(e,n,t){t*=.5;var i=n[0],r=n[1],a=n[2],o=n[3],s=Math.sin(t),c=Math.cos(t);return e[0]=i*c+o*s,e[1]=r*c+a*s,e[2]=a*c-r*s,e[3]=o*c-i*s,e}function Ai(e,n,t){t*=.5;var i=n[0],r=n[1],a=n[2],o=n[3],s=Math.sin(t),c=Math.cos(t);return e[0]=i*c-a*s,e[1]=r*c+o*s,e[2]=a*c+i*s,e[3]=o*c-r*s,e}function Di(e,n,t){t*=.5;var i=n[0],r=n[1],a=n[2],o=n[3],s=Math.sin(t),c=Math.cos(t);return e[0]=i*c+r*s,e[1]=r*c-i*s,e[2]=a*c+o*s,e[3]=o*c-a*s,e}function Ci(e,n){var t=n[0],i=n[1],r=n[2];return e[0]=t,e[1]=i,e[2]=r,e[3]=Math.sqrt(Math.abs(1-t*t-i*i-r*r)),e}function Vi(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=Math.sqrt(t*t+i*i+r*r),s=Math.exp(a),c=o>0?s*Math.sin(o)/o:0;return e[0]=t*c,e[1]=i*c,e[2]=r*c,e[3]=s*Math.cos(o),e}function Bi(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=Math.sqrt(t*t+i*i+r*r),s=o>0?Math.atan2(o,a)/o:0;return e[0]=t*s,e[1]=i*s,e[2]=r*s,e[3]=.5*Math.log(t*t+i*i+r*r+a*a),e}function Oi(e,n,t){return Bi(e,n),ir(e,e,t),Vi(e,e),e}function zi(e,n,t,i){var r,a,o,s,c,u=n[0],l=n[1],h=n[2],f=n[3],d=t[0],p=t[1],v=t[2],_=t[3];return(a=u*d+l*p+h*v+f*_)<0&&(a=-a,d=-d,p=-p,v=-v,_=-_),1-a>m?(r=Math.acos(a),o=Math.sin(r),s=Math.sin((1-i)*r)/o,c=Math.sin(i*r)/o):(s=1-i,c=i),e[0]=s*u+c*d,e[1]=s*l+c*p,e[2]=s*h+c*v,e[3]=s*f+c*_,e}function Ii(e){var n=p(),t=p(),i=p(),r=Math.sqrt(1-n),a=Math.sqrt(n);return e[0]=r*Math.sin(2*Math.PI*t),e[1]=r*Math.cos(2*Math.PI*t),e[2]=a*Math.sin(2*Math.PI*i),e[3]=a*Math.cos(2*Math.PI*i),e}function ki(e,n){var t=n[0],i=n[1],r=n[2],a=n[3],o=t*t+i*i+r*r+a*a,s=o?1/o:0;return e[0]=-t*s,e[1]=-i*s,e[2]=-r*s,e[3]=a*s,e}function Gi(e,n){return e[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e[3]=n[3],e}function Ui(e,n){var t,i=n[0]+n[4]+n[8];if(i>0)t=Math.sqrt(i+1),e[3]=.5*t,t=.5/t,e[0]=(n[5]-n[7])*t,e[1]=(n[6]-n[2])*t,e[2]=(n[1]-n[3])*t;else{var r=0;n[4]>n[0]&&(r=1),n[8]>n[3*r+r]&&(r=2);var a=(r+1)%3,o=(r+2)%3;t=Math.sqrt(n[3*r+r]-n[3*a+a]-n[3*o+o]+1),e[r]=.5*t,t=.5/t,e[3]=(n[3*a+o]-n[3*o+a])*t,e[a]=(n[3*a+r]+n[3*r+a])*t,e[o]=(n[3*o+r]+n[3*r+o])*t}return e}function qi(e,n,t,i){var r=.5*Math.PI/180;n*=r,t*=r,i*=r;var a=Math.sin(n),o=Math.cos(n),s=Math.sin(t),c=Math.cos(t),u=Math.sin(i),l=Math.cos(i);return e[0]=a*c*l-o*s*u,e[1]=o*s*l+a*c*u,e[2]=o*c*u-a*s*l,e[3]=o*c*l+a*s*u,e}function Hi(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}var ji,Xi,Wi,$i,Ki,Qi,Yi=It,Zi=kt,Ji=Gt,er=Ut,nr=qt,tr=Ei,ir=Zt,rr=si,ar=ui,or=ti,sr=or,cr=ii,ur=cr,lr=oi,hr=pi,fr=vi,mr=(ji=qn(),Xi=Xn(1,0,0),Wi=Xn(0,1,0),function(e,n,t){var i=ft(n,t);return i<-.999999?(mt(ji,Xi,n),Vt(ji)<1e-6&&mt(ji,Wi,n),ht(ji,ji),Ti(e,ji,Math.PI),e):i>.999999?(e[0]=0,e[1]=0,e[2]=0,e[3]=1,e):(mt(ji,n,t),e[0]=ji[0],e[1]=ji[1],e[2]=ji[2],e[3]=1+i,lr(e,e))}),dr=($i=Li(),Ki=Li(),function(e,n,t,i,r,a){return zi($i,n,r,a),zi(Ki,t,i,a),zi(e,$i,Ki,2*a*(1-a)),e}),pr=(Qi=_e(),function(e,n,t,i){return Qi[0]=t[0],Qi[3]=t[1],Qi[6]=t[2],Qi[1]=i[0],Qi[4]=i[1],Qi[7]=i[2],Qi[2]=-n[0],Qi[5]=-n[1],Qi[8]=-n[2],lr(e,Ui(e,Qi))});function vr(){var e=new d(8);return d!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0),e[3]=1,e}function _r(e){var n=new d(8);return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n}function gr(e,n,t,i,r,a,o,s){var c=new d(8);return c[0]=e,c[1]=n,c[2]=t,c[3]=i,c[4]=r,c[5]=a,c[6]=o,c[7]=s,c}function Mr(e,n,t,i,r,a,o){var s=new d(8);s[0]=e,s[1]=n,s[2]=t,s[3]=i;var c=.5*r,u=.5*a,l=.5*o;return s[4]=c*i+u*t-l*n,s[5]=u*i+l*e-c*t,s[6]=l*i+c*n-u*e,s[7]=-c*e-u*n-l*t,s}function br(e,n,t){var i=.5*t[0],r=.5*t[1],a=.5*t[2],o=n[0],s=n[1],c=n[2],u=n[3];return e[0]=o,e[1]=s,e[2]=c,e[3]=u,e[4]=i*u+r*c-a*s,e[5]=r*u+a*o-i*c,e[6]=a*u+i*s-r*o,e[7]=-i*o-r*s-a*c,e}function xr(e,n){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=.5*n[0],e[5]=.5*n[1],e[6]=.5*n[2],e[7]=0,e}function Sr(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}function wr(e,n){var t=Li();wn(t,n);var i=new d(3);return xn(i,n),br(e,t,i),e}function yr(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e}function Lr(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e}function Pr(e,n,t,i,r,a,o,s,c){return e[0]=n,e[1]=t,e[2]=i,e[3]=r,e[4]=a,e[5]=o,e[6]=s,e[7]=c,e}var Tr=Ji;function Rr(e,n){return e[0]=n[4],e[1]=n[5],e[2]=n[6],e[3]=n[7],e}var Fr=Ji;function Er(e,n){return e[4]=n[0],e[5]=n[1],e[6]=n[2],e[7]=n[3],e}function Nr(e,n){var t=n[4],i=n[5],r=n[6],a=n[7],o=-n[0],s=-n[1],c=-n[2],u=n[3];return e[0]=2*(t*u+a*o+i*c-r*s),e[1]=2*(i*u+a*s+r*o-t*c),e[2]=2*(r*u+a*c+t*s-i*o),e}function Ar(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=.5*t[0],c=.5*t[1],u=.5*t[2],l=n[4],h=n[5],f=n[6],m=n[7];return e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=o*s+r*u-a*c+l,e[5]=o*c+a*s-i*u+h,e[6]=o*u+i*c-r*s+f,e[7]=-i*s-r*c-a*u+m,e}function Dr(e,n,t){var i=-n[0],r=-n[1],a=-n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=s*o+l*i+c*a-u*r,f=c*o+l*r+u*i-s*a,m=u*o+l*a+s*r-c*i,d=l*o-s*i-c*r-u*a;return Ni(e,n,t),i=e[0],r=e[1],a=e[2],o=e[3],e[4]=h*o+d*i+f*a-m*r,e[5]=f*o+d*r+m*i-h*a,e[6]=m*o+d*a+h*r-f*i,e[7]=d*o-h*i-f*r-m*a,e}function Cr(e,n,t){var i=-n[0],r=-n[1],a=-n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=s*o+l*i+c*a-u*r,f=c*o+l*r+u*i-s*a,m=u*o+l*a+s*r-c*i,d=l*o-s*i-c*r-u*a;return Ai(e,n,t),i=e[0],r=e[1],a=e[2],o=e[3],e[4]=h*o+d*i+f*a-m*r,e[5]=f*o+d*r+m*i-h*a,e[6]=m*o+d*a+h*r-f*i,e[7]=d*o-h*i-f*r-m*a,e}function Vr(e,n,t){var i=-n[0],r=-n[1],a=-n[2],o=n[3],s=n[4],c=n[5],u=n[6],l=n[7],h=s*o+l*i+c*a-u*r,f=c*o+l*r+u*i-s*a,m=u*o+l*a+s*r-c*i,d=l*o-s*i-c*r-u*a;return Di(e,n,t),i=e[0],r=e[1],a=e[2],o=e[3],e[4]=h*o+d*i+f*a-m*r,e[5]=f*o+d*r+m*i-h*a,e[6]=m*o+d*a+h*r-f*i,e[7]=d*o-h*i-f*r-m*a,e}function Br(e,n,t){var i=t[0],r=t[1],a=t[2],o=t[3],s=n[0],c=n[1],u=n[2],l=n[3];return e[0]=s*o+l*i+c*a-u*r,e[1]=c*o+l*r+u*i-s*a,e[2]=u*o+l*a+s*r-c*i,e[3]=l*o-s*i-c*r-u*a,s=n[4],c=n[5],u=n[6],l=n[7],e[4]=s*o+l*i+c*a-u*r,e[5]=c*o+l*r+u*i-s*a,e[6]=u*o+l*a+s*r-c*i,e[7]=l*o-s*i-c*r-u*a,e}function Or(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=t[0],c=t[1],u=t[2],l=t[3];return e[0]=i*l+o*s+r*u-a*c,e[1]=r*l+o*c+a*s-i*u,e[2]=a*l+o*u+i*c-r*s,e[3]=o*l-i*s-r*c-a*u,s=t[4],c=t[5],u=t[6],l=t[7],e[4]=i*l+o*s+r*u-a*c,e[5]=r*l+o*c+a*s-i*u,e[6]=a*l+o*u+i*c-r*s,e[7]=o*l-i*s-r*c-a*u,e}function zr(e,n,t,i){if(Math.abs(i)<m)return yr(e,n);var r=Math.hypot(t[0],t[1],t[2]);i*=.5;var a=Math.sin(i),o=a*t[0]/r,s=a*t[1]/r,c=a*t[2]/r,u=Math.cos(i),l=n[0],h=n[1],f=n[2],d=n[3];e[0]=l*u+d*o+h*c-f*s,e[1]=h*u+d*s+f*o-l*c,e[2]=f*u+d*c+l*s-h*o,e[3]=d*u-l*o-h*s-f*c;var p=n[4],v=n[5],_=n[6],g=n[7];return e[4]=p*u+g*o+v*c-_*s,e[5]=v*u+g*s+_*o-p*c,e[6]=_*u+g*c+p*s-v*o,e[7]=g*u-p*o-v*s-_*c,e}function Ir(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e[4]=n[4]+t[4],e[5]=n[5]+t[5],e[6]=n[6]+t[6],e[7]=n[7]+t[7],e}function kr(e,n,t){var i=n[0],r=n[1],a=n[2],o=n[3],s=t[4],c=t[5],u=t[6],l=t[7],h=n[4],f=n[5],m=n[6],d=n[7],p=t[0],v=t[1],_=t[2],g=t[3];return e[0]=i*g+o*p+r*_-a*v,e[1]=r*g+o*v+a*p-i*_,e[2]=a*g+o*_+i*v-r*p,e[3]=o*g-i*p-r*v-a*_,e[4]=i*l+o*s+r*u-a*c+h*g+d*p+f*_-m*v,e[5]=r*l+o*c+a*s-i*u+f*g+d*v+m*p-h*_,e[6]=a*l+o*u+i*c-r*s+m*g+d*_+h*v-f*p,e[7]=o*l-i*s-r*c-a*u+d*g-h*p-f*v-m*_,e}var Gr=kr;function Ur(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e[4]=n[4]*t,e[5]=n[5]*t,e[6]=n[6]*t,e[7]=n[7]*t,e}var qr=rr;function Hr(e,n,t,i){var r=1-i;return qr(n,t)<0&&(i=-i),e[0]=n[0]*r+t[0]*i,e[1]=n[1]*r+t[1]*i,e[2]=n[2]*r+t[2]*i,e[3]=n[3]*r+t[3]*i,e[4]=n[4]*r+t[4]*i,e[5]=n[5]*r+t[5]*i,e[6]=n[6]*r+t[6]*i,e[7]=n[7]*r+t[7]*i,e}function jr(e,n){var t=Kr(n);return e[0]=-n[0]/t,e[1]=-n[1]/t,e[2]=-n[2]/t,e[3]=n[3]/t,e[4]=-n[4]/t,e[5]=-n[5]/t,e[6]=-n[6]/t,e[7]=n[7]/t,e}function Xr(e,n){return e[0]=-n[0],e[1]=-n[1],e[2]=-n[2],e[3]=n[3],e[4]=-n[4],e[5]=-n[5],e[6]=-n[6],e[7]=n[7],e}var Wr=or,$r=Wr,Kr=cr,Qr=Kr;function Yr(e,n){var t=Kr(n);if(t>0){t=Math.sqrt(t);var i=n[0]/t,r=n[1]/t,a=n[2]/t,o=n[3]/t,s=n[4],c=n[5],u=n[6],l=n[7],h=i*s+r*c+a*u+o*l;e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=(s-i*h)/t,e[5]=(c-r*h)/t,e[6]=(u-a*h)/t,e[7]=(l-o*h)/t}return e}function Zr(e){return"quat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+")"}function Jr(e,n){return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]&&e[6]===n[6]&&e[7]===n[7]}function ea(e,n){var t=e[0],i=e[1],r=e[2],a=e[3],o=e[4],s=e[5],c=e[6],u=e[7],l=n[0],h=n[1],f=n[2],d=n[3],p=n[4],v=n[5],_=n[6],g=n[7];return Math.abs(t-l)<=m*Math.max(1,Math.abs(t),Math.abs(l))&&Math.abs(i-h)<=m*Math.max(1,Math.abs(i),Math.abs(h))&&Math.abs(r-f)<=m*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(a-d)<=m*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(o-p)<=m*Math.max(1,Math.abs(o),Math.abs(p))&&Math.abs(s-v)<=m*Math.max(1,Math.abs(s),Math.abs(v))&&Math.abs(c-_)<=m*Math.max(1,Math.abs(c),Math.abs(_))&&Math.abs(u-g)<=m*Math.max(1,Math.abs(u),Math.abs(g))}function na(){var e=new d(2);return d!=Float32Array&&(e[0]=0,e[1]=0),e}function ta(e){var n=new d(2);return n[0]=e[0],n[1]=e[1],n}function ia(e,n){var t=new d(2);return t[0]=e,t[1]=n,t}function ra(e,n){return e[0]=n[0],e[1]=n[1],e}function aa(e,n,t){return e[0]=n,e[1]=t,e}function oa(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e}function sa(e,n,t){return e[0]=n[0]-t[0],e[1]=n[1]-t[1],e}function ca(e,n,t){return e[0]=n[0]*t[0],e[1]=n[1]*t[1],e}function ua(e,n,t){return e[0]=n[0]/t[0],e[1]=n[1]/t[1],e}function la(e,n){return e[0]=Math.ceil(n[0]),e[1]=Math.ceil(n[1]),e}function ha(e,n){return e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1]),e}function fa(e,n,t){return e[0]=Math.min(n[0],t[0]),e[1]=Math.min(n[1],t[1]),e}function ma(e,n,t){return e[0]=Math.max(n[0],t[0]),e[1]=Math.max(n[1],t[1]),e}function da(e,n){return e[0]=Math.round(n[0]),e[1]=Math.round(n[1]),e}function pa(e,n,t){return e[0]=n[0]*t,e[1]=n[1]*t,e}function va(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e}function _a(e,n){var t=n[0]-e[0],i=n[1]-e[1];return Math.hypot(t,i)}function ga(e,n){var t=n[0]-e[0],i=n[1]-e[1];return t*t+i*i}function Ma(e){var n=e[0],t=e[1];return Math.hypot(n,t)}function ba(e){var n=e[0],t=e[1];return n*n+t*t}function xa(e,n){return e[0]=-n[0],e[1]=-n[1],e}function Sa(e,n){return e[0]=1/n[0],e[1]=1/n[1],e}function wa(e,n){var t=n[0],i=n[1],r=t*t+i*i;return r>0&&(r=1/Math.sqrt(r)),e[0]=n[0]*r,e[1]=n[1]*r,e}function ya(e,n){return e[0]*n[0]+e[1]*n[1]}function La(e,n,t){var i=n[0]*t[1]-n[1]*t[0];return e[0]=e[1]=0,e[2]=i,e}function Pa(e,n,t,i){var r=n[0],a=n[1];return e[0]=r+i*(t[0]-r),e[1]=a+i*(t[1]-a),e}function Ta(e,n){n=n||1;var t=2*p()*Math.PI;return e[0]=Math.cos(t)*n,e[1]=Math.sin(t)*n,e}function Ra(e,n,t){var i=n[0],r=n[1];return e[0]=t[0]*i+t[2]*r,e[1]=t[1]*i+t[3]*r,e}function Fa(e,n,t){var i=n[0],r=n[1];return e[0]=t[0]*i+t[2]*r+t[4],e[1]=t[1]*i+t[3]*r+t[5],e}function Ea(e,n,t){var i=n[0],r=n[1];return e[0]=t[0]*i+t[3]*r+t[6],e[1]=t[1]*i+t[4]*r+t[7],e}function Na(e,n,t){var i=n[0],r=n[1];return e[0]=t[0]*i+t[4]*r+t[12],e[1]=t[1]*i+t[5]*r+t[13],e}function Aa(e,n,t,i){var r=n[0]-t[0],a=n[1]-t[1],o=Math.sin(i),s=Math.cos(i);return e[0]=r*s-a*o+t[0],e[1]=r*o+a*s+t[1],e}function Da(e,n){var t=e[0],i=e[1],r=n[0],a=n[1],o=Math.sqrt(t*t+i*i)*Math.sqrt(r*r+a*a),s=o&&(t*r+i*a)/o;return Math.acos(Math.min(Math.max(s,-1),1))}function Ca(e){return e[0]=0,e[1]=0,e}function Va(e){return"vec2("+e[0]+", "+e[1]+")"}function Ba(e,n){return e[0]===n[0]&&e[1]===n[1]}function Oa(e,n){var t=e[0],i=e[1],r=n[0],a=n[1];return Math.abs(t-r)<=m*Math.max(1,Math.abs(t),Math.abs(r))&&Math.abs(i-a)<=m*Math.max(1,Math.abs(i),Math.abs(a))}var za=Ma,Ia=sa,ka=ca,Ga=ua,Ua=_a,qa=ga,Ha=ba,ja=function(){var e=na();return function(n,t,i,r,a,o){var s,c;for(t||(t=2),i||(i=0),c=r?Math.min(r*t+i,n.length):n.length,s=i;s<c;s+=t)e[0]=n[s],e[1]=n[s+1],a(e,e,o),n[s]=e[0],n[s+1]=e[1];return n}}()},526:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Demo=void 0;const i=t(160);class r extends i.Initializable{showSpinner(){document.getElementsByClassName("spinner").item(0).style.display="inline"}hideSpinner(){document.getElementsByClassName("spinner").item(0).style.display="none"}expose(){window.canvas=this.canvas,window.context=this.canvas.context,window.controller=this.canvas.controller,window.renderer=this.renderer}initialize(e){const n=this.onInitialize(e);return this.renderer.loadingStatus$.subscribe((e=>{e===i.LoadingStatus.Finished?this.hideSpinner():e===i.LoadingStatus.Started&&this.showSpinner()})),this.expose(),n}uninitialize(){this.onUninitialize()}enableFullscreenOnCtrlClick(){const e=this.canvas.element;e.addEventListener("click",(n=>{n.ctrlKey&&i.viewer.Fullscreen.toggle(e)}))}}n.Demo=r},971:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DiskLight=n.SphereLight=void 0,n.SphereLight=class{constructor(e,n,t){this.center=e,this.radius=n,this.luminance=t}},n.DiskLight=class{constructor(e,n,t,i,r){this.center=e,this.radius=n,this.luminance=t,this.direction=i,this.fovy=r}}},982:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DepthOfFieldKernel=void 0;const i=t(160),r=t(160);class a extends r.KernelF32{constructor(e){super(2,e),this.generate()}generate(){i.auxiliaries.assert(this.width>0,"expected every kernel to comprise at least one element"),this.set([0,0],0);for(let e=1;e<this.width;++e)this.set([i.auxiliaries.rand(-1,1),i.auxiliaries.rand(-1,1)],e);this.sort(r.AbstractKernel.SortApproach.BySquaredLength)}get width(){return this._width}set width(e){this._width!==e&&(this._width=e,this.resize(),this.generate())}}n.DepthOfFieldKernel=a},66:function(e,n,t){"use strict";var i=this&&this.__decorate||function(e,n,t,i){var r,a=arguments.length,o=a<3?n:null===i?i=Object.getOwnPropertyDescriptor(n,t):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,n,t,i);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(a<3?r(o):a>3?r(n,t,o):r(n,t))||o);return a>3&&o&&Object.defineProperty(n,t,o),o};Object.defineProperty(n,"__esModule",{value:!0}),n.PostProcessingPass=void 0;const r=t(160);class a extends r.Initializable{constructor(e){super(),this._context=e}initialize(e){const n=this._context.gl;this._frameBuffer=new r.Framebuffer(this._context,"PostProcessingFBO"),this._targetTexture=new r.Texture2D(this._context,"PostProcessingTexture"),this._ndcTriangle=e;const i=new r.Shader(this._context,n.VERTEX_SHADER,"ndcvertices.vert (postprocessing)");i.initialize(t(608));const a=new r.Shader(this._context,n.FRAGMENT_SHADER,"postprocessing.frag");return a.initialize(t(231)),this._program=new r.Program(this._context,"AccumulateProgram"),this._program.initialize([i,a],!1),this._program.attribute("a_vertex",this._ndcTriangle.vertexLocation),this._program.link(),this._program.bind(),n.uniform1i(this._program.uniform("u_texture"),0),n.uniform1i(this._program.uniform("u_normalDepthTexture"),1),this._program.unbind(),this.exposure=1,!0}uninitialize(){this._program.uninitialize(),this._frameBuffer.uninitialize()}update(){const e=this._context.gl,n=this._context.gl2facade;if(!this._texture||!this._texture.valid)return void r.auxiliaries.log(r.auxiliaries.LogLevel.Warning,`valid texture for postprocessing update expected, given ${this._texture}`);const t=this._texture.size;if(!this._targetTexture.initialized){const n=r.Wizard.queryInternalTextureFormat(this._context,e.RGBA,r.Wizard.Precision.byte);this._targetTexture.initialize(t[0],t[1],n[0],e.RGBA,n[1])}(this._targetTexture.width!==this._texture.width||this._targetTexture.height!==this._texture.height)&&this._targetTexture.resize(this._texture.width,this._texture.height),this._frameBuffer.initialized||this._frameBuffer.initialize([[n.COLOR_ATTACHMENT0,this._targetTexture]]),r.auxiliaries.assert(this._frameBuffer.valid,"valid framebuffers expected for postprocessing")}frame(){r.auxiliaries.assert(this._frameBuffer.valid,"valid framebuffer objects for postprocessing expected."),r.auxiliaries.logIf(!this._texture||!this._texture.valid,r.auxiliaries.LogLevel.Warning,`valid texture for postprocessing frame expected, given ${this._texture}`),r.auxiliaries.logIf(!this._normalDepthTexture||!this._normalDepthTexture.valid,r.auxiliaries.LogLevel.Warning,`valid normal/depth texture for postprocessing frame expected, given ${this._texture}`);const e=this._context.gl;e.viewport(0,0,this._targetTexture.width,this._targetTexture.height),this._program.bind(),this._texture.bind(e.TEXTURE0),this._normalDepthTexture.bind(e.TEXTURE1),this._frameBuffer.bind(e.DRAW_FRAMEBUFFER),this._ndcTriangle.bind(),this._ndcTriangle.draw(),this._ndcTriangle.unbind(),this._frameBuffer.unbind(e.DRAW_FRAMEBUFFER)}clear(){const e=this._context.gl;this._frameBuffer.initialized&&this._frameBuffer.clear(e.COLOR_BUFFER_BIT)}set texture(e){this._texture=e}set normalDepthTexture(e){this._normalDepthTexture=e}set exposure(e){const n=this._context.gl;this._program.bind(),n.uniform1f(this._program.uniform("u_exposure"),e),this._program.unbind()}get targetTexture(){return this._targetTexture}get framebuffer(){return this._frameBuffer}}i([r.Initializable.initialize()],a.prototype,"initialize",null),i([r.Initializable.uninitialize()],a.prototype,"uninitialize",null),i([r.Initializable.assert_initialized()],a.prototype,"update",null),i([r.Initializable.assert_initialized()],a.prototype,"frame",null),n.PostProcessingPass=a},605:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.SampleManager=n.LightSample=n.SpecularEnvironmentSample=n.DiffuseEnvironmentSample=n.Sample=void 0;const i=t(160),r=t(659),a=t(314);class o{constructor(e){this.factor=e}}n.Sample=o;class s extends o{}n.DiffuseEnvironmentSample=s;class c extends o{}n.SpecularEnvironmentSample=c;class u extends o{constructor(e,n,t){super(e),this.lightIndex=n,this.eye=t}}n.LightSample=u,n.SampleManager=class{constructor(e,n,t,r){this._currentFrame=0,this._scene=e,this._multiframeNumber=n,this._lightSampleCount=t,this._environmentSampleCount=r,i.auxiliaries.assert(t*this._scene.diskLights.length<=n,"Total number of light samples can not be higher than multiframe count."),this._lightQueue=new Array,this._environmentQueue=new Array,this.generateSampleQueue()}allEmpty(e){let n=!0;for(const t of e)if(t.length>0){n=!1;break}return n}mergeArrays(e){const n=new Array;for(;!this.allEmpty(e);)for(const t of e)t.length>0&&n.push(t.shift());return n}distributeSamples(e,n,t,r){const a=(r-t)/e.length;let o=t;for(const t of e){const e=Math.floor(o);i.auxiliaries.assert(e<n.length,`Index ${e} is out of bounds while distributing light samples.`),n[e].push(t),o+=a}}generateSampleQueue(){const e=Math.round(this._environmentSampleCount/2),n=this._multiframeNumber/e,t=this._environmentSampleCount-e,i=this._multiframeNumber/t,o=this._multiframeNumber/this._lightSampleCount,l=[],h=[];for(let t=0;t<e;++t)l.push(new s(n));for(let e=0;e<t;++e)h.push(new c(i));this._environmentQueue=this.mergeArrays([l,h]);const f=[];let m=0;for(const e of this._scene.diskLights){const n=new a.ShadowKernel(this._lightSampleCount,e),t=[];for(let e=0;e<this._lightSampleCount;++e){const i=n.get(e);t.push(new u(o,m,r.vec3.fromValues(i[0],i[1],i[2])))}f.push(t),m++}this._lightQueue=this.mergeArrays(f),this._perFrameSamples=[];for(let e=0;e<this._multiframeNumber;++e)this._perFrameSamples.push([]);this.distributeSamples(this._lightQueue,this._perFrameSamples,Math.round(.3*this._multiframeNumber),this._multiframeNumber-1),this.distributeSamples(this._environmentQueue,this._perFrameSamples,0,this._multiframeNumber-1)}getNextFrameSamples(){i.auxiliaries.assert(this._currentFrame<this._multiframeNumber,"Samples can only be generated during a multiframe.");const e=this._perFrameSamples[this._currentFrame];return this._currentFrame++,e}}},60:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Scene=void 0,n.Scene=class{constructor(e,n,t,i){this._uri=e,this._camera=n,this._camera.near=t,this._camera.far=i,this._sphereLights=new Array,this._diskLights=new Array}addSphereLight(e){this._sphereLights.push(e)}addDiskLight(e){this._diskLights.push(e)}get uri(){return this._uri}get camera(){return this._camera}get sphereLights(){return this._sphereLights}get diskLights(){return this._diskLights}}},314:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ShadowKernel=void 0;const i=t(160),r=t(659),a=t(160);class o extends a.KernelF32{constructor(e,n){super(3,e),this._diskLight=n,this.generate()}generate(){i.auxiliaries.assert(this.width>0,"expected every kernel to comprise at least one element");const e=this._diskLight.center;this.set([e[0],e[1],e[2]],0);for(let n=1;n<this.width;++n){const t=r.vec3.random(r.vec3.create(),this._diskLight.radius),i=r.vec3.add(r.vec3.create(),e,t);this.set([i[0],i[1],i[2]],n)}this.sort(a.AbstractKernel.SortApproach.BySquaredLength)}get width(){return this._width}set width(e){this._width!==e&&(this._width=e,this.resize(),this.generate())}}n.ShadowKernel=o},683:e=>{e.exports="precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\nvoid ndcOffset(inout vec4 vertex, in vec2 offset) {\n    vertex.xy = offset * vec2(vertex.w) + vertex.xy;\n}\n\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\n\n#if __VERSION__ == 100\n    attribute vec4 a_position;\n    attribute vec4 a_normal;\n    attribute vec4 a_tangent;\n    attribute vec2 a_texcoord_0;\n    attribute vec2 a_texcoord_1;\n    attribute vec2 a_texcoord_2;\n    attribute vec4 a_joints;\n    attribute vec4 a_weights;\n    attribute vec4 a_color;\n#else\n    layout (location = 0) in vec4 a_position;\n    layout (location = 1) in vec3 a_normal;\n    layout (location = 2) in vec4 a_tangent;\n    layout (location = 3) in vec2 a_texcoord_0;\n    layout (location = 4) in vec2 a_texcoord_1;\n    layout (location = 5) in vec2 a_texcoord_2;\n    layout (location = 6) in vec4 a_joints;\n    layout (location = 7) in vec4 a_weights;\n    layout (location = 8) in vec4 a_color;\n#endif\n\nuniform mat4 u_model;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat3 u_normalMatrix;\n\nuniform mediump int u_geometryFlags;\n\nuniform vec2 u_ndcOffset;\nuniform vec2 u_cocPoint;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\nbool checkFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nvec4 depthOfField(mat4 modelView, vec4 worldPos, vec2 cocPoint, float focalDist)\n{\n    vec4 viewVertex = modelView * worldPos;\n    viewVertex.xy += cocPoint * (viewVertex.z + focalDist);\n    return viewVertex;\n}\n\nvoid main(void)\n{\n    vec4 pos = u_model * a_position;\n    v_position = vec3(pos.xyz) / pos.w;\n\n    if (checkFlag(HAS_NORMALS)) {\n        if (checkFlag(HAS_TANGENTS)) {\n            vec3 normalW = normalize(vec3(u_normalMatrix * a_normal));\n            vec3 tangentW = normalize(vec3(u_model * vec4(a_tangent.xyz, 0.0)));\n            vec3 bitangentW = cross(normalW, tangentW) * a_tangent.w;\n            v_TBN = mat3(tangentW, bitangentW, normalW);\n        } else { // HAS_TANGENTS != 1\n            v_normal = normalize(vec3(u_model * vec4(a_normal.xyz, 0.0)));\n        }\n    }\n\n    if (checkFlag(HAS_UV)) {\n        v_uv[0] = a_texcoord_0;\n        v_uv[1] = a_texcoord_1;\n        v_uv[2] = a_texcoord_2;\n    } else {\n        v_uv[0] = vec2(0., 0.);\n        v_uv[1] = vec2(0., 0.);\n        v_uv[2] = vec2(0., 0.);\n    }\n\n    if (checkFlag(HAS_COLORS)) {\n        v_color = a_color;\n    } else {\n        v_color = vec4(1.0);\n    }\n\n    vec4 viewVertex = depthOfField(u_view * u_model, a_position, u_cocPoint, 8.0);\n    gl_Position = u_projection * viewVertex;\n    ndcOffset(gl_Position, u_ndcOffset);\n}\n"},486:e=>{e.exports="\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_cameraNearFar;\nuniform mat4 u_view;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\nconst int USE_IBL               = 1 << 4;\nconst int HAS_BASECOLORMAP      = 1 << 5;\nconst int HAS_NORMALMAP         = 1 << 6;\nconst int HAS_EMISSIVEMAP       = 1 << 7;\nconst int HAS_METALROUGHNESSMAP = 1 << 8;\nconst int HAS_OCCLUSIONMAP      = 1 << 9;\nconst int USE_TEX_LOD           = 1 << 10;\n\nuniform mediump int u_geometryFlags;\n\nvarying vec3 v_position;\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\nvarying vec2 v_uv[3];\n\nbool checkGeometryFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    mat3 TBN;\n    // Retrieve the tangent space matrix\n    if (!checkGeometryFlag(HAS_TANGENTS)) {\n        vec3 pos_dx = dFdx(v_position);\n        vec3 pos_dy = dFdy(v_position);\n        vec3 tex_dx = dFdx(vec3(v_uv[0], 0.0));\n        vec3 tex_dy = dFdy(vec3(v_uv[0], 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n        vec3 ng;\n        if (checkGeometryFlag(HAS_NORMALS))\n            ng = normalize(v_normal);\n        else\n            ng = cross(pos_dx, pos_dy);\n\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            TBN = mat3(t, b, ng);\n        }\n    else { // HAS_TANGENTS\n        TBN = v_TBN;\n    }\n\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(TBN[2].xyz);\n\n    // reverse backface normals\n    n *= (2.0 * float(gl_FrontFacing) - 1.0);\n\n    return n;\n}\n\nvoid main(void)\n{\n    vec4 viewPosition = u_view * vec4(v_position, 1.0);\n    viewPosition /= viewPosition.w;\n\n    float depth = length(viewPosition.xyz);\n    fragColor = vec4(getNormal(), depth);\n}\n"},231:e=>{e.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\n// Uncharted 2 tone mapping\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nuniform sampler2D u_texture;\nuniform sampler2D u_normalDepth;\n\nuniform float u_exposure;\n\nvarying vec2 v_uv;\n\n// Edge-Avoiding TrousWavelet Transform for denoising\n// see https://www.shadertoy.com/view/ldKBzG\nvec3 denoise() {\n    const float denoiseStrength = 1.0;\n\n    vec2 offset[25];\n    offset[0] = vec2(-2,-2);\n    offset[1] = vec2(-1,-2);\n    offset[2] = vec2(0,-2);\n    offset[3] = vec2(1,-2);\n    offset[4] = vec2(2,-2);\n\n    offset[5] = vec2(-2,-1);\n    offset[6] = vec2(-1,-1);\n    offset[7] = vec2(0,-1);\n    offset[8] = vec2(1,-1);\n    offset[9] = vec2(2,-1);\n\n    offset[10] = vec2(-2,0);\n    offset[11] = vec2(-1,0);\n    offset[12] = vec2(0,0);\n    offset[13] = vec2(1,0);\n    offset[14] = vec2(2,0);\n\n    offset[15] = vec2(-2,1);\n    offset[16] = vec2(-1,1);\n    offset[17] = vec2(0,1);\n    offset[18] = vec2(1,1);\n    offset[19] = vec2(2,1);\n\n    offset[20] = vec2(-2,2);\n    offset[21] = vec2(-1,2);\n    offset[22] = vec2(0,2);\n    offset[23] = vec2(1,2);\n    offset[24] = vec2(2,2);\n\n    float kernel[25];\n    kernel[0] = 1.0f/256.0f;\n    kernel[1] = 1.0f/64.0f;\n    kernel[2] = 3.0f/128.0f;\n    kernel[3] = 1.0f/64.0f;\n    kernel[4] = 1.0f/256.0f;\n\n    kernel[5] = 1.0f/64.0f;\n    kernel[6] = 1.0f/16.0f;\n    kernel[7] = 3.0f/32.0f;\n    kernel[8] = 1.0f/16.0f;\n    kernel[9] = 1.0f/64.0f;\n\n    kernel[10] = 3.0f/128.0f;\n    kernel[11] = 3.0f/32.0f;\n    kernel[12] = 9.0f/64.0f;\n    kernel[13] = 3.0f/32.0f;\n    kernel[14] = 3.0f/128.0f;\n\n    kernel[15] = 1.0f/64.0f;\n    kernel[16] = 1.0f/16.0f;\n    kernel[17] = 3.0f/32.0f;\n    kernel[18] = 1.0f/16.0f;\n    kernel[19] = 1.0f/64.0f;\n\n    kernel[20] = 1.0f/256.0f;\n    kernel[21] = 1.0f/64.0f;\n    kernel[22] = 3.0f/128.0f;\n    kernel[23] = 1.0f/64.0f;\n    kernel[24] = 1.0f/256.0f;\n\n    vec3 sum = vec3(0.0);\n    float c_phi = 1.0;\n    float n_phi = 0.5;\n\tvec3 cval = texture(u_texture, v_uv).rgb;\n\tvec3 nval = texture(u_normalDepth, v_uv).rgb;\n\n    vec2 texSize = vec2(textureSize(u_texture, 0));\n\n    float cum_w = 0.0;\n    for (int i = 0; i < 25; i++)\n    {\n        vec2 uv = v_uv + (offset[i] / texSize) * denoiseStrength;\n\n        vec3 ctmp = texture(u_texture, uv).rgb;\n        vec3 t = cval - ctmp;\n        float dist2 = dot(t, t);\n        float c_w = min(exp(-(dist2) / c_phi), 1.0);\n\n        vec3 ntmp = texture(u_normalDepth, uv).rgb;\n        t = nval - ntmp;\n        dist2 = max(dot(t,t), 0.0);\n        float n_w = min(exp(-(dist2) / n_phi), 1.0);\n\n        float weight = c_w * n_w;\n        sum += ctmp * weight * kernel[i];\n        cum_w += weight * kernel[i];\n    }\n\n    return sum / cum_w;\n}\n\nvoid main(void)\n{\n    vec3 inputColor = texture(u_texture, v_uv).rgb;\n    // vec3 inputColor = denoise();\n\n    fragColor = vec4(toneMapUncharted(inputColor * u_exposure), 1.0);\n}\n"},383:e=>{e.exports='precision highp float;\n\n// Adapted from https://github.com/KhronosGroup/glTF-WebGL-PBR\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n#line 1\n\n\n#undef M_PI\n#define M_PI 3.14159265359\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 uniformSampleSphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = 1.0 - 2.0 * u1;\n    float sinTheta = sqrt(max (0.0, 1.0 - cosTheta * cosTheta));\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 uniformSampleHemisphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = 1.0 - u1;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Moving Frostbite to PBR"\nvec3 cosineSampleHemisphere(const in float u1, const in float u2)\n{\n    float phi = 2.0 * M_PI * u2;\n    float cosTheta = sqrt(1.0 - u1);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// Adapted from "Real Shading in Unreal Engine 4"\nvec3 importanceSampleGGX(const in vec2 Xi, const in float alphaRoughnessSq)\n{\n    float Phi = 2.0 * M_PI * Xi.x;\n    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alphaRoughnessSq - 1.0) * Xi.y));\n    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);\n\n    return vec3(SinTheta * cos(Phi), SinTheta * sin(Phi), CosTheta);\n}\n\n// Calculate intersection between a ray and a sphere\n// Returns only the closest distance of the two intersections if there are two\n// Adapted from https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\nfloat raySphereIntersect(const in vec3 r0, const in vec3 rd, const in vec3 s0, const in float sr, out bool hit)\n{\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b * b - 4.0 * a * c < 0.0) {\n        hit = false;\n    }\n\n    hit = true;\n    return (-b - sqrt((b * b) - 4.0 * a * c))/(2.0 * a);\n}\n\n// Returns pseudo-random number within [0,1]\nfloat rand(const in vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Fast calculation of the Van Der Corpus sequence using bitshifting magic\n// See https://learnopengl.com/PBR/IBL/Specular-IBL\nfloat radicalInverse_VdC(in uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n// Returns 2D points according to the quasirandom Hammersley distribution\nvec2 hammersley(const in uint i, const in uint N)\n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\n// Returns 2D points according to the quasirandom Weyl distribution\nvec2 weyl(const in int n) { // borrowed from https://www.shadertoy.com/view/3lsXW2\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\n#line 1\n\n// PBR implementation adapted from https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/metallic-roughness.frag\n// commit 6f1fb2d\n\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#undef M_PI\n#define M_PI 3.14159265359\n\nstruct LightingInfo {\n    vec3 incidentPosition;\n    vec3 incidentNormal;\n    vec3 view;\n    vec2 uv;\n\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 reflectance0;\n    vec3 reflectance90;\n    float perceptualRoughness;\n    float alphaRoughness;\n    float alphaRoughnessSq;\n};\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(const in vec3 reflectance0, const in vec3 reflectance90, const in float VdotH)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(const in float alphaRoughnessSq, const in float NdotL, const in float NdotV)\n{\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(const in float alphaRoughnessSq, const in float NdotH)\n{\n    float f = (NdotH * alphaRoughnessSq - NdotH) * NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 diffuseBrdf(const in LightingInfo info)\n{\n    return info.diffuseColor / M_PI;\n}\n\nvec3 specularBrdfGGX(const in vec3 L, const in LightingInfo info, const in float D_normalization)\n{\n    vec3 H = normalize(info.view + L);\n\n    float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n    float NdotL = clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n    float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n\n    if (NdotL < 0.0 && NdotV < 0.0) {\n        return vec3(0.0);\n    }\n\n    // Fix numerical issues in the microfacet distribution when alphaRoughnessSq is very close to 0\n    // This still introduces some error but fixes values approching infinity, which mess up the whole calculation\n    float clampedAlphaRoughness = clamp(info.alphaRoughnessSq, 0.0000001, 1.0);\n\n    vec3 F = specularReflection(info.reflectance0, info.reflectance90, VdotH);\n    float Vis = visibilityOcclusion(info.alphaRoughnessSq, NdotL, NdotV);\n    float D = microfacetDistribution(clampedAlphaRoughness, NdotH) * D_normalization;\n\n    return F * Vis * D;\n}\n\n// Importance sampling with GGX introduces the pdf: D * NdotH / (4.0 * VdotH), therefore D cancels out\n// The division by NdotH / (4.0 * VdotH) still has to be applied where this function is used\nvec3 specularBrdfGGXImportanceSampled(const in vec3 L, const in LightingInfo info)\n{\n    vec3 H = normalize(info.view + L);\n\n    float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n    float NdotL = clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n    float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n\n    if (NdotL < 0.0 && NdotV < 0.0) {\n        return vec3(0.0);\n    }\n\n    vec3 F = specularReflection(info.reflectance0, info.reflectance90, VdotH);\n    float Vis = visibilityOcclusion(info.alphaRoughnessSq, NdotL, NdotV);\n\n    return F * Vis;\n}\n\n\nstruct SphereLight {\n    vec3 center;\n    float radius;\n    vec3 luminance;\n};\n\nstruct DiskLight {\n    vec3 center;\n    vec3 direction;\n    float radius;\n    vec3 luminance;\n};\n\n// This function uses Monte Carlo integration to calculate the lighting of spherical light source.\n// The rays are generated uniformly over the area of the light source.\n// This can be used to generate a ground truth image or as part of a Multiple Importance Sampling (MIS) approach.\nvec3 sphereLightBruteForce(const in SphereLight light, const in LightingInfo info)\n{\n    const int SAMPLE_COUNT = 16;\n\n    vec3 lightAccumulator = vec3(0.0);\n\n    float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n    float pdf = 1.0 / sphereArea;\n\n    for (int i = 0; i < SAMPLE_COUNT; ++i) {\n        vec2 u = weyl(int(info.uv.x * info.uv.y * 4324231.8) + i);\n        // vec2 u = hammersley(uint(i), uint(SAMPLE_COUNT - 1));\n        // vec2 u = vec2(rand(v_uv + vec2(float(i))), rand(v_uv + vec2(float(i * 3))));\n\n        vec3 sphereNormal = uniformSampleSphere(u.x, u.y);\n\n        vec3 spherePosition = sphereNormal * light.radius + light.center;\n        vec3 lightVector = spherePosition - info.incidentPosition;\n        float sqDist = dot(lightVector, lightVector);\n        vec3 L = normalize(lightVector);\n\n        // turn this from an area integral to a solid angle integral\n        float lightPdf = pdf * sqDist / clamp(dot(sphereNormal, -L), 0.0, 1.0);\n        vec3 L_i = light.luminance; // incoming lumincance from light source (unit: cd / m^2)\n        vec3 integralSample = L_i / lightPdf;\n\n        float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n        vec3 diffuse = diffuseBrdf(info);\n        vec3 specular = specularBrdfGGX(L, info, 1.0);\n        lightAccumulator += (diffuse + specular) * integralSample * NdotL;\n    }\n\n    return lightAccumulator / float(SAMPLE_COUNT);\n}\n\n// Fast approximation using (radius^2 / distance^2) * NdotL\n// This formula does not have proper horizon handling but is cheap to evaluate\n// See "Moving Frostbite to PBR" p.44\nvec3 diffuseSphereLightApproximated(const in SphereLight light, const in LightingInfo info)\n{\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n    float sqrDist = dot(Lunormalized, Lunormalized);\n\n    float sqrLightRadius = light.radius * light.radius;\n    float illuminance = M_PI * (sqrLightRadius / (max(sqrLightRadius, sqrDist))) * clamp(dot(info.incidentNormal, L), 0.0, 1.0);\n\n    float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n    return diffuseBrdf(info) * light.luminance * illuminance * NdotL;\n}\n\nvec3 diffuseDiskLightApproximated(const in DiskLight light, const in LightingInfo info)\n{\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n\n    SphereLight sphereLight = SphereLight(light.center, light.radius, light.luminance);\n    float diskFactor = smoothstep(-0.1, 0.1, -dot(L, light.direction));\n    return diffuseSphereLightApproximated(sphereLight, info) * diskFactor;\n}\n\n// This function uses Monte Carlo importance sampling to evaluate a spherical light source.\n// By generating more rays towards the BRDF lobe, shiny materials are rendered with lower variance\n// However, for diffuse materials the variance may increase\n// This can be used alongside sampling a towards light source by using Multiple Importance Sampling (MIS)\n// vec3 specularSphereLightImportanceSampleGGX(SphereLight light, LightingInfo info)\n// {\n//     const int SAMPLE_COUNT = 16;\n\n//     vec3 lightAccumulator = vec3(0.0);\n\n//     float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n\n//     for (int i = 0; i < SAMPLE_COUNT; ++i) {\n//         vec2 u = weyl(int(info.uv.x * info.uv.y * 4324231.8) + i);\n//         // vec2 u = hammersley(uint(i), uint(SAMPLE_COUNT));\n//         // vec2 u = vec2(rand(v_uv + vec2(float(i))), rand(v_uv + vec2(float(i * 3))));\n\n//         vec3 H = importanceSampleGGX(u, info.alphaRoughnessSq, info.incidentNormal);\n\n//         vec3 sampleDir = reflect(info.view, H);\n\n//         bool hit;\n//         float t = raySphereIntersect(info.incidentPosition, sampleDir, light.center, light.radius, hit);\n\n//         if (!hit || t >= 0.0) continue;\n\n//         float NdotH = clamp(dot(info.incidentNormal, H), 0.0, 1.0);\n//         float VdotH = clamp(dot(info.view, H), 0.0, 1.0);\n\n//         // Math behind calculating the pdf: https://schuttejoe.github.io/post/ggximportancesamplingpart1/\n//         // Note that the D term is not included since it cancels out with the BRDF\n//         float pdf = NdotH / (4.0 * VdotH);\n\n//         vec3 spherePosition = info.incidentPosition + t * sampleDir;\n//         vec3 sphereNormal = normalize(spherePosition - light.center);\n\n//         vec3 lightVector = spherePosition - info.incidentPosition;\n//         float sqDist = dot(lightVector, lightVector);\n//         vec3 L = normalize(lightVector);\n\n//         vec3 L_i = light.luminance; // incoming radiance from light source (unit: W / sr*m^2)\n//         vec3 integralSample = L_i / pdf;\n\n//         float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n//         lightAccumulator += specularBrdfGGXImportanceSampled(L, info) * integralSample * NdotL;\n//     }\n\n//     return lightAccumulator / float(SAMPLE_COUNT);\n// }\n\n// This function approximates a spherical area light by using a "Most Representative Point", which is treated as a point light.\n// This approach does not have proper energy conservation, however Karis gives an approximate normalization factor for the NDF.\n// See "Real Shading in Unreal Engine 4"\nvec3 specularSphereLightKaris(const in SphereLight light, const in LightingInfo info)\n{\n    float sphereArea = 4.0 * M_PI * light.radius * light.radius;\n\n    vec3 R = reflect(info.view, info.incidentNormal);\n    vec3 L_center = light.center - info.incidentPosition;\n    vec3 centerToRay = dot(L_center, R) * R - L_center;\n    vec3 closestPoint = L_center + centerToRay * clamp(light.radius / length(centerToRay), 0.0, 1.0);\n    vec3 L = normalize(closestPoint);\n    float sqDist = max(dot(closestPoint, closestPoint), 0.1);\n\n    // To approximate the area light source as a point light source, we need to convert from luminance (cd/m^2) to luminous power (lm)\n    // We multiply by PI to get lm / m^2 (since we assume a lambertian light source and the integral of cos over hemisphere sums to PI)\n    // Then we multiply by area to get lm\n    vec3 lightPower = M_PI * sphereArea * light.luminance;\n    // Estimate the irradiance from total light power\n    // Note: this formula is an approximation that assumes the light source is a point light at the newly calculated light position\n    vec3 irradiance = lightPower / (4.0 * M_PI * sqDist);\n\n    // This normalization factor given by Karis should be used to scale the NDF\n    float normalization = info.alphaRoughness / (info.alphaRoughness + light.radius / (2.0 * sqrt(sqDist)));\n    normalization = normalization * normalization;\n\n    float NdotL = clamp(dot(L, info.incidentNormal), 0.0, 1.0);\n\n    return specularBrdfGGX(L, info, normalization) * irradiance * NdotL;\n}\n\nvec3 specularDiskLightKaris(const in DiskLight light, const in LightingInfo info) {\n    vec3 Lunormalized = light.center - info.incidentPosition;\n    vec3 L = normalize(Lunormalized);\n\n    SphereLight sphereLight = SphereLight(light.center, light.radius, light.luminance);\n    float diskFactor = smoothstep(-0.1, 0.1, -dot(L, light.direction));\n    return specularSphereLightKaris(sphereLight, info) * diskFactor;\n}\n\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\n// Uncharted 2 tone mapping\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev\'s upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\n#line 17\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\nconst int HAS_NORMALS           = 1;\nconst int HAS_TANGENTS          = 1 << 1;\nconst int HAS_UV                = 1 << 2;\nconst int HAS_COLORS            = 1 << 3;\nconst int USE_IBL               = 1 << 4;\nconst int HAS_BASECOLORMAP      = 1 << 5;\nconst int HAS_NORMALMAP         = 1 << 6;\nconst int HAS_EMISSIVEMAP       = 1 << 7;\nconst int HAS_METALROUGHNESSMAP = 1 << 8;\nconst int HAS_OCCLUSIONMAP      = 1 << 9;\nconst int USE_TEX_LOD           = 1 << 10;\n\nconst float c_MinRoughness = 0.04;\n\nuniform sampler2D u_baseColor;\nuniform sampler2D u_metallicRoughness;\nuniform sampler2D u_normal;\nuniform sampler2D u_emissive;\nuniform sampler2D u_occlusion;\n\nuniform samplerCube u_diffuseEnvironment;\nuniform samplerCube u_specularEnvironment;\nuniform sampler2D u_brdfLUT;\nuniform sampler2D u_shadowMap;\nuniform sampler2D u_lastFrame;\nuniform sampler2D u_normalDepth;\n\n#define MAX_LIGHTS 6\nuniform int u_numDiskLights;\nuniform DiskLight u_diskLights[MAX_LIGHTS];\n\nuniform int u_lightSampleIndex;\nuniform float u_lightFactor;\nuniform int u_numDiffuseEnvironmentSamples;\nuniform float u_diffuseEnvironmentFactor;\nuniform int u_numSpecularEnvironmentSamples;\nuniform float u_specularEnvironmentFactor;\n\nuniform int u_baseColorTexCoord;\nuniform int u_normalTexCoord;\nuniform int u_metallicRoughnessTexCoord;\nuniform int u_occlusionTexCoord;\nuniform int u_emissiveTexCoord;\n\nuniform vec4 u_baseColorFactor;\nuniform float u_metallicFactor;\nuniform float u_roughnessFactor;\nuniform vec3 u_emissiveFactor;\nuniform float u_normalScale;\nuniform int u_blendMode;\nuniform float u_blendCutoff;\n\nuniform mediump int u_geometryFlags;\nuniform mediump int u_pbrFlags;\nuniform vec3 u_eye;\nuniform vec2 u_lightNearFar;\nuniform mat4 u_lightView;\nuniform mat4 u_lightProjection;\n\nuniform mat4 u_viewProjection;\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat3 u_viewNormalMatrix;\nuniform vec2 u_cameraNearFar;\n\nuniform int u_frameNumber;\nuniform int u_debugMode;\nuniform float u_iblStrength;\nuniform float u_occlusionRange;\n\nvarying vec2 v_uv[3];\nvarying vec4 v_color;\nvarying vec3 v_position;\n\nvarying mat3 v_TBN;\nvarying vec3 v_normal;\n\nbool checkGeometryFlag(int flag) {\n    return (u_geometryFlags & flag) == flag;\n}\n\nbool checkFlag(int flag) {\n    return (u_pbrFlags & flag) == flag;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    mat3 TBN;\n    // Retrieve the tangent space matrix\n    if (!checkGeometryFlag(HAS_TANGENTS)) {\n        vec3 pos_dx = dFdx(v_position);\n        vec3 pos_dy = dFdy(v_position);\n        vec3 tex_dx = dFdx(vec3(v_uv[0], 0.0));\n        vec3 tex_dy = dFdy(vec3(v_uv[0], 0.0));\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n        vec3 ng;\n        if (checkGeometryFlag(HAS_NORMALS))\n            ng = normalize(v_normal);\n        else\n            ng = cross(pos_dx, pos_dy);\n\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            TBN = mat3(t, b, ng);\n        }\n    else { // HAS_TANGENTS\n        TBN = v_TBN;\n    }\n\n    vec3 n;\n    if (checkFlag(HAS_NORMALMAP)) {\n        n = texture(u_normal, v_uv[u_normalTexCoord]).rgb;\n        n = normalize(TBN * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n    } else {\n        // The tbn matrix is linearly interpolated, so we need to re-normalize\n        n = normalize(TBN[2].xyz);\n    }\n\n    // reverse backface normals\n    n *= (2.0 * float(gl_FrontFacing) - 1.0);\n\n    return n;\n}\n\nvec3 sampleOcclusion(const in LightingInfo info, const in vec3 viewPosition, const in vec3 viewSampleOffset, out bool hit) {\n    vec3 viewSamplePoint = viewPosition + viewSampleOffset;\n    vec4 ndcSamplePoint = u_projection * vec4(viewSamplePoint, 1.0);\n    vec2 sampleUV = (ndcSamplePoint / ndcSamplePoint.w).xy * 0.5 + 0.5;\n    float sampleDepth = length(viewSamplePoint);\n\n    vec4 normalDepth = texture(u_normalDepth, sampleUV);\n    vec3 hitNormal = normalDepth.rgb;\n    float compareDepth = normalDepth.a;\n\n    // TODO: figure out math to get real sampled point\n    // vec3 sampledPoint = vec3(viewSamplePoint.xy, compareDepth);\n    vec3 sampledPoint = viewSamplePoint;\n    vec3 direction = normalize(sampledPoint - viewPosition);\n\n    // range check fixes halos when depths are very different\n    float rangeCheck = abs(compareDepth - sampleDepth) < u_occlusionRange ? 1.0 : 0.0;\n    float check = step(compareDepth, sampleDepth) * rangeCheck;\n\n    float cosOutgoing = clamp(dot(direction, normalize(u_viewNormalMatrix * -hitNormal)), 0.0, 1.0);\n    float cosIncoming = clamp(dot(direction, normalize(u_viewNormalMatrix * info.incidentNormal)), 0.0, 1.0);\n    float bounceDistance = max(length(sampledPoint - viewPosition), 1.0);\n\n    hit = true;\n    if (check <= 0.0) {\n        hit = false;\n        return vec3(0.0);\n    }\n\n    vec3 hitColor = texture(u_lastFrame, sampleUV).rgb;\n    return hitColor * cosIncoming * cosOutgoing / bounceDistance;\n}\n\nmat3 generateTBN(const in LightingInfo info) {\n    // generate matrix to transform from tangent to view space\n    vec3 viewNormal = normalize(u_viewNormalMatrix * info.incidentNormal);\n    vec3 random = normalize(vec3(0.0, 1.0, 1.0));\n    vec3 t = normalize(random - viewNormal * dot(random, viewNormal));\n    vec3 b = cross(viewNormal, t);\n    return mat3(t, b, viewNormal);\n}\n\nvec3 ssaoSample(const in LightingInfo info, const in mat3 TBN, out bool hit) {\n    vec3 viewPosition = (u_view * vec4(info.incidentPosition, 1.0)).xyz;\n\n    float random1 = rand(info.uv * float(u_frameNumber + 1));\n    float random2 = rand(info.uv * float(u_frameNumber + 2));\n    float random3 = rand(info.uv * float(u_frameNumber + 3));\n\n    vec3 viewSampleOffset = TBN * cosineSampleHemisphere(random1, random2);\n    viewSampleOffset *= u_occlusionRange * random3;\n\n    return sampleOcclusion(info, viewPosition, viewSampleOffset, hit);\n}\n\nvec3 ssrSample(const in LightingInfo info, const in mat3 TBN, out bool hit) {\n    vec3 viewPosition = (u_view * vec4(info.incidentPosition, 1.0)).xyz;\n\n    float random1 = rand(info.uv * float(u_frameNumber + 1));\n    float random2 = rand(info.uv * float(u_frameNumber + 2));\n    float random3 = rand(info.uv * float(u_frameNumber + 3));\n\n    vec3 viewHalfNormal = TBN * importanceSampleGGX(vec2(random1, random2), info.alphaRoughnessSq);\n    vec3 viewSampleOffset = reflect(-u_viewNormalMatrix * info.view, viewHalfNormal);\n    viewSampleOffset *= u_occlusionRange * random3;\n\n    return sampleOcclusion(info, viewPosition, viewSampleOffset, hit);\n}\n\nvec3 sampleDiffuseEnvironment(const in LightingInfo info, const in mat3 TBN, const in bool applyOcclusion)\n{\n    vec4 diffuseSample = texture(u_diffuseEnvironment, info.incidentNormal);\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb * u_iblStrength;\n\n    vec3 diffuseReflection = vec3(0.0);\n    bool diffuseReflectionHit = false;\n\n    if (applyOcclusion) {\n        diffuseReflection = ssaoSample(info, TBN, diffuseReflectionHit);\n    }\n\n    vec3 diffuse = diffuseLight * info.diffuseColor;\n\n    if (diffuseReflectionHit) {\n        diffuse = diffuseReflection * info.diffuseColor;\n    }\n\n    return diffuse;\n}\n\nvec3 sampleSpecularEnvironment(const in LightingInfo info, const in mat3 TBN, const in bool applyOcclusion)\n{\n    float NdotV = clamp(dot(info.incidentNormal, info.view), 0.0, 1.0);\n\n    // TODO: pass uniform for mip count\n    const float MIP_COUNT = 8.0;\n    float lod = clamp(info.perceptualRoughness * MIP_COUNT, 0.0, MIP_COUNT);\n    vec3 reflection = normalize(reflect(-info.view, info.incidentNormal));\n\n    vec2 brdfSamplePoint = vec2(NdotV, info.perceptualRoughness);\n    vec2 brdf = texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 specularSample = textureLod(u_specularEnvironment, reflection, lod);\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb * u_iblStrength;\n\n    vec3 specularReflection = vec3(0.0);\n    bool specularReflectionHit = false;\n    if (applyOcclusion) {\n        specularReflection = ssrSample(info, TBN, specularReflectionHit);\n    }\n\n    vec3 specular = specularLight * (info.specularColor * brdf.x + brdf.y);\n\n    if (specularReflectionHit) {\n        specular = specularReflection * info.specularColor;\n    }\n\n    return specular;\n}\n\nvoid main(void)\n{\n    // The albedo may be defined from a base texture or a flat color\n    vec4 baseColor;\n    if (checkFlag(HAS_BASECOLORMAP)) {\n        baseColor = SRGBtoLINEAR(texture(u_baseColor, v_uv[u_baseColorTexCoord])) * u_baseColorFactor;\n    } else {\n        baseColor = u_baseColorFactor;\n    }\n\n    if (u_debugMode == 1) { // flat\n        fragColor = vec4(baseColor.rgb, 1.0);\n        return;\n    }\n\n    float perceptualRoughness = u_roughnessFactor;\n    float metallic = u_metallicFactor;\n    if (checkFlag(HAS_METALROUGHNESSMAP)) {\n        // Roughness is stored in the \'g\' channel, metallic is stored in the \'b\' channel.\n        // This layout intentionally reserves the \'r\' channel for (optional) occlusion map data\n        vec4 mrSample = texture(u_metallicRoughness, v_uv[u_metallicRoughnessTexCoord]);\n        perceptualRoughness = mrSample.g * perceptualRoughness;\n        metallic = mrSample.b * metallic;\n    }\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    if (u_debugMode == 4) { // Illuminance\n        baseColor = vec4(1.0);\n    }\n\n    // spec: COLOR_0 ... acts as an additional linear multiplier to baseColor\n    // TODO!: distinguish vec3/vec4 colors...\n    baseColor *= vec4(v_color.rgb, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 N = getNormal(); // normal at surface point\n    vec3 V = normalize(u_eye - v_position); // Vector from surface point to camera\n\n    vec4 ndcPosition = u_viewProjection * vec4(v_position, 1.0);\n    vec2 uv = (ndcPosition / ndcPosition.w).xy * 0.5 + 0.5;\n\n    LightingInfo info = LightingInfo(\n        v_position,\n        N,\n        V,\n        uv,\n\n        diffuseColor,\n        specularColor,\n        specularEnvironmentR0,\n        specularEnvironmentR90,\n        perceptualRoughness,\n        alphaRoughness,\n        alphaRoughness * alphaRoughness\n    );\n\n    vec3 color = vec3(0.0);\n    vec3 lightSources = vec3(0.0);\n\n    // Disk lights with shadow mapping\n    if (u_lightSampleIndex >= 0) {\n        vec4 vLightViewSpace = u_lightView * vec4(v_position, 1.0);\n        vec4 vLightViewProjectionSpace = u_lightProjection * vLightViewSpace;\n\n        float lightDepth = clamp((length(vLightViewSpace.xyz) - u_lightNearFar[0]) / (u_lightNearFar[1] - u_lightNearFar[0]), 0.0, 1.0);\n        vec2 shadowUv = (vLightViewProjectionSpace.xy / vLightViewProjectionSpace.w) * 0.5 + 0.5;\n\n        const float shadowBias = -0.0003;\n        float visibility = SMCompare(u_shadowMap, shadowUv, lightDepth, shadowBias);\n\n        if (any(greaterThan(shadowUv, vec2(1.0))) || any(lessThan(shadowUv, vec2(0.0)))) {\n            visibility = 1.0;\n        }\n\n        lightSources += diffuseDiskLightApproximated(u_diskLights[u_lightSampleIndex], info) * u_lightFactor * visibility;\n        lightSources += specularDiskLightKaris(u_diskLights[u_lightSampleIndex], info) * u_lightFactor * visibility;\n    }\n\n    color += lightSources;\n\n    // Environment lighting\n    mat3 TBN = generateTBN(info);\n    bool applyOcclusion = u_frameNumber > 0;\n    vec3 environmentLight = vec3(0.0);\n\n    for (int i = 0; i < u_numDiffuseEnvironmentSamples; ++i) {\n        environmentLight += sampleDiffuseEnvironment(info, TBN, applyOcclusion) * u_diffuseEnvironmentFactor;\n    }\n\n    for (int i = 0; i < u_numSpecularEnvironmentSamples; ++i) {\n        environmentLight += sampleSpecularEnvironment(info, TBN, applyOcclusion) * u_specularEnvironmentFactor;\n    }\n\n    color += environmentLight;\n\n    // Emissive lighting\n    if (checkFlag(HAS_EMISSIVEMAP)) {\n        vec3 emissive = SRGBtoLINEAR(texture(u_emissive, v_uv[u_emissiveTexCoord])).rgb * u_emissiveFactor;\n        color += emissive;\n    }\n\n    // NOTE: the spec mandates to ignore any alpha value in \'OPAQUE\' mode\n    float alpha = 1.0;\n    if (u_blendMode == 1) {\n        if (baseColor.a < u_blendCutoff) {\n            discard;\n        }\n    }\n    else if (u_blendMode == 2) {\n        alpha = baseColor.a;\n    }\n\n    fragColor = vec4(color, alpha);\n\n    if (u_debugMode == 2) { // IBL\n        fragColor = vec4(environmentLight, alpha);\n    }\n    else if (u_debugMode == 3) { // Light sources\n        fragColor = vec4(lightSources, alpha);\n    }\n}\n'},387:e=>{e.exports="\n#if __VERSION__ == 100\n\n    #ifdef GL_OES_standard_derivatives\n        #extension GL_OES_standard_derivatives : enable\n    #endif\n\n#endif\n\nprecision highp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n\nuniform vec2 u_lightNearFar;\nuniform vec3 u_lightPosition;\nuniform mat4 u_view;\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nvarying vec3 v_position;\n\n\n\nvec2 SMCoordinates(vec4 worldPosition, mat4 shadowViewProjection)\n{\n    vec4 transformed = shadowViewProjection * worldPosition;\n    return transformed.xy / transformed.w * 0.5 + 0.5;\n}\n\nfloat SMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    return (distance(worldPosition, lightPosition) - lightNearFar.x) / (lightNearFar.y - lightNearFar.x);\n}\n\nfloat SMCompare(sampler2D depths, vec2 uv, float compare, float offset)\n{\n    float depth = texture(depths, uv).r;\n    return step(compare + offset, depth);\n}\n\nvec2 VSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n\n    vec2 df = vec2(dFdx(depth), dFdy(depth));\n    float moment = depth * depth + 0.25 * dot(df, df);\n\n    return vec2(depth, moment);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float compare, float minVariance, float lightBleedingReduction)\n{\n    float p = 0.0;\n\n    // Surface is fully lit, as the current fragment is before the light occluder\n    if (compare <= moments.x)\n        p = 1.0;\n\n    // The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n    // How likely this pixel is to be lit (p_max)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    float d = compare - moments.x;\n    float p_max = variance / (variance + d*d);\n\n    // Correct light bleeding\n    p_max = smoothstep(lightBleedingReduction, 1.0, p_max);\n\n    return max(p, p_max);\n}\n\nfloat VSMCompare(sampler2D depths, vec2 uv, float compare, float minVariance, float lightBleedingReduction)\n{\n    vec2 moments = texture(depths, uv).rg;\n    return chebyshevUpperBound(moments, compare, minVariance, lightBleedingReduction);\n}\n\nfloat ESMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, float exponent)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    return exp(exponent * depth);\n}\n\nfloat ESMCompare(sampler2D depths, vec2 uv, float compare, float exponent)\n{\n    float expDepth = texture(depths, uv).r;\n    return clamp(expDepth * exp(-exponent  * compare), 0.0, 1.0);\n}\n\nvec2 EVSMWarpDepth(float depth, vec2 exponents)\n{\n    depth = depth * 2.0 - 1.0;\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\nvec4 EVSMDepth(vec3 worldPosition, vec3 lightPosition, vec2 lightNearFar, vec2 exponents)\n{\n    float depth = SMDepth(worldPosition, lightPosition, lightNearFar);\n    vec2 warpedDepth = EVSMWarpDepth(depth, exponents);\n    return vec4(warpedDepth, warpedDepth * warpedDepth);\n}\n\nfloat EVSMCompare(sampler2D depths, vec2 uv, float compare, vec2 exponents, float lightBleedingReduction)\n{\n    vec4 moments = texture(depths, uv);\n    vec2 warpedCompare = EVSMWarpDepth(compare, exponents);\n    vec2 depthScale = 0.0001 * exponents * warpedCompare;\n    vec2 minVariance = depthScale * depthScale;\n    return min(\n        chebyshevUpperBound(moments.xz, warpedCompare.x, minVariance.x, lightBleedingReduction),\n        chebyshevUpperBound(moments.yw, warpedCompare.y, minVariance.y, lightBleedingReduction)\n    );\n}\n\n// vec4 calculateShadowColor(vec4 objectColor, float visibility, float intensity, vec4 shadowColor, float colorIntensity)\n// {\n//   visibility = min(visibility + (1.0 - intensity) * (1.0 - visibility), 1.0);\n\n//   vec4 finalColor = vec4(visibility * objectColor.rgb, objectColor.a);\n//   if (visibility < 1.0)\n//   {\n//     finalColor = clamp(shadowColor * colorIntensity + finalColor, finalColor, objectColor);\n//   }\n\n//   return finalColor;\n// }\n\n\nvoid main(void)\n{\n    vec4 viewPosition = u_view * vec4(v_position, 1.0);\n    fragColor = vec4(VSMDepth(v_position, u_lightPosition, u_lightNearFar), 0.0, 1.0);\n}\n"},608:e=>{e.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else\n    layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nvarying vec2 v_uv;\n\n\nvoid main(void)\n{\n    v_uv = a_vertex * 0.5 + 0.5;\n\n    gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n"},160:n=>{"use strict";n.exports=e}},t={};function i(e){var r=t[e];if(void 0!==r)return r.exports;var a=t[e]={exports:{}};return n[e].call(a.exports,a,a.exports,i),a.exports}i.d=(e,n)=>{for(var t in n)i.o(n,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},i.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{"use strict";var e=r;Object.defineProperty(e,"__esModule",{value:!0}),e.ProgressiveLightingDemo=e.ProgressiveLightingRenderer=void 0;const n=i(659),t=i(160),a=i(160),o=i(66),s=i(60),c=i(526),u=i(971),l=i(982),h=i(605);class f extends a.Renderer{onInitialize(e,t,r){const c=this._context.gl,l=this._context.gl2facade;e.enable(["OES_standard_derivatives","WEBGL_color_buffer_float","OES_texture_float","OES_texture_float_linear"]),this._loader=new a.GLTFLoader(this._context),this._cornellScene=new s.Scene(`${f.URL}/models/cornell.glb`,new a.Camera(n.vec3.fromValues(-.255,3.09,-8),n.vec3.fromValues(.135,1.192,-.46)),.2,20),this._cornellScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(.13,2.32,-.23),.15,n.vec3.fromValues(303,303,303),n.vec3.fromValues(0,-1,0),90)),this._skylineScene=new s.Scene(`${f.URL}/models/skyline.glb`,new a.Camera(n.vec3.fromValues(-4.0645,2.816,6.2326),n.vec3.fromValues(.342,-.42328,.1032)),.2,20),this._skylineScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(1.827,2.5,-1.11),.25,n.vec3.fromValues(501,501,501),n.vec3.fromValues(-.5554236173629761,-.7600213289260864,.33744949102401733),110)),this._skylineScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(-2.03,2.5,-1.205),.25,n.vec3.fromValues(501,501,501),n.vec3.fromValues(.5903826355934143,-.7270721793174744,.3504488170146942),110)),this._skylineScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(1.418,2.5,2.17),.25,n.vec3.fromValues(501,501,501),n.vec3.fromValues(-.39374271035194397,-.6941867470741272,-.6025540828704834),110)),this._skylineScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(-1.642,2.5,1.9708),.25,n.vec3.fromValues(501,501,501),n.vec3.fromValues(.45841217041015625,-.6979479193687439,-.5502063035964966),110)),this._datsunScene=new s.Scene(`${f.URL}/models/datsun.glb`,new a.Camera(n.vec3.fromValues(-1.9631,1.89,6.548),n.vec3.fromValues(.292,-.327,-.13)),.2,30),this._datsunScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(-3.04,3,-1.4),.15,n.vec3.fromValues(901,901,901),n.vec3.fromValues(.67636,-.66746,.31148),110)),this._datsunScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(2.62,3,-1.4),.15,n.vec3.fromValues(901,901,901),n.vec3.fromValues(-.62057,-.71058,.3316),110)),this._datsunScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(-2.12,3,2.1),.15,n.vec3.fromValues(901,901,901),n.vec3.fromValues(.50102,-.70899,-.49629),110)),this._datsunScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(2.14,3,2.1),.15,n.vec3.fromValues(901,901,901),n.vec3.fromValues(-.50454,-.70731,-.49511),110)),this._kitchenScene=new s.Scene(`${f.URL}/models/kitchen.glb`,new a.Camera(n.vec3.fromValues(-.65597,2.2284,6.2853),n.vec3.fromValues(.24971,1.1144,-.7265)),.1,10),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(-.54,1.6,-1.17),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(.88,1.6,-1.17),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(1.62,1.6,-1.17),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(.16,1.6,-1.17),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(1.92,1.6,-.86),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._kitchenScene.addDiskLight(new u.DiskLight(n.vec3.fromValues(1.92,1.6,-.22),.025,n.vec3.fromValues(5001,5001,5001),n.vec3.fromValues(0,-1,0),160)),this._emptyTexture=new a.Texture2D(this._context,"EmptyTexture"),this._emptyTexture.initialize(1,1,c.RGBA,c.RGBA,c.UNSIGNED_BYTE),this._defaultFramebuffer=new a.DefaultFramebuffer(this._context,"DefaultFBO"),this._defaultFramebuffer.initialize(),this._ndcTriangle=new a.NdcFillingTriangle(this._context),this._ndcTriangle.initialize();const h=new a.Shader(this._context,c.VERTEX_SHADER,"mesh.vert");h.initialize(i(683));const m=new a.Shader(this._context,c.FRAGMENT_SHADER,"progressive_lighting.frag");m.initialize(i(383)),this._program=new a.Program(this._context,"ProgressiveLightingProgram"),this._program.initialize([h,m]),this._uViewProjection=this._program.uniform("u_viewProjection"),this._uView=this._program.uniform("u_view"),this._uProjection=this._program.uniform("u_projection"),this._uModel=this._program.uniform("u_model"),this._uNormalMatrix=this._program.uniform("u_normalMatrix"),this._uViewNormalMatrix=this._program.uniform("u_viewNormalMatrix"),this._uCameraNearFar=this._program.uniform("u_cameraNearFar"),this._uBaseColor=this._program.uniform("u_baseColor"),this._uBaseColorTexCoord=this._program.uniform("u_baseColorTexCoord"),this._uMetallicRoughness=this._program.uniform("u_metallicRoughness"),this._uMetallicRoughnessTexCoord=this._program.uniform("u_metallicRoughnessTexCoord"),this._uNormal=this._program.uniform("u_normal"),this._uNormalTexCoord=this._program.uniform("u_normalTexCoord"),this._uEmissive=this._program.uniform("u_emissive"),this._uEmissiveTexCoord=this._program.uniform("u_emissiveTexCoord"),this._uOcclusion=this._program.uniform("u_occlusion"),this._uOcclusionTexCoord=this._program.uniform("u_occlusionTexCoord"),this._uNdcOffset=this._program.uniform("u_ndcOffset"),this._uFrameNumber=this._program.uniform("u_frameNumber"),this._uCocPoint=this._program.uniform("u_cocPoint"),this._uEye=this._program.uniform("u_eye"),this._uGeometryFlags=this._program.uniform("u_geometryFlags"),this._uPbrFlags=this._program.uniform("u_pbrFlags"),this._uBaseColorFactor=this._program.uniform("u_baseColorFactor"),this._uMetallicFactor=this._program.uniform("u_metallicFactor"),this._uRoughnessFactor=this._program.uniform("u_roughnessFactor"),this._uEmissiveFactor=this._program.uniform("u_emissiveFactor"),this._uNormalScale=this._program.uniform("u_normalScale"),this._uBlendMode=this._program.uniform("u_blendMode"),this._uBlendCutoff=this._program.uniform("u_blendCutoff"),this._uLightSampleIndex=this._program.uniform("u_lightSampleIndex"),this._uLightFactor=this._program.uniform("u_lightFactor"),this._uNumDiffuseEnvironmentSamples=this._program.uniform("u_numDiffuseEnvironmentSamples"),this._uDiffuseEnvironmentFactor=this._program.uniform("u_diffuseEnvironmentFactor"),this._uNumSpecularEnvironmentSamples=this._program.uniform("u_numSpecularEnvironmentSamples"),this._uSpecularEnvironmentFactor=this._program.uniform("u_specularEnvironmentFactor"),this._uDiffuseEnvironment=this._program.uniform("u_diffuseEnvironment"),this._uSpecularEnvironment=this._program.uniform("u_specularEnvironment"),this._uBRDFLookupTable=this._program.uniform("u_brdfLUT"),this._uLastFrame=this._program.uniform("u_lastFrame"),this._uShadowMap=this._program.uniform("u_shadowMap"),this._uNormalDepth=this._program.uniform("u_normalDepth"),this._uLightView=this._program.uniform("u_lightView"),this._uLightProjection=this._program.uniform("u_lightProjection"),this._uLightNearFar=this._program.uniform("u_lightNearFar"),this._uOcclusionRange=this._program.uniform("u_occlusionRange"),this._uIBLStrength=this._program.uniform("u_iblStrength");const d=new a.Shader(this._context,c.VERTEX_SHADER,"mesh.vert");d.initialize(i(683));const p=new a.Shader(this._context,c.FRAGMENT_SHADER,"shadow.frag");p.initialize(i(387)),this._shadowProgram=new a.Program(this._context,"ShadowProgram"),this._shadowProgram.initialize([d,p]),this._uModelS=this._shadowProgram.uniform("u_model"),this._uViewS=this._shadowProgram.uniform("u_view"),this._uProjectionS=this._shadowProgram.uniform("u_projection"),this._uLightNearFarS=this._shadowProgram.uniform("u_lightNearFar"),this._uLightPositionS=this._shadowProgram.uniform("u_lightPosition");const v=new a.Shader(this._context,c.VERTEX_SHADER,"mesh.vert");v.initialize(i(683));const _=new a.Shader(this._context,c.FRAGMENT_SHADER,"normal_depth.frag");_.initialize(i(486)),this._depthProgram=new a.Program(this._context,"NormalDepthProgram"),this._depthProgram.initialize([v,_]),this._uViewD=this._depthProgram.uniform("u_view"),this._uProjectionD=this._depthProgram.uniform("u_projection"),this._uCameraNearFarD=this._depthProgram.uniform("u_cameraNearFar"),this._uModelD=this._depthProgram.uniform("u_model"),this._camera=new a.Camera,this._navigation=new a.Navigation(t,r),this._navigation.camera=this._camera,this._colorRenderTexture=new a.Texture2D(this._context,"ColorRenderTexture"),this._depthRenderbuffer=new a.Renderbuffer(this._context,"DepthRenderbuffer"),this._intermediateFBO=new a.Framebuffer(this._context,"IntermediateFBO"),this._preDepthFBO=new a.Framebuffer(this._context,"PreDepthFBO"),this._normalDepthTexture=new a.Texture2D(this._context,"NormalDepthTexture"),this._preDepthRenderbuffer=new a.Renderbuffer(this._context,"PreDepthRenderbuffer"),this._forwardPass=new a.ForwardSceneRenderPass(e),this._forwardPass.initialize(),this._forwardPass.camera=this._camera,this._forwardPass.target=this._intermediateFBO,this._forwardPass.program=this._program,this._forwardPass.updateViewProjectionTransform=e=>{c.uniformMatrix4fv(this._uViewProjection,c.FALSE,e)},this._accumulatePass=new a.AccumulatePass(e),this._accumulatePass.initialize(this._ndcTriangle),this._accumulatePass.precision=a.Wizard.Precision.float,this._accumulatePass.texture=this._colorRenderTexture,this._postProcessingPass=new o.PostProcessingPass(e),this._postProcessingPass.initialize(this._ndcTriangle),this._shadowPass=new a.ShadowPass(e),this._shadowPass.initialize(a.ShadowPass.ShadowMappingType.HardLinear,[2048,2048]),this._blitPass=new a.BlitPass(this._context),this._blitPass.initialize(this._ndcTriangle),this._blitPass.framebuffer=this._postProcessingPass.framebuffer,this._blitPass.readBuffer=l.COLOR_ATTACHMENT0,this._blitPass.target=this._defaultFramebuffer,this._blitPass.drawBuffer=c.BACK,this.loadEnvironmentMap(),window.document.getElementById("asset-select").onchange=e=>{this.loadAsset()},window.document.getElementById("environment-select").onchange=e=>{this.loadEnvironmentMap(),this._invalidate(!0)},window.document.getElementById("debug-select").onchange=e=>{this.setDebugMode(),this._invalidate(!0)};const g=window.document.getElementById("exposure-range");g.onchange=e=>{this._postProcessingPass.exposure=parseFloat(g.value)/10,this._invalidate(!0)};const M=window.document.getElementById("ibl-range");M.onchange=e=>{this._program.bind(),c.uniform1f(this._uIBLStrength,parseFloat(M.value)/20),this._program.unbind(),this._invalidate(!0)},M.onchange(new Event(""));const b=window.document.getElementById("occlusion-range");b.onchange=e=>{this._program.bind(),c.uniform1f(this._uOcclusionRange,parseFloat(b.value)/300),this._program.unbind(),this._invalidate(!0)},b.onchange(new Event(""));const x=window.document.getElementById("dof-range");return x.onchange=e=>{this._depthOfFieldRange=parseFloat(x.value)/1e3,this._invalidate(!0)},x.onchange(new Event("")),!0}onUninitialize(){super.uninitialize()}onDiscarded(){this._altered.alter("canvasSize"),this._altered.alter("clearColor"),this._altered.alter("frameSize"),this._altered.alter("multiFrameNumber")}onUpdate(){return(this._altered.frameSize||this._camera.altered)&&(this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),(this._altered.canvasSize||this._camera.altered)&&(this._camera.aspect=this._canvasSize[0]/this._canvasSize[1]),this._navigation.update(),this._forwardPass.update(),this._altered.any||this._camera.altered}onPrepare(){const e=this._context.gl,n=this._context.gl2facade;void 0===this._forwardPass.scene&&this.loadAsset();const t=Math.round(this._multiFrameNumber/this._currentScene.diskLights.length/4),i=Math.round(this._multiFrameNumber);this._sampleManager=new h.SampleManager(this._currentScene,this._multiFrameNumber,t,i),this._intermediateFBO.initialized||(this._colorRenderTexture.initialize(this._frameSize[0],this._frameSize[1],this._context.isWebGL2?e.RGBA32F:e.RGBA,e.RGBA,e.FLOAT),this._depthRenderbuffer.initialize(this._frameSize[0],this._frameSize[1],e.DEPTH_COMPONENT16),this._intermediateFBO.initialize([[n.COLOR_ATTACHMENT0,this._colorRenderTexture],[e.DEPTH_ATTACHMENT,this._depthRenderbuffer]])),this._preDepthFBO.initialized||(this._normalDepthTexture.initialize(this._frameSize[0],this._frameSize[1],this._context.isWebGL2?e.RGBA32F:e.RGBA,(this._context.isWebGL2,e.RGBA),e.FLOAT),this._preDepthRenderbuffer.initialize(this._frameSize[0],this._frameSize[1],e.DEPTH_COMPONENT16),this._preDepthFBO.initialize([[n.COLOR_ATTACHMENT0,this._normalDepthTexture],[e.DEPTH_ATTACHMENT,this._preDepthRenderbuffer]])),this._altered.multiFrameNumber&&(this._ndcOffsetKernel=new a.AntiAliasingKernel(this._multiFrameNumber),this._depthOfFieldKernel=new l.DepthOfFieldKernel(this._multiFrameNumber)),this._altered.frameSize&&(this._intermediateFBO.resize(this._frameSize[0],this._frameSize[1]),this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),this._altered.clearColor&&(this._intermediateFBO.clearColor(this._clearColor),this._forwardPass.clearColor=this._clearColor),this._forwardPass.prepare(),this._accumulatePass.update(),this._postProcessingPass.texture=this._accumulatePass.framebuffer.texture(n.COLOR_ATTACHMENT0),this._postProcessingPass.normalDepthTexture=this._normalDepthTexture,this._postProcessingPass.update(),this.bindMultiframeUniforms(),this._altered.reset(),this._camera.altered=!1}preDepthPass(){const e=this._context.gl;this._preDepthFBO.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT,!0,!1),e.viewport(0,0,this._preDepthFBO.width,this._preDepthFBO.height),this._depthProgram.bind(),this._forwardPass.program=this._depthProgram,this._forwardPass.target=this._preDepthFBO,this._forwardPass.bindMaterial=e=>{},this._forwardPass.bindGeometry=e=>{},this._forwardPass.updateModelTransform=n=>{e.uniformMatrix4fv(this._uModelD,e.FALSE,n)},this._forwardPass.drawCalls(!1)}shadowPass(e,t){const i=this._context.gl,r=this._currentScene.diskLights[e],o=n.vec3.add(n.vec3.create(),t,r.direction),s=new a.Camera;s.eye=t,s.center=o,s.up=n.vec3.fromValues(1,0,0),s.near=.1,s.far=30,s.fovy=r.fovy;const c=n.vec2.fromValues(s.near,s.far);this._shadowPass.frame((()=>{this._shadowProgram.bind(),i.uniformMatrix4fv(this._uProjectionS,i.FALSE,s.projection),i.uniformMatrix4fv(this._uViewS,i.FALSE,s.view),i.uniform2fv(this._uLightNearFarS,c),i.uniform3fv(this._uLightPositionS,t),this._forwardPass.bindMaterial=e=>{},this._forwardPass.bindGeometry=e=>{},this._forwardPass.updateModelTransform=e=>{i.uniformMatrix4fv(this._uModelS,i.FALSE,e)},this._forwardPass.drawCalls(!1),this._shadowProgram.unbind()})),this._program.bind(),i.uniformMatrix4fv(this._uLightView,i.FALSE,s.view),i.uniformMatrix4fv(this._uLightProjection,i.FALSE,s.projection),i.uniform2fv(this._uLightNearFar,c),this._program.unbind()}onFrame(e){if(this.isLoading)return;t.auxiliaries.assert(void 0!==this._forwardPass.scene,"Scene undefined in onFrame.");const i=this._context.gl,r=this._context.gl2facade;this.prepareFrame(e),this._forwardPass.program=this._program,this._forwardPass.target=this._intermediateFBO,this._forwardPass.bindMaterial=e=>{const n=e;t.auxiliaries.assert(void 0!==n,`Material ${e.name} is not a PBR material.`),void 0!==n.baseColorTexture?(n.baseColorTexture.bind(i.TEXTURE0),i.uniform1i(this._uBaseColorTexCoord,n.baseColorTexCoord)):this._emptyTexture.bind(i.TEXTURE0),void 0!==n.metallicRoughnessTexture?(n.metallicRoughnessTexture.bind(i.TEXTURE1),i.uniform1i(this._uMetallicRoughnessTexCoord,n.metallicRoughnessTexCoord)):this._emptyTexture.bind(i.TEXTURE1),void 0!==n.normalTexture?(n.normalTexture.bind(i.TEXTURE2),i.uniform1i(this._uNormalTexCoord,n.normalTexCoord)):this._emptyTexture.bind(i.TEXTURE2),void 0!==n.occlusionTexture?(n.occlusionTexture.bind(i.TEXTURE3),i.uniform1i(this._uOcclusionTexCoord,n.occlusionTexCoord)):this._emptyTexture.bind(i.TEXTURE3),void 0!==n.emissiveTexture?(n.emissiveTexture.bind(i.TEXTURE4),i.uniform1i(this._uEmissiveTexCoord,n.emissiveTexCoord)):this._emptyTexture.bind(i.TEXTURE4),i.uniform4fv(this._uBaseColorFactor,n.baseColorFactor),i.uniform3fv(this._uEmissiveFactor,n.emissiveFactor),i.uniform1f(this._uMetallicFactor,n.metallicFactor),i.uniform1f(this._uRoughnessFactor,n.roughnessFactor),i.uniform1f(this._uNormalScale,n.normalScale),i.uniform1i(this._uPbrFlags,n.flags),n.alphaMode===a.GLTFAlphaMode.OPAQUE?(i.disable(i.BLEND),i.uniform1i(this._uBlendMode,0)):n.alphaMode===a.GLTFAlphaMode.MASK?(i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),i.uniform1i(this._uBlendMode,1),i.uniform1f(this._uBlendCutoff,n.alphaCutoff)):n.alphaMode===a.GLTFAlphaMode.BLEND?(i.enable(i.BLEND),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.uniform1i(this._uBlendMode,2)):t.auxiliaries.log(t.auxiliaries.LogLevel.Warning,"Unknown blend mode encountered.")},this._forwardPass.bindGeometry=e=>{const n=e;i.uniform1i(this._uGeometryFlags,n.flags)},this._forwardPass.updateModelTransform=e=>{i.uniformMatrix4fv(this._uModel,i.FALSE,e);const t=n.mat3.create();n.mat3.normalFromMat4(t,e),i.uniformMatrix3fv(this._uNormalMatrix,i.FALSE,t)},this._forwardPass.frame(),this._accumulatePass.frame(e),this._postProcessingPass.texture=this._accumulatePass.framebuffer.texture(r.COLOR_ATTACHMENT0),this._postProcessingPass.frame()}onSwap(){this._blitPass.frame()}bindMultiframeUniforms(){const e=this._context.gl;this._program.bind(),e.uniformMatrix4fv(this._uView,e.FALSE,this._camera.view),e.uniformMatrix4fv(this._uProjection,e.FALSE,this._camera.projection),e.uniform2fv(this._uCameraNearFar,n.vec2.fromValues(this._camera.near,this._camera.far));const t=n.mat3.create();n.mat3.normalFromMat4(t,this._camera.view),e.uniformMatrix3fv(this._uViewNormalMatrix,e.FALSE,t),e.uniform3fv(this._uEye,this._camera.eye),e.uniform1i(this._uBaseColor,0),e.uniform1i(this._uMetallicRoughness,1),e.uniform1i(this._uNormal,2),e.uniform1i(this._uOcclusion,3),e.uniform1i(this._uEmissive,4),e.uniform1i(this._uDiffuseEnvironment,10),e.uniform1i(this._uSpecularEnvironment,5),e.uniform1i(this._uBRDFLookupTable,6),e.uniform1i(this._uShadowMap,7),e.uniform1i(this._uNormalDepth,8),e.uniform1i(this._uLastFrame,9),this._specularEnvironment.bind(e.TEXTURE5),this._diffuseEnvironment.bind(e.TEXTURE10),this._brdfLUT.bind(e.TEXTURE6),this._shadowPass.shadowMapTexture.bind(e.TEXTURE7),this._normalDepthTexture.bind(e.TEXTURE8),this._depthProgram.bind(),e.uniform2fv(this._uCameraNearFarD,n.vec2.fromValues(this._camera.near,this._camera.far)),e.uniformMatrix4fv(this._uViewD,e.FALSE,this._camera.view),e.uniformMatrix4fv(this._uProjectionD,e.FALSE,this._camera.projection),this._depthProgram.unbind()}prepareFrame(e){const t=this._context.gl,i=this._context.gl2facade,r=this._sampleManager.getNextFrameSamples();let a=0,o=1,s=0,c=1,u=-1,l=n.vec3.create(),f=1;for(const e of r)e instanceof h.DiffuseEnvironmentSample&&(a++,o=e.factor),e instanceof h.SpecularEnvironmentSample&&(s++,c=e.factor),e instanceof h.LightSample&&(u=e.lightIndex,l=e.eye,f=e.factor);1===e&&this.preDepthPass(),u>=0&&this.shadowPass(u,l),this._program.bind(),t.uniform1i(this._uFrameNumber,e);const m=this._ndcOffsetKernel.get(e);m[0]=2*m[0]/this._frameSize[0],m[1]=2*m[1]/this._frameSize[1],t.uniform2fv(this._uNdcOffset,m);const d=this._depthOfFieldKernel.get(e);d[0]*=this._depthOfFieldRange,d[1]*=this._depthOfFieldRange,t.uniform2fv(this._uCocPoint,d),t.uniform1i(this._uLightSampleIndex,u),t.uniform1f(this._uLightFactor,f),t.uniform1i(this._uNumDiffuseEnvironmentSamples,a),t.uniform1f(this._uDiffuseEnvironmentFactor,o),t.uniform1i(this._uNumSpecularEnvironmentSamples,s),t.uniform1f(this._uSpecularEnvironmentFactor,c),this._accumulatePass.framebuffer.texture(i.COLOR_ATTACHMENT0).bind(t.TEXTURE9)}loadAsset(){const e=window.document.getElementById("asset-select");let n;"Datsun"===e.value?n=this._datsunScene:"Kitchen"===e.value?n=this._kitchenScene:"Cornell"===e.value?n=this._cornellScene:"Skyline"===e.value&&(n=this._skylineScene),t.auxiliaries.assert(void 0!==n,`Unknown scene ${e.value}.`),void 0!==n?(this.startLoading(),this._postProcessingPass.clear(),this._currentScene=n,this._camera=n.camera,this.updateCamera(),this.updateLights(n),this._loader.uninitialize(),this._loader.loadAsset(n.uri).then((()=>{this._forwardPass.scene=this._loader.defaultScene,this._invalidate(!0),this.finishLoading()}))):t.auxiliaries.log(t.auxiliaries.LogLevel.Error,`Scene ${e.value} could not be loaded.`)}setDebugMode(){const e=this._context.gl,n=window.document.getElementById("debug-select");let t=0;"Final"===n.value?t=0:"Flat"===n.value?t=1:"IBL"===n.value?t=2:"Light sources"===n.value?t=3:"Illuminance"===n.value&&(t=4),this._program.bind(),e.uniform1i(this._program.uniform("u_debugMode"),t),this._program.unbind()}updateLights(e){const n=this._context.gl;this._program.bind(),n.uniform1i(this._program.uniform("u_numDiskLights"),e.diskLights.length);let t=0;for(const i of e.diskLights)n.uniform3fv(this._program.uniform(`u_diskLights[${t}].center`),i.center),n.uniform1f(this._program.uniform(`u_diskLights[${t}].radius`),i.radius),n.uniform3fv(this._program.uniform(`u_diskLights[${t}].luminance`),i.luminance),n.uniform3fv(this._program.uniform(`u_diskLights[${t}].direction`),i.direction),t++;this._program.unbind()}updateCamera(){this._camera.viewport=[this._frameSize[0],this._frameSize[1]],this._camera.aspect=this._canvasSize[0]/this._canvasSize[1];const e=39.6*t.auxiliaries.DEG2RAD,n=2*Math.atan(Math.tan(e/2)*(1/this._camera.aspect));this._camera.fovy=n*t.auxiliaries.RAD2DEG,this._forwardPass.camera=this._camera,this._navigation.camera=this._camera,this._camera.altered=!0}loadEnvironmentMap(){const e=window.document.getElementById("environment-select").value,n=this._context.gl;this._brdfLUT=new a.Texture2D(this._context,"BRDFLookUpTable"),this._brdfLUT.initialize(1,1,n.RG16F,n.RG,n.FLOAT),this._brdfLUT.wrap(n.CLAMP_TO_EDGE,n.CLAMP_TO_EDGE),this._brdfLUT.filter(n.LINEAR,n.LINEAR),this._brdfLUT.fetch("/examples/data/imagebasedlighting/brdfLUT.png");const t=a.Wizard.queryInternalTextureFormat(this._context,n.RGBA,a.Wizard.Precision.byte);this._diffuseEnvironment=new a.TextureCube(this._context,"DiffuseEnvironment"),this._diffuseEnvironment.initialize(64,t[0],n.RGBA,t[1]),this._diffuseEnvironment.fetch({positiveX:`${f.URL}/${e}/preprocessed-map-px-diffuse.png`,negativeX:`${f.URL}/${e}/preprocessed-map-nx-diffuse.png`,positiveY:`${f.URL}/${e}/preprocessed-map-py-diffuse.png`,negativeY:`${f.URL}/${e}/preprocessed-map-ny-diffuse.png`,positiveZ:`${f.URL}/${e}/preprocessed-map-pz-diffuse.png`,negativeZ:`${f.URL}/${e}/preprocessed-map-nz-diffuse.png`},!0),this._specularEnvironment=new a.TextureCube(this._context,"SpecularEnvironment"),this._specularEnvironment.initialize(512,t[0],n.RGBA,t[1]),this._specularEnvironment.filter(n.LINEAR,n.LINEAR_MIPMAP_LINEAR),this._specularEnvironment.levels(0,8);for(let n=0;n<9;++n)this._specularEnvironment.fetch({positiveX:`${f.URL}/${e}/preprocessed-map-px-${n}.png`,negativeX:`${f.URL}/${e}/preprocessed-map-nx-${n}.png`,positiveY:`${f.URL}/${e}/preprocessed-map-py-${n}.png`,negativeY:`${f.URL}/${e}/preprocessed-map-ny-${n}.png`,positiveZ:`${f.URL}/${e}/preprocessed-map-pz-${n}.png`,negativeZ:`${f.URL}/${e}/preprocessed-map-nz-${n}.png`},!0,n)}}e.ProgressiveLightingRenderer=f,f.URL="https://p-otto.waduhek.de";class m extends c.Demo{onInitialize(e){this._canvas=new a.Canvas(e),this._canvas.controller.multiFrameNumber=128,this._canvas.framePrecision=a.Wizard.Precision.float,this._canvas.frameScale=[1,1],this._renderer=new f,this._canvas.renderer=this._renderer;const n=window.document.getElementById("frame-scale");n.onchange=e=>{const t=parseFloat(n.value)/100;this._canvas.frameScale=[t,t]};const t=window.document.getElementById("multiframe-count");return t.onchange=e=>{this._canvas.controller.multiFrameNumber=parseInt(t.value,10)},!0}onUninitialize(){this._canvas.dispose(),this._renderer.uninitialize()}get canvas(){return this._canvas}get renderer(){return this._renderer}}e.ProgressiveLightingDemo=m})(),r})()));
//# sourceMappingURL=progressive-lighting.js.map