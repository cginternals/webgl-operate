{"version":3,"file":"cornell-box.js","mappings":"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","sources":["webpack:///webpack/universalModuleDefinition","webpack:///./cornell-box/cornellboxdata.ts","webpack:///./demo.ts","webpack:///./cornell-box/cornell.vert","webpack:///./cornell-box/cornell0.frag","webpack:///./cornell-box/cornell1.frag","webpack:///./cornell-box/cornell2.frag","webpack:///external umd \"gloperate\"","webpack:///webpack/bootstrap","webpack:///./cornell-box/cornellbox.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gloperate\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gloperate\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"gloperate\")) : factory(root[\"gloperate\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__160__) => {\nreturn ","\n// http://www.graphics.cornell.edu/online/box/data.html\n\nexport let vertices = new Float32Array([\n    // room\n    -1.000000, -1.000000, -1.000000, -1.000000, -1.000000, +1.000000,\n    -1.000000, +1.000000, -1.000000, -1.000000, +1.000000, +1.000000,\n    +0.988489, -1.000000, -1.000000, +0.976978, -1.000000, +1.000000,\n    +1.000000, +1.000000, -1.000000, +1.000000, +1.000000, +1.000000,\n    // short block\n    +0.043165, -1.000000, -0.592275, +0.043165, -0.398688, -0.592275,\n    -0.136691, -1.000000, -0.027182, -0.136691, -0.398688, -0.027182,\n    -0.705036, -1.000000, -0.195279, -0.705036, -0.398688, -0.195279,\n    -0.532374, -1.000000, -0.767525, -0.532374, -0.398688, -0.767525,\n    // tall block\n    +0.521583, -1.000000, -0.116595, +0.521583, +0.202624, -0.116595,\n    +0.697842, -1.000000, +0.452074, +0.697842, +0.202624, +0.452074,\n    +0.129496, -1.000000, +0.630901, +0.129496, +0.202624, +0.630901,\n    -0.046763, -1.000000, +0.058655, -0.046763, +0.202624, +0.058655,\n]);\n\n\n/**\n * Indices per line: [ v0, v1, v2, color ]\n */\nexport let indices = new Uint8Array([\n    // room ceiling\n    6, 7, 3, 1,\n    6, 3, 2, 1,\n    // room floor\n    4, 0, 1, 1,\n    4, 1, 5, 1,\n    // room front wall\n    // 6, 2, 0, 1,\n    // 6, 0, 4, 1,\n    // room back wall\n    5, 1, 3, 1,\n    5, 3, 7, 1,\n    // room right wall\n    1, 0, 2, 3,\n    1, 2, 3, 3,\n    // room left wall\n    4, 5, 7, 2,\n    4, 7, 6, 2,\n    // short block\n    15, 13, 11, 1,\n    15, 11, 9, 1,\n    8, 9, 11, 1,\n    8, 11, 10, 1,\n    14, 15, 9, 1,\n    14, 9, 8, 1,\n    12, 13, 15, 1,\n    12, 15, 14, 1,\n    10, 11, 13, 1,\n    10, 13, 12, 1,\n    // tall block\n    23, 21, 19, 1,\n    23, 19, 17, 1,\n    16, 17, 19, 1,\n    16, 19, 18, 1,\n    22, 23, 17, 1,\n    22, 17, 16, 1,\n    20, 21, 23, 1,\n    20, 23, 22, 1,\n    18, 19, 21, 1,\n    18, 21, 20, 1,\n]);\n\n\nexport let colors = new Float32Array([\n    0.0000, 0.0000, 0.0000,  // 0 black\n    0.7295, 0.7355, 0.7290,  // 1 white\n    0.6110, 0.0555, 0.0620,  // 2 red\n    0.1170, 0.4125, 0.1150,  // 3 green\n    0.0620, 0.0555, 0.6110,  // 4 blue\n]);\n","\n/* spellchecker: disable */\n\nimport {\n    Canvas,\n    Initializable,\n    LoadingStatus,\n    Renderer,\n    viewer,\n} from 'webgl-operate';\n\n/* spellchecker: enable */\n\n\nexport abstract class Demo extends Initializable {\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected showSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'inline';\n    }\n\n    /**\n     * Hide the loading spinner.\n     */\n    protected hideSpinner(): void {\n        const spinnerElement = document.getElementsByClassName('spinner').item(0)!;\n        (spinnerElement as HTMLElement).style.display = 'none';\n    }\n\n    protected expose(): void {\n\n        (window as any)['canvas'] = this.canvas;\n        (window as any)['context'] = this.canvas.context;\n        (window as any)['controller'] = this.canvas.controller;\n\n        (window as any)['renderer'] = this.renderer;\n    }\n\n    initialize(element: HTMLCanvasElement | string): boolean {\n        const result = this.onInitialize(element);\n\n        this.renderer.loadingStatus$.subscribe((status: LoadingStatus) => {\n            if (status === LoadingStatus.Finished) {\n                this.hideSpinner();\n            } else if (status === LoadingStatus.Started) {\n                this.showSpinner();\n            }\n        });\n\n        this.expose();\n\n        return result;\n    }\n\n    uninitialize(): void {\n        this.onUninitialize();\n    }\n\n    abstract onInitialize(element: HTMLCanvasElement | string): boolean;\n\n    abstract onUninitialize(): void;\n\n    abstract get renderer(): Renderer;\n\n    abstract get canvas(): Canvas;\n\n    enableFullscreenOnCtrlClick(): void {\n\n        const e = this.canvas.element;\n        e.addEventListener('click', (event) => {\n            if (event.ctrlKey) { viewer.Fullscreen.toggle(e); }\n        });\n    }\n}\n","module.exports = \"\\nprecision lowp float;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else\\n    #define varying out\\n#endif\\n\\n\\n\\n#if __VERSION__ == 100\\n    attribute vec2 a_vertex;\\n#else\\n    layout(location = 0) in vec2 a_vertex;\\n#endif\\n\\n\\nuniform mat4 u_transform;\\nuniform mediump vec3 u_eye;\\nuniform vec2 u_ndcOffset;\\n\\nvarying mediump vec2 v_uv;\\nvarying mediump vec4 v_ray;\\n\\nvoid main()\\n{\\n    v_uv = a_vertex * 0.5 + 0.5;\\n    v_ray = u_transform * vec4(u_ndcOffset + a_vertex, 1.0, 1.0);\\n\\n    gl_Position = vec4(a_vertex, 1.0, 1.0);\\n}\\n\"","module.exports = \"\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n    #extension GL_OES_standard_derivatives : enable\\n    precision mediump float;\\n#else\\n    precision mediump float;\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nuniform sampler2D u_vertices; // 1D\\nuniform sampler2D u_indices;  // 1D\\nuniform sampler2D u_colors;   // 1D\\nconst float NUM_VERTICES = 24.0;\\nconst float NUM_TRIANGLES = 30.0;\\nconst float NUM_COLORS = 5.0;\\n\\nuniform sampler2D u_hsphere;\\nuniform sampler2D u_lights;\\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\\n\\n\\nconst vec3 premultUint8x3 = vec3(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0);\\nfloat uint8x3_to_float24x1(const in vec3 v) {\\n    return dot(v, premultUint8x3); // a1 * b1 + a2 * b2 + a3 * b3  ;)\\n}\\n\\nvec3 vertexFetch(const in float index) {\\n    // *3 because every vertex has 3 floats\\n    float realIndex = index * 3.0;\\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_VERTICES* 3.0 - 1.0), 0);\\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\\n    // read and scale from [0..1] to [-1..+1]\\n    float x = uint8x3_to_float24x1(texture(u_vertices, floatIndex1).xyz) * 2.0 - 1.0;\\n    float y = uint8x3_to_float24x1(texture(u_vertices, floatIndex2).xyz) * 2.0 - 1.0;\\n    float z = uint8x3_to_float24x1(texture(u_vertices, floatIndex3).xyz) * 2.0 - 1.0;\\n\\n    return vec3(x,y,z);\\n}\\n\\nvec4 indexFetch(const in float index) {\\n    // * 255 because openGL scales to [0..1]\\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\\n}\\n\\nvec3 colorFetch(const in float index) {\\n    // *3 because every color has 3 floats\\n    float realIndex = index * 3.0;\\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_COLORS* 3.0 - 1.0), 0);\\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_COLORS* 3.0 - 1.0), 0);\\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_COLORS* 3.0 - 1.0), 0);\\n\\n    float x = uint8x3_to_float24x1(texture(u_colors, floatIndex1).xyz);\\n    float y = uint8x3_to_float24x1(texture(u_colors, floatIndex2).xyz);\\n    float z = uint8x3_to_float24x1(texture(u_colors, floatIndex3).xyz);\\n\\n    return vec3(x,y,z);\\n}\\n\\nvec3 hsphereFetch(const in vec2 index) {\\n    // *3 because every vector has 3 floats\\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\\n\\n    float x = uint8x3_to_float24x1(texture(u_hsphere, floatIndex1).xyz) * 2.0 - 1.0;\\n    float y = uint8x3_to_float24x1(texture(u_hsphere, floatIndex2).xyz) * 2.0 - 1.0;\\n    float z = uint8x3_to_float24x1(texture(u_hsphere, floatIndex3).xyz) * 2.0 - 1.0;\\n\\n    return vec3(x,y,z);\\n}\\n\\nvec3 lightFetch(const in vec2 index) {\\n    // *3 because every vector has 3 floats\\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\\n    // read and scale from [0..1] to [-1..+1]\\n    float x = uint8x3_to_float24x1(texture(u_lights, floatIndex1).xyz) * 2.0 - 1.0;\\n    float y = uint8x3_to_float24x1(texture(u_lights, floatIndex2).xyz) * 2.0 - 1.0;\\n    float z = uint8x3_to_float24x1(texture(u_lights, floatIndex3).xyz) * 2.0 - 1.0;\\n\\n    return vec3(x,y,z);\\n}\\n\\n\\n\\n/*\\nneeds version specific stuff:\\nlayout(location = 0) out vec4 fragColor;\\n\\nconst float NUM_TRIANGLES\\nconst vec2 SPHERE_SAMPLER_SIZE\\nconst vec2 LIGHT_SAMPLER_SIZE\\n\\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\\nvec3 vertexFetch(const in float index) {}\\nvec4 indexFetch(const in float index) {}\\nvec3 colorFetch(const in float index) {}\\nvec3 hsphereFetch(const in vec2 index) {}\\nvec3 lightFetch(const in vec2 index) {}\\n*/\\n\\nuniform int u_frame;\\nuniform int u_rand;\\nuniform vec3 u_eye;\\nuniform vec4 u_viewport;\\n\\nvarying vec2 v_uv;\\nvarying vec4 v_ray;\\n\\nconst vec3 up = vec3(0.0, 1.0, 0.0);\\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\\n\\nconst float EPSILON  = 1e-6;\\nconst float INFINITY = 1e+4;\\n\\nconst int BOUNCES = 4;\\nconst float EXPOSURE = 4.0;\\nconst float GAMMA = 2.1;\\n\\n\\n\\n// intersection with triangle\\nbool intersectionTriangle(\\n\\tconst in vec3  triangle[3]\\n,\\tconst in vec3  origin\\n,\\tconst in vec3  ray\\n,\\tconst in float t_min\\n,   out float t)\\n{\\n    vec3 e0 = triangle[1] - triangle[0];\\n\\tvec3 e1 = triangle[2] - triangle[0];\\n\\n\\tvec3  h = cross(ray, e1);\\n\\tfloat a = dot(e0, h);\\n\\n\\t// if(a > -EPSILON && a < EPSILON) // backface culling off\\n\\tif(a < EPSILON) // backface culling on\\n\\t\\treturn false;\\n\\n\\tfloat f = 1.0 / a;\\n\\n\\tvec3  s = origin - triangle[0];\\n\\tfloat u = f * dot(s, h);\\n\\n\\tif(u < 0.0 || u > 1.0)\\n\\t\\treturn false;\\n\\n\\tvec3  q = cross(s, e0);\\n\\tfloat v = f * dot(ray, q);\\n\\n\\tif(v < 0.0 || u + v > 1.0)\\n\\t\\treturn false;\\n\\n\\tt = f * dot(e1, q);\\n\\n\\treturn EPSILON < t && t < t_min;\\n}\\n\\nbool intersectionSphere(\\n    const in vec4  sphere\\n,   const in vec3  origin\\n,   const in vec3  ray\\n,   const in float t_min\\n,   out float t)\\n{\\n    float radius = sphere.w;\\n    vec3 center = sphere.xyz; \\n    vec3 rayOriginToSphereCenter = origin - center;\\n    float dist = length(rayOriginToSphereCenter);\\n    float dot_term = dot(ray, rayOriginToSphereCenter);\\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\\n    if (someVar < EPSILON) { // no intersection\\n        return false;\\n    }\\n    t = -dot_term - sqrt(someVar);\\n    return EPSILON < t && t < t_min;\\n}\\n\\n// intersection with scene geometry\\nfloat intersection(\\n    const in vec3 origin\\n,   const in vec3 ray\\n,   out vec3 normal\\n,   out vec3 color\\n,   out bool reflecting)\\n{\\n    float t_min = INFINITY;\\n    float t = INFINITY;\\n\\n    float colorIndex;\\n\\n    // intersection with triangles\\n\\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\\n\\t{\\n        vec3 triangle[3];\\n        vec4 triangleIndices = indexFetch(float(i));\\n\\t\\ttriangle[0] = vertexFetch(triangleIndices[0]);\\n\\t\\ttriangle[1] = vertexFetch(triangleIndices[1]);\\n\\t\\ttriangle[2] = vertexFetch(triangleIndices[2]);\\n\\n\\t\\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\\n\\t\\t{\\n\\t\\t\\tnormal = normalize(cross(\\n                triangle[1] - triangle[0],\\n                triangle[2] - triangle[0]\\n            ));\\n\\t\\t\\tcolorIndex = triangleIndices[3];\\n\\t\\t\\tt_min = t;\\n            reflecting = colorIndex == 5.0;\\n\\t\\t}\\n\\t}\\n\\n    // intersection with sphere\\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\\n    {\\n        vec3 intersectionPoint = origin + ray*t;\\n        normal = normalize(intersectionPoint - SPHERE.xyz);\\n        colorIndex = 4.0;\\n        t_min = t;\\n        reflecting = true;\\n    }\\n\\n    color = colorFetch(colorIndex);\\n\\n    return t_min;\\n}\\n\\nvec3 randomPointOnHemisphere(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\\n\\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\\n    float y = i / SPHERE_SAMPLER_SIZE[0];\\n\\n\\treturn hsphereFetch(vec2(x,y));\\n}\\n\\nvec3 randomPointInLight(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\\n\\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\\n    float y = i / LIGHT_SAMPLER_SIZE[0];\\n\\n\\treturn lightFetch(vec2(x,y));\\n}\\n\\n// intersection with scene geometry\\nfloat shadow(\\n\\tconst in int fragID\\n,\\tconst in vec3 origin\\n,\\tconst in vec3 normal\\n,   out float sqDistToLight)\\n{\\n    vec3 pointInLight = randomPointInLight(fragID);\\n    float distToLight = distance(pointInLight, origin);\\n\\n\\tvec3 ray_direction = normalize(pointInLight - origin);\\n\\n\\tfloat a = dot(ray_direction, normal);\\n\\tif(a < EPSILON)\\n\\t \\treturn 0.0;\\n\\n    vec3 v1,v2; bool r; // unused\\n    float dist = intersection(origin, ray_direction, v1, v2, r);\\n    if(EPSILON < dist && dist <= distToLight)\\n        return 0.0;\\n        \\n    sqDistToLight = distToLight * distToLight;\\n\\treturn a;\\n}\\n\\nmat3 computeTbn(in vec3 normal)\\n{\\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \\n        step(0.0, abs(dot(arbNormal, normal))));\\n\\n    vec3 e0 = cross(arbNormal, normal);\\n\\tvec3 e1 = cross(e0, normal);\\n\\n    return mat3(e0, normal, e1);\\n}\\n\\n// http://gpupathtracer.blogspot.de/\\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\\n\\nvoid main()\\n{\\n    vec3 ray_origin = u_eye;\\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\\n\\n    // fragment index for random variation\\n\\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\\n\\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\\n\\n\\t// path color accumulation\\n\\tvec3 maskColor = vec3(1.0);\\n\\tvec3 pathColor = vec3(0.0);\\n\\n    // fragment is transparent before any intersection\\n    float alpha = 0.0;\\n\\n\\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\\n\\t{\\n        // check intersection with scene geometry\\n        vec3 normal;\\n        vec3 color;\\n        bool reflecting;\\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \\n\\n        if(dist == INFINITY)\\n            break; // TODO: break on no intersection, with correct path color weight?\\n\\n        // update ray for next bounce\\n        ray_origin = ray_origin + ray_direction * dist;\\n        if(reflecting){\\n            ray_direction = reflect(ray_direction, normal);\\n            if(bounce == 0) {\\n                alpha = 1.0;\\n            }\\n            continue;\\n        }\\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\\n\\n        // compute lighting and color\\n        alpha = 1.0;\\n        float squaredDistToLight = 1.0;\\n  \\t\\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\\n  \\t    maskColor *= color;\\n  \\t\\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\\n    }\\n\\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\\n}\\n\\n\"","module.exports = \"\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n    #extension GL_OES_standard_derivatives : enable\\n    precision mediump float;\\n#else\\n    precision mediump float;\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nuniform sampler2D u_vertices; // 1D\\nuniform sampler2D u_indices;  // 1D\\nuniform sampler2D u_colors;   // 1D\\nconst float NUM_VERTICES = 24.0;\\nconst float NUM_TRIANGLES = 30.0;\\nconst float NUM_COLORS = 5.0;\\n\\nuniform sampler2D u_hsphere;\\nuniform sampler2D u_lights;\\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\\n\\n\\nvec3 vertexFetch(const in float index) {\\n    return texture(u_vertices, vec2(index / (NUM_VERTICES-1.0), 0)).xyz;\\n}\\n\\nvec4 indexFetch(const in float index) {\\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\\n}\\n\\nvec3 colorFetch(const in float index) {\\n    return texture(u_colors, vec2(index / (NUM_COLORS-1.0), 0)).xyz;\\n}\\n\\nvec3 hsphereFetch(const in vec2 index) {\\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\\n}\\n\\nvec3 lightFetch(const in vec2 index) {\\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\\n}\\n\\n\\n\\n/*\\nneeds version specific stuff:\\nlayout(location = 0) out vec4 fragColor;\\n\\nconst float NUM_TRIANGLES\\nconst vec2 SPHERE_SAMPLER_SIZE\\nconst vec2 LIGHT_SAMPLER_SIZE\\n\\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\\nvec3 vertexFetch(const in float index) {}\\nvec4 indexFetch(const in float index) {}\\nvec3 colorFetch(const in float index) {}\\nvec3 hsphereFetch(const in vec2 index) {}\\nvec3 lightFetch(const in vec2 index) {}\\n*/\\n\\nuniform int u_frame;\\nuniform int u_rand;\\nuniform vec3 u_eye;\\nuniform vec4 u_viewport;\\n\\nvarying vec2 v_uv;\\nvarying vec4 v_ray;\\n\\nconst vec3 up = vec3(0.0, 1.0, 0.0);\\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\\n\\nconst float EPSILON  = 1e-6;\\nconst float INFINITY = 1e+4;\\n\\nconst int BOUNCES = 4;\\nconst float EXPOSURE = 4.0;\\nconst float GAMMA = 2.1;\\n\\n\\n\\n// intersection with triangle\\nbool intersectionTriangle(\\n\\tconst in vec3  triangle[3]\\n,\\tconst in vec3  origin\\n,\\tconst in vec3  ray\\n,\\tconst in float t_min\\n,   out float t)\\n{\\n    vec3 e0 = triangle[1] - triangle[0];\\n\\tvec3 e1 = triangle[2] - triangle[0];\\n\\n\\tvec3  h = cross(ray, e1);\\n\\tfloat a = dot(e0, h);\\n\\n\\t// if(a > -EPSILON && a < EPSILON) // backface culling off\\n\\tif(a < EPSILON) // backface culling on\\n\\t\\treturn false;\\n\\n\\tfloat f = 1.0 / a;\\n\\n\\tvec3  s = origin - triangle[0];\\n\\tfloat u = f * dot(s, h);\\n\\n\\tif(u < 0.0 || u > 1.0)\\n\\t\\treturn false;\\n\\n\\tvec3  q = cross(s, e0);\\n\\tfloat v = f * dot(ray, q);\\n\\n\\tif(v < 0.0 || u + v > 1.0)\\n\\t\\treturn false;\\n\\n\\tt = f * dot(e1, q);\\n\\n\\treturn EPSILON < t && t < t_min;\\n}\\n\\nbool intersectionSphere(\\n    const in vec4  sphere\\n,   const in vec3  origin\\n,   const in vec3  ray\\n,   const in float t_min\\n,   out float t)\\n{\\n    float radius = sphere.w;\\n    vec3 center = sphere.xyz; \\n    vec3 rayOriginToSphereCenter = origin - center;\\n    float dist = length(rayOriginToSphereCenter);\\n    float dot_term = dot(ray, rayOriginToSphereCenter);\\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\\n    if (someVar < EPSILON) { // no intersection\\n        return false;\\n    }\\n    t = -dot_term - sqrt(someVar);\\n    return EPSILON < t && t < t_min;\\n}\\n\\n// intersection with scene geometry\\nfloat intersection(\\n    const in vec3 origin\\n,   const in vec3 ray\\n,   out vec3 normal\\n,   out vec3 color\\n,   out bool reflecting)\\n{\\n    float t_min = INFINITY;\\n    float t = INFINITY;\\n\\n    float colorIndex;\\n\\n    // intersection with triangles\\n\\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\\n\\t{\\n        vec3 triangle[3];\\n        vec4 triangleIndices = indexFetch(float(i));\\n\\t\\ttriangle[0] = vertexFetch(triangleIndices[0]);\\n\\t\\ttriangle[1] = vertexFetch(triangleIndices[1]);\\n\\t\\ttriangle[2] = vertexFetch(triangleIndices[2]);\\n\\n\\t\\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\\n\\t\\t{\\n\\t\\t\\tnormal = normalize(cross(\\n                triangle[1] - triangle[0],\\n                triangle[2] - triangle[0]\\n            ));\\n\\t\\t\\tcolorIndex = triangleIndices[3];\\n\\t\\t\\tt_min = t;\\n            reflecting = colorIndex == 5.0;\\n\\t\\t}\\n\\t}\\n\\n    // intersection with sphere\\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\\n    {\\n        vec3 intersectionPoint = origin + ray*t;\\n        normal = normalize(intersectionPoint - SPHERE.xyz);\\n        colorIndex = 4.0;\\n        t_min = t;\\n        reflecting = true;\\n    }\\n\\n    color = colorFetch(colorIndex);\\n\\n    return t_min;\\n}\\n\\nvec3 randomPointOnHemisphere(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\\n\\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\\n    float y = i / SPHERE_SAMPLER_SIZE[0];\\n\\n\\treturn hsphereFetch(vec2(x,y));\\n}\\n\\nvec3 randomPointInLight(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\\n\\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\\n    float y = i / LIGHT_SAMPLER_SIZE[0];\\n\\n\\treturn lightFetch(vec2(x,y));\\n}\\n\\n// intersection with scene geometry\\nfloat shadow(\\n\\tconst in int fragID\\n,\\tconst in vec3 origin\\n,\\tconst in vec3 normal\\n,   out float sqDistToLight)\\n{\\n    vec3 pointInLight = randomPointInLight(fragID);\\n    float distToLight = distance(pointInLight, origin);\\n\\n\\tvec3 ray_direction = normalize(pointInLight - origin);\\n\\n\\tfloat a = dot(ray_direction, normal);\\n\\tif(a < EPSILON)\\n\\t \\treturn 0.0;\\n\\n    vec3 v1,v2; bool r; // unused\\n    float dist = intersection(origin, ray_direction, v1, v2, r);\\n    if(EPSILON < dist && dist <= distToLight)\\n        return 0.0;\\n        \\n    sqDistToLight = distToLight * distToLight;\\n\\treturn a;\\n}\\n\\nmat3 computeTbn(in vec3 normal)\\n{\\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \\n        step(0.0, abs(dot(arbNormal, normal))));\\n\\n    vec3 e0 = cross(arbNormal, normal);\\n\\tvec3 e1 = cross(e0, normal);\\n\\n    return mat3(e0, normal, e1);\\n}\\n\\n// http://gpupathtracer.blogspot.de/\\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\\n\\nvoid main()\\n{\\n    vec3 ray_origin = u_eye;\\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\\n\\n    // fragment index for random variation\\n\\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\\n\\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\\n\\n\\t// path color accumulation\\n\\tvec3 maskColor = vec3(1.0);\\n\\tvec3 pathColor = vec3(0.0);\\n\\n    // fragment is transparent before any intersection\\n    float alpha = 0.0;\\n\\n\\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\\n\\t{\\n        // check intersection with scene geometry\\n        vec3 normal;\\n        vec3 color;\\n        bool reflecting;\\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \\n\\n        if(dist == INFINITY)\\n            break; // TODO: break on no intersection, with correct path color weight?\\n\\n        // update ray for next bounce\\n        ray_origin = ray_origin + ray_direction * dist;\\n        if(reflecting){\\n            ray_direction = reflect(ray_direction, normal);\\n            if(bounce == 0) {\\n                alpha = 1.0;\\n            }\\n            continue;\\n        }\\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\\n\\n        // compute lighting and color\\n        alpha = 1.0;\\n        float squaredDistToLight = 1.0;\\n  \\t\\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\\n  \\t    maskColor *= color;\\n  \\t\\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\\n    }\\n\\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\\n}\\n\\n\"","module.exports = \"\\nprecision mediump float;\\nprecision mediump usampler2D;\\n\\n\\n#if __VERSION__ == 100\\n    #define texture(sampler, coord) texture2D(sampler, coord)\\n#else \\n    #define varying in\\n#endif\\n\\n\\n#if __VERSION__ == 100\\n    #define fragColor gl_FragColor\\n    #extension GL_OES_standard_derivatives : enable\\n#else\\n    layout(location = 0) out vec4 fragColor;\\n#endif\\n\\n\\nconst int NUM_TRIANGLES = 30;\\nconst int NUM_VERTICES = 24;\\nconst int NUM_COLORS = 5;\\n\\nconst float vertices[NUM_VERTICES * 3] = float[NUM_VERTICES * 3]\\n(   // room\\n    -1.000000, -1.000000, -1.000000, -1.000000, -1.000000, +1.000000,\\n    -1.000000, +1.000000, -1.000000, -1.000000, +1.000000, +1.000000,\\n    +0.988489, -1.000000, -1.000000, +0.976978, -1.000000, +1.000000,\\n    +1.000000, +1.000000, -1.000000, +1.000000, +1.000000, +1.000000,\\n    // short block\\n    +0.043165, -1.000000, -0.592275, +0.043165, -0.398688, -0.592275,\\n    -0.136691, -1.000000, -0.027182, -0.136691, -0.398688, -0.027182,\\n    -0.705036, -1.000000, -0.195279, -0.705036, -0.398688, -0.195279,\\n    -0.532374, -1.000000, -0.767525, -0.532374, -0.398688, -0.767525,\\n    // tall block\\n    +0.521583, -1.000000, -0.116595, +0.521583, +0.202624, -0.116595,\\n    +0.697842, -1.000000, +0.452074, +0.697842, +0.202624, +0.452074,\\n    +0.129496, -1.000000, +0.630901, +0.129496, +0.202624, +0.630901,\\n    -0.046763, -1.000000, +0.058655, -0.046763, +0.202624, +0.058655\\n);\\n\\n// v0, v1, v2, color\\nconst int indices[NUM_TRIANGLES * 4] = int[NUM_TRIANGLES * 4]\\n(\\n    // room ceiling\\n    6, 7, 3, 1,\\n    6, 3, 2, 1,\\n    // room floor\\n    4, 0, 1, 1,\\n    4, 1, 5, 1,\\n    // room front wall\\n    // 6, 2, 0, 1,\\n    // 6, 0, 4, 1,\\n    // room back wall\\n    5, 1, 3, 1,\\n    5, 3, 7, 1,\\n    // room right wall\\n    1, 0, 2, 3,\\n    1, 2, 3, 3,\\n    // room left wall\\n    4, 5, 7, 2,\\n    4, 7, 6, 2,\\n    // short block\\n    15, 13, 11, 1,\\n    15, 11,  9, 1,\\n     8,  9, 11, 1,\\n     8, 11, 10, 1,\\n    14, 15,  9, 1,\\n    14,  9,  8, 1,\\n    12, 13, 15, 1,\\n    12, 15, 14, 1,\\n    10, 11, 13, 1,\\n    10, 13, 12, 1,\\n    // tall block\\n    23, 21, 19, 1,\\n    23, 19, 17, 1,\\n    16, 17, 19, 1,\\n    16, 19, 18, 1,\\n    22, 23, 17, 1,\\n    22, 17, 16, 1,\\n    20, 21, 23, 1,\\n    20, 23, 22, 1,\\n    18, 19, 21, 1,\\n    18, 21, 20, 1\\n);\\n\\nconst float colors[NUM_COLORS * 3] = float[NUM_COLORS * 3]\\n(\\n    0.0000, 0.0000, 0.0000,  // 0 black\\n    0.7295, 0.7355, 0.7290,  // 1 white\\n    0.6110, 0.0555, 0.0620,  // 2 red\\n    0.1170, 0.4125, 0.1150,  // 3 green\\n    0.0620, 0.0555, 0.6110   // 4 blue\\n);\\n\\n\\nuniform sampler2D u_hsphere;\\nuniform sampler2D u_lights;\\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\\n\\n\\nvec3 vertexFetch(const in float index) {\\n    return vec3(\\n        vertices[int(round(index)) * 3 + 0],\\n        vertices[int(round(index)) * 3 + 1],\\n        vertices[int(round(index)) * 3 + 2]\\n    );\\n}\\n\\nvec4 indexFetch(const in float index) {\\n    return vec4(\\n        indices[int(round(index)) * 4 + 0],\\n        indices[int(round(index)) * 4 + 1],\\n        indices[int(round(index)) * 4 + 2],\\n        indices[int(round(index)) * 4 + 3]\\n    );\\n}\\n\\nvec3 colorFetch(const in float index) {\\n    return vec3(\\n        colors[int(round(index)) * 3 + 0],\\n        colors[int(round(index)) * 3 + 1],\\n        colors[int(round(index)) * 3 + 2]\\n    );\\n}\\n\\nvec3 hsphereFetch(const in vec2 index) {\\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\\n}\\n\\nvec3 lightFetch(const in vec2 index) {\\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\\n}\\n\\n\\n\\n/*\\nneeds version specific stuff:\\nlayout(location = 0) out vec4 fragColor;\\n\\nconst float NUM_TRIANGLES\\nconst vec2 SPHERE_SAMPLER_SIZE\\nconst vec2 LIGHT_SAMPLER_SIZE\\n\\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\\nvec3 vertexFetch(const in float index) {}\\nvec4 indexFetch(const in float index) {}\\nvec3 colorFetch(const in float index) {}\\nvec3 hsphereFetch(const in vec2 index) {}\\nvec3 lightFetch(const in vec2 index) {}\\n*/\\n\\nuniform int u_frame;\\nuniform int u_rand;\\nuniform vec3 u_eye;\\nuniform vec4 u_viewport;\\n\\nvarying vec2 v_uv;\\nvarying vec4 v_ray;\\n\\nconst vec3 up = vec3(0.0, 1.0, 0.0);\\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\\n\\nconst float EPSILON  = 1e-6;\\nconst float INFINITY = 1e+4;\\n\\nconst int BOUNCES = 4;\\nconst float EXPOSURE = 4.0;\\nconst float GAMMA = 2.1;\\n\\n\\n\\n// intersection with triangle\\nbool intersectionTriangle(\\n\\tconst in vec3  triangle[3]\\n,\\tconst in vec3  origin\\n,\\tconst in vec3  ray\\n,\\tconst in float t_min\\n,   out float t)\\n{\\n    vec3 e0 = triangle[1] - triangle[0];\\n\\tvec3 e1 = triangle[2] - triangle[0];\\n\\n\\tvec3  h = cross(ray, e1);\\n\\tfloat a = dot(e0, h);\\n\\n\\t// if(a > -EPSILON && a < EPSILON) // backface culling off\\n\\tif(a < EPSILON) // backface culling on\\n\\t\\treturn false;\\n\\n\\tfloat f = 1.0 / a;\\n\\n\\tvec3  s = origin - triangle[0];\\n\\tfloat u = f * dot(s, h);\\n\\n\\tif(u < 0.0 || u > 1.0)\\n\\t\\treturn false;\\n\\n\\tvec3  q = cross(s, e0);\\n\\tfloat v = f * dot(ray, q);\\n\\n\\tif(v < 0.0 || u + v > 1.0)\\n\\t\\treturn false;\\n\\n\\tt = f * dot(e1, q);\\n\\n\\treturn EPSILON < t && t < t_min;\\n}\\n\\nbool intersectionSphere(\\n    const in vec4  sphere\\n,   const in vec3  origin\\n,   const in vec3  ray\\n,   const in float t_min\\n,   out float t)\\n{\\n    float radius = sphere.w;\\n    vec3 center = sphere.xyz; \\n    vec3 rayOriginToSphereCenter = origin - center;\\n    float dist = length(rayOriginToSphereCenter);\\n    float dot_term = dot(ray, rayOriginToSphereCenter);\\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\\n    if (someVar < EPSILON) { // no intersection\\n        return false;\\n    }\\n    t = -dot_term - sqrt(someVar);\\n    return EPSILON < t && t < t_min;\\n}\\n\\n// intersection with scene geometry\\nfloat intersection(\\n    const in vec3 origin\\n,   const in vec3 ray\\n,   out vec3 normal\\n,   out vec3 color\\n,   out bool reflecting)\\n{\\n    float t_min = INFINITY;\\n    float t = INFINITY;\\n\\n    float colorIndex;\\n\\n    // intersection with triangles\\n\\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\\n\\t{\\n        vec3 triangle[3];\\n        vec4 triangleIndices = indexFetch(float(i));\\n\\t\\ttriangle[0] = vertexFetch(triangleIndices[0]);\\n\\t\\ttriangle[1] = vertexFetch(triangleIndices[1]);\\n\\t\\ttriangle[2] = vertexFetch(triangleIndices[2]);\\n\\n\\t\\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\\n\\t\\t{\\n\\t\\t\\tnormal = normalize(cross(\\n                triangle[1] - triangle[0],\\n                triangle[2] - triangle[0]\\n            ));\\n\\t\\t\\tcolorIndex = triangleIndices[3];\\n\\t\\t\\tt_min = t;\\n            reflecting = colorIndex == 5.0;\\n\\t\\t}\\n\\t}\\n\\n    // intersection with sphere\\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\\n    {\\n        vec3 intersectionPoint = origin + ray*t;\\n        normal = normalize(intersectionPoint - SPHERE.xyz);\\n        colorIndex = 4.0;\\n        t_min = t;\\n        reflecting = true;\\n    }\\n\\n    color = colorFetch(colorIndex);\\n\\n    return t_min;\\n}\\n\\nvec3 randomPointOnHemisphere(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\\n\\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\\n    float y = i / SPHERE_SAMPLER_SIZE[0];\\n\\n\\treturn hsphereFetch(vec2(x,y));\\n}\\n\\nvec3 randomPointInLight(const in int fragID)\\n{\\n\\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\\n\\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\\n    float y = i / LIGHT_SAMPLER_SIZE[0];\\n\\n\\treturn lightFetch(vec2(x,y));\\n}\\n\\n// intersection with scene geometry\\nfloat shadow(\\n\\tconst in int fragID\\n,\\tconst in vec3 origin\\n,\\tconst in vec3 normal\\n,   out float sqDistToLight)\\n{\\n    vec3 pointInLight = randomPointInLight(fragID);\\n    float distToLight = distance(pointInLight, origin);\\n\\n\\tvec3 ray_direction = normalize(pointInLight - origin);\\n\\n\\tfloat a = dot(ray_direction, normal);\\n\\tif(a < EPSILON)\\n\\t \\treturn 0.0;\\n\\n    vec3 v1,v2; bool r; // unused\\n    float dist = intersection(origin, ray_direction, v1, v2, r);\\n    if(EPSILON < dist && dist <= distToLight)\\n        return 0.0;\\n        \\n    sqDistToLight = distToLight * distToLight;\\n\\treturn a;\\n}\\n\\nmat3 computeTbn(in vec3 normal)\\n{\\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \\n        step(0.0, abs(dot(arbNormal, normal))));\\n\\n    vec3 e0 = cross(arbNormal, normal);\\n\\tvec3 e1 = cross(e0, normal);\\n\\n    return mat3(e0, normal, e1);\\n}\\n\\n// http://gpupathtracer.blogspot.de/\\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\\n\\nvoid main()\\n{\\n    vec3 ray_origin = u_eye;\\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\\n\\n    // fragment index for random variation\\n\\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\\n\\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\\n\\n\\t// path color accumulation\\n\\tvec3 maskColor = vec3(1.0);\\n\\tvec3 pathColor = vec3(0.0);\\n\\n    // fragment is transparent before any intersection\\n    float alpha = 0.0;\\n\\n\\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\\n\\t{\\n        // check intersection with scene geometry\\n        vec3 normal;\\n        vec3 color;\\n        bool reflecting;\\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \\n\\n        if(dist == INFINITY)\\n            break; // TODO: break on no intersection, with correct path color weight?\\n\\n        // update ray for next bounce\\n        ray_origin = ray_origin + ray_direction * dist;\\n        if(reflecting){\\n            ray_direction = reflect(ray_direction, normal);\\n            if(bounce == 0) {\\n                alpha = 1.0;\\n            }\\n            continue;\\n        }\\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\\n\\n        // compute lighting and color\\n        alpha = 1.0;\\n        float squaredDistToLight = 1.0;\\n  \\t\\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\\n  \\t    maskColor *= color;\\n  \\t\\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\\n    }\\n\\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\\n}\\n\\n\"","module.exports = __WEBPACK_EXTERNAL_MODULE__160__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n/* spellchecker: disable */\n\nimport { auxiliaries, vec3 } from 'webgl-operate';\n\nimport {\n    AccumulatePass,\n    AntiAliasingKernel,\n    BlitPass,\n    Camera,\n    Canvas,\n    Context,\n    DefaultFramebuffer,\n    EventProvider,\n    Framebuffer,\n    Invalidate,\n    Navigation,\n    NdcFillingTriangle,\n    Program,\n    Renderbuffer,\n    Renderer,\n    Shader,\n    Texture2D,\n    Wizard,\n} from 'webgl-operate';\n\nimport { Demo } from '../demo';\n\nimport { colors, indices, vertices } from './cornellboxdata';\n\n/* spellchecker: enable */\n\n// tslint:disable:max-classes-per-file\n\n\n// camera constants\nconst _gEye = vec3.fromValues(\n    +0.000000, +0.005102, -3.861230);\nconst _gCenter = vec3.fromValues(\n    +0.000000, +0.000000, +0.000000);\nconst _gUp = vec3.fromValues(\n    +0.000000, +1.000000, +0.000000);\n\n// corners of axis aligned light cuboid\nconst light0 = vec3.fromValues(-0.233813, +1 - 2e-2, -0.188126);\nconst light1 = vec3.fromValues(+0.233813, +1 - 2e-1, +0.187411);\n\n\nexport class CornellBoxRenderer extends Renderer {\n\n    protected _extensions = false;\n\n    // stuff\n    protected _camera: Camera;\n    protected _navigation: Navigation;\n\n    protected _ndcTriangle: NdcFillingTriangle;\n\n    // program and uniforms\n    protected _program: Program;\n    protected _uTransform: WebGLUniformLocation;\n\n    protected _uFrame: WebGLUniformLocation;\n    protected _uRand: WebGLUniformLocation;\n    protected _uEye: WebGLUniformLocation;\n    protected _uViewport: WebGLUniformLocation;\n\n    protected _ndcOffsetKernel: AntiAliasingKernel;\n    protected _uNdcOffset: WebGLUniformLocation;\n\n    // Textures\n    protected _hsphereImage: Texture2D;\n    protected _lightsImage: Texture2D;\n\n    // blit and accumulate\n    protected _accumulate: AccumulatePass;\n    protected _blit: BlitPass;\n\n    protected _defaultFBO: DefaultFramebuffer;\n    protected _colorRenderTexture: Texture2D;\n    protected _depthRenderbuffer: Renderbuffer;\n    protected _intermediateFBO: Framebuffer;\n\n    // for webgl1\n    protected _verticesImage: Texture2D;\n    protected _indicesImage: Texture2D;\n    protected _colorsImage: Texture2D;\n\n    protected onUpdate(): boolean {\n\n        // Update camera navigation (process events)\n        this._navigation.update();\n        return this._altered.any || this._camera.altered;\n    }\n\n    protected onPrepare(): void {\n\n        const gl = this._context.gl;\n        const gl2facade = this._context.gl2facade;\n\n        if (!this._intermediateFBO.initialized) {\n            this._colorRenderTexture.initialize(this._frameSize[0], this._frameSize[1],\n                this._context.isWebGL2 ? gl.RGBA8 : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n            this._depthRenderbuffer.initialize(this._frameSize[0], this._frameSize[1], gl.DEPTH_COMPONENT16);\n            this._intermediateFBO.initialize([[gl2facade.COLOR_ATTACHMENT0, this._colorRenderTexture]\n                , [gl.DEPTH_ATTACHMENT, this._depthRenderbuffer]]);\n\n        }\n\n        // resize\n        if (this._altered.frameSize) {\n            this._intermediateFBO.resize(this._frameSize[0], this._frameSize[1]);\n            this._camera.viewport = [this._frameSize[0], this._frameSize[1]];\n        }\n        if (this._altered.canvasSize) {\n            this._camera.aspect = this._canvasSize[0] / this._canvasSize[1];\n        }\n\n        if (this._altered.clearColor) {\n            this._intermediateFBO.clearColor(this._clearColor);\n        }\n\n        if (this._altered.multiFrameNumber) {\n            this._ndcOffsetKernel = new AntiAliasingKernel(this._multiFrameNumber);\n        }\n\n        this._accumulate.update();\n\n\n        if (this._camera.altered) {\n            this._program.bind();\n\n            gl.uniformMatrix4fv(this._uTransform, false, this._camera.viewProjectionInverse);\n            gl.uniform3fv(this._uEye, this._camera.eye);\n            gl.uniform4f(this._uViewport,\n                this._camera.viewport[0],\n                this._camera.viewport[1],\n                1.0 / this._camera.viewport[0],\n                1.0 / this._camera.viewport[1]);\n        }\n\n        this._altered.reset();\n        this._camera.altered = false;\n    }\n\n    protected onFrame(frameNumber: number): void {\n        const gl = this._context.gl;\n\n        gl.viewport(0, 0, this._frameSize[0], this._frameSize[1]);\n\n        this._intermediateFBO.bind();\n        this._intermediateFBO.clear(gl.COLOR_BUFFER_BIT, false, false);\n\n        const ndcOffset = this._ndcOffsetKernel.get(frameNumber);\n        ndcOffset[0] = 2.0 * ndcOffset[0] / this._frameSize[0];\n        ndcOffset[1] = 2.0 * ndcOffset[1] / this._frameSize[1];\n\n        // set uniforms\n        this._program.bind();\n        gl.uniform1i(this._uFrame, frameNumber);\n        gl.uniform1i(this._uRand, Math.floor(Math.random() * 1e6));\n        gl.uniform2fv(this._uNdcOffset, ndcOffset);\n\n        this._hsphereImage.bind(gl.TEXTURE0);\n        this._lightsImage.bind(gl.TEXTURE1);\n\n        // webgl1\n        if (this._context.isWebGL1) {\n            this._verticesImage.bind(gl.TEXTURE2);\n            this._indicesImage.bind(gl.TEXTURE3);\n            this._colorsImage.bind(gl.TEXTURE4);\n        }\n\n        // render geometry\n        this._ndcTriangle.bind();\n        this._ndcTriangle.draw();\n        this._ndcTriangle.unbind();\n\n        this._intermediateFBO.unbind();\n\n        this._accumulate.frame(frameNumber);\n    }\n\n    protected onSwap(): void {\n        if (this._accumulate.framebuffer) {\n            this._blit.framebuffer = this._accumulate.framebuffer;\n        } else {\n            this._blit.framebuffer = this._intermediateFBO;\n        }\n        this._blit.frame();\n    }\n\n    protected onInitialize(context: Context, callback: Invalidate, eventProvider: EventProvider): boolean {\n        const gl = this._context.gl;\n        const gl2facade = this._context.gl2facade;\n\n        /* Enable required extensions. */\n\n        if (this._extensions === false && this._context.isWebGL1) {\n            auxiliaries.assert(this._context.supportsStandardDerivatives,\n                `expected OES_standard_derivatives support`);\n            this._context.standardDerivatives;\n            this._extensions = true;\n        }\n\n        if (this._camera === undefined) {\n            this._camera = new Camera();\n            this._camera.eye = _gEye;\n            this._camera.center = _gCenter;\n            this._camera.up = _gUp;\n            this._camera.near = 0.1;\n            this._camera.far = 4.0;\n        }\n\n        // Initialize navigation\n        this._navigation = new Navigation(callback, eventProvider);\n        this._navigation.camera = this._camera;\n\n\n        // program\n        const vert = new Shader(this._context, gl.VERTEX_SHADER, 'cornell.vert');\n        vert.initialize(require('./cornell.vert'));\n        const frag = new Shader(this._context, gl.FRAGMENT_SHADER, 'cornell.frag');\n        frag.initialize(require(this._context.isWebGL1 ?\n            (this._context.supportsTextureFloat ? './cornell1.frag' : './cornell0.frag') :\n            './cornell2.frag'));\n        this._program = new Program(this._context);\n        this._program.initialize([vert, frag], false);\n\n        // attributes\n        this._ndcTriangle = new NdcFillingTriangle(this._context);\n        const aVertex = this._program.attribute('a_vertex', 0);\n        this._program.link();\n\n        // uniforms\n        this._uTransform = this._program.uniform('u_transform');\n        this._uFrame = this._program.uniform('u_frame');\n        this._uRand = this._program.uniform('u_rand');\n        this._uEye = this._program.uniform('u_eye');\n        this._uViewport = this._program.uniform('u_viewport');\n\n        this._program.bind();\n        gl.uniform1i(this._program.uniform('u_hsphere'), 0);\n        gl.uniform1i(this._program.uniform('u_lights'), 1);\n        this._program.unbind();\n\n\n        this._ndcTriangle.initialize(aVertex);\n\n\n        // CREATE HEMISPHERE PATH SAMPLES and LIGHT AREA SAMPLES\n        this._hsphereImage = new Texture2D(this._context, 'hsphereImage');\n        this._lightsImage = new Texture2D(this._context, 'lightsImage');\n\n        const points = this.pointsOnSphere(32 * 32);\n        const samplerSize = Math.floor(Math.sqrt(points.length)); // shader expects 32\n        const spherePoints = new Float32Array(samplerSize * samplerSize * 3);\n        for (let i = 0; i < samplerSize * samplerSize; ++i) {\n            spherePoints[3 * i + 0] = points[i][0];\n            spherePoints[3 * i + 1] = points[i][1];\n            spherePoints[3 * i + 2] = points[i][2];\n        }\n\n        // CREATE LIGHT AREA SAMPLES\n        const lights = this.pointsInLight(light0, light1, 32 * 32);\n        const lights2 = new Float32Array(lights.length * 3);\n        let i2 = 0;\n        for (const light of lights) {\n            lights2[i2++] = light[0];\n            lights2[i2++] = light[1];\n            lights2[i2++] = light[2];\n        }\n\n        // special case for webgl1 and no float support\n        if (this._context.isWebGL1 && !this._context.supportsTextureFloat) {\n            this._hsphereImage.initialize(32 * 3, 32, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE);\n            this._hsphereImage.data(this.encodeFloatArrayAndScale(spherePoints));\n            this._lightsImage.initialize(32 * 3, 32, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE);\n            this._lightsImage.data(this.encodeFloatArrayAndScale(lights2));\n        } else {\n            const format = Wizard.queryInternalTextureFormat(this._context, gl.RGB, Wizard.Precision.float);\n            this._hsphereImage.initialize(samplerSize, samplerSize, format[0], gl.RGB, format[1]);\n            this._hsphereImage.data(spherePoints);\n            this._lightsImage.initialize(32, 32, format[0], gl.RGB, format[1]);\n            this._lightsImage.data(lights2);\n        }\n\n        this._hsphereImage.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n        this._hsphereImage.filter(gl.NEAREST, gl.NEAREST);\n        this._lightsImage.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n        this._lightsImage.filter(gl.NEAREST, gl.NEAREST);\n\n\n        // scene textures for webgl1\n        if (this._context.isWebGL1) {\n            this._program.bind();\n            gl.uniform1i(this._program.uniform('u_vertices'), 2);\n            gl.uniform1i(this._program.uniform('u_indices'), 3);\n            gl.uniform1i(this._program.uniform('u_colors'), 4);\n            this._program.unbind();\n\n            this._verticesImage = new Texture2D(this._context, 'verticesImage');\n            this._indicesImage = new Texture2D(this._context, 'indicesImage');\n            this._colorsImage = new Texture2D(this._context, 'colorsImage');\n\n            this._indicesImage.initialize(indices.length / 4, 1, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n            this._indicesImage.data(indices);\n\n            if (context.supportsTextureFloat) {\n                this._verticesImage.initialize(vertices.length / 3, 1, gl.RGB, gl.RGB, gl.FLOAT);\n                this._verticesImage.data(vertices);\n                this._colorsImage.initialize(colors.length / 3, 1, gl.RGB, gl.RGB, gl.FLOAT);\n                this._colorsImage.data(colors);\n            } else {\n                // no floats => encode float in 3 bytes\n                this._verticesImage.initialize(vertices.length / 3 * 3, 1, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE);\n                this._verticesImage.data(this.encodeFloatArrayAndScale(vertices));\n                this._colorsImage.initialize(colors.length / 3 * 3, 1, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE);\n                this._colorsImage.data(this.encodeFloatArray(colors));\n            }\n\n            this._verticesImage.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n            this._verticesImage.filter(gl.NEAREST, gl.NEAREST);\n\n            this._indicesImage.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n            this._indicesImage.filter(gl.NEAREST, gl.NEAREST);\n\n            this._colorsImage.wrap(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\n            this._colorsImage.filter(gl.NEAREST, gl.NEAREST);\n        }\n\n        this._uNdcOffset = this._program.uniform('u_ndcOffset');\n\n        this._defaultFBO = new DefaultFramebuffer(this._context, 'DefaultFBO');\n        this._defaultFBO.initialize();\n        this._colorRenderTexture = new Texture2D(this._context, 'ColorRenderTexture');\n        this._depthRenderbuffer = new Renderbuffer(this._context, 'DepthRenderbuffer');\n        this._intermediateFBO = new Framebuffer(this._context, 'IntermediateFBO');\n\n        this._accumulate = new AccumulatePass(this._context);\n        this._accumulate.initialize(this._ndcTriangle);\n        this._accumulate.precision = this._framePrecision;\n        this._accumulate.texture = this._colorRenderTexture;\n\n        this._blit = new BlitPass(this._context);\n        this._blit.initialize(this._ndcTriangle);\n        this._blit.readBuffer = gl2facade.COLOR_ATTACHMENT0;\n        this._blit.drawBuffer = gl.BACK;\n        this._blit.target = this._defaultFBO;\n\n        return true;\n    }\n\n    protected onUninitialize(): void {\n        this._program.uninitialize();\n        this._ndcTriangle.uninitialize();\n\n        this._hsphereImage.uninitialize();\n        this._lightsImage.uninitialize();\n\n        if (this._context.isWebGL1) {\n            this._verticesImage.uninitialize();\n            this._indicesImage.uninitialize();\n            this._colorsImage.uninitialize();\n        }\n\n        this._intermediateFBO.uninitialize();\n        this._defaultFBO.uninitialize();\n        this._colorRenderTexture.uninitialize();\n        this._depthRenderbuffer.uninitialize();\n\n        this._blit.uninitialize();\n    }\n\n    protected onDiscarded(): void {\n        this._altered.alter('canvasSize');\n        this._altered.alter('clearColor');\n        this._altered.alter('frameSize');\n        this._altered.alter('multiFrameNumber');\n    }\n\n\n    // https://en.wikipedia.org/wiki/Fisher-Yates_shuffle\n    shuffle(deck: Array<vec3>): Array<vec3> {\n        const randomizedDeck = Array<vec3>();\n        const array = deck.slice();\n        while (array.length !== 0) {\n            const rIndex = Math.floor(array.length * Math.random());\n            randomizedDeck.push(array[rIndex]);\n            array.splice(rIndex, 1);\n        }\n        return randomizedDeck;\n    }\n\n    pointsInLight(llf: vec3, urb: vec3, minN: number): Array<vec3> {\n        const lights = Array<vec3>();\n\n        const min = vec3.min(vec3.create(), llf, urb);\n        const max = vec3.max(vec3.create(), llf, urb);\n        const size = vec3.subtract(vec3.create(), max, min);\n\n        const r = Math.ceil(Math.sqrt(1.0 * minN));\n        const step = vec3.scale(vec3.create(), size, (1.0 - 1e-4) / (r - 1.0)); // the \"<=\" and floating precision\n        for (let x = min[0]; x <= max[0]; x += step[0]) {\n            for (let z = min[2]; z <= max[2]; z += step[2]) {\n                lights.push(vec3.fromValues(x, auxiliaries.rand(min[1], max[1]), z));\n            }\n        }\n        return this.shuffle(lights);\n    }\n\n    pointsOnSphere(numPoints: number): Array<vec3> {\n        /* Random directions in tangent space. */\n        const donkey = new Array<vec3>(numPoints);\n        for (let i = 0; i < donkey.length; ++i) {\n            const bound = 1.0 - 1e-4;\n            const x = auxiliaries.rand(-bound, bound);\n            const z = auxiliaries.rand(-bound, bound);\n            const y = Math.sqrt(Math.max(1.0 - x * x - z * z, 1e-4));\n            donkey[i] = vec3.normalize(vec3.create(), vec3.fromValues(x, y, z));\n        }\n        return donkey;\n    }\n\n    fract(x: number): number {\n        return x > 0 ? x - Math.floor(x) : x - Math.ceil(x);\n    }\n\n    encode_float24x1_to_uint8x3(out: vec3, x: number): vec3 {\n        out[0] = Math.floor(x * 255.0);\n        out[1] = Math.floor(this.fract(x * 255.0) * 255.0);\n        out[2] = Math.floor(this.fract(x * 65536.0) * 255.0);\n        return out;\n    }\n\n    encodeFloatArray(floats: Float32Array): Uint8Array {\n        const byteEncodedArray = new Uint8Array(floats.length * 3);\n        for (let i = 0; i < floats.length; i++) {\n            const encodedVec3 = this.encode_float24x1_to_uint8x3(vec3.create(), floats[i]);\n            byteEncodedArray[3 * i + 0] = encodedVec3[0];\n            byteEncodedArray[3 * i + 1] = encodedVec3[1];\n            byteEncodedArray[3 * i + 2] = encodedVec3[2];\n        }\n        return byteEncodedArray;\n    }\n\n    // scale from [-1..+1] to [0..1] and encode\n    encodeFloatArrayAndScale(floats: Float32Array): Uint8Array {\n        const byteEncodedArray = new Uint8Array(floats.length * 3);\n        for (let i = 0; i < floats.length; i++) {\n            const encodedVec3 = this.encode_float24x1_to_uint8x3(vec3.create(), floats[i] * 0.5 + 0.5);\n            byteEncodedArray[3 * i + 0] = encodedVec3[0];\n            byteEncodedArray[3 * i + 1] = encodedVec3[1];\n            byteEncodedArray[3 * i + 2] = encodedVec3[2];\n        }\n        return byteEncodedArray;\n    }\n\n}\n\n\nexport class CornellBoxDemo extends Demo {\n\n    private _canvas: Canvas;\n    private _renderer: CornellBoxRenderer;\n\n    onInitialize(element: HTMLCanvasElement | string): boolean {\n\n        this._canvas = new Canvas(element);\n        this._canvas.controller.multiFrameNumber = 1;\n        this._canvas.framePrecision = Wizard.Precision.float;\n        this._canvas.frameScale = [0.3333, 0.3333];\n        this._canvas.clearColor.fromHex('d6d8db');\n        this._canvas.controller.multiFrameNumber = 1024;\n\n        this._canvas.element.addEventListener('click', () => { this._canvas.controller.update(); });\n\n        this._renderer = new CornellBoxRenderer();\n        this._canvas.renderer = this._renderer;\n\n        return true;\n    }\n\n    onUninitialize(): void {\n        this._canvas.dispose();\n        (this._renderer as Renderer).uninitialize();\n    }\n\n    get canvas(): Canvas {\n        return this._canvas;\n    }\n\n    get renderer(): CornellBoxRenderer {\n        return this._renderer;\n    }\n\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__160__","vertices","Float32Array","indices","Uint8Array","colors","Demo","Initializable","showSpinner","document","getElementsByClassName","item","style","display","hideSpinner","expose","window","this","canvas","context","controller","renderer","initialize","element","result","onInitialize","loadingStatus$","subscribe","status","LoadingStatus","Finished","Started","uninitialize","onUninitialize","enableFullscreenOnCtrlClick","e","addEventListener","event","ctrlKey","viewer","Fullscreen","toggle","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","_gEye","vec3","fromValues","_gCenter","_gUp","light0","light1","CornellBoxRenderer","Renderer","_extensions","onUpdate","_navigation","update","_altered","any","_camera","altered","onPrepare","gl","_context","gl2facade","_intermediateFBO","initialized","_colorRenderTexture","_frameSize","isWebGL2","RGBA8","RGBA","UNSIGNED_BYTE","_depthRenderbuffer","DEPTH_COMPONENT16","COLOR_ATTACHMENT0","DEPTH_ATTACHMENT","frameSize","resize","viewport","canvasSize","aspect","_canvasSize","clearColor","_clearColor","multiFrameNumber","_ndcOffsetKernel","AntiAliasingKernel","_multiFrameNumber","_accumulate","_program","bind","uniformMatrix4fv","_uTransform","viewProjectionInverse","uniform3fv","_uEye","eye","uniform4f","_uViewport","reset","onFrame","frameNumber","clear","COLOR_BUFFER_BIT","ndcOffset","get","uniform1i","_uFrame","_uRand","Math","floor","random","uniform2fv","_uNdcOffset","_hsphereImage","TEXTURE0","_lightsImage","TEXTURE1","isWebGL1","_verticesImage","TEXTURE2","_indicesImage","TEXTURE3","_colorsImage","TEXTURE4","_ndcTriangle","draw","unbind","frame","onSwap","framebuffer","_blit","callback","eventProvider","auxiliaries","assert","supportsStandardDerivatives","standardDerivatives","Camera","center","up","near","far","Navigation","camera","vert","Shader","VERTEX_SHADER","frag","FRAGMENT_SHADER","supportsTextureFloat","Program","NdcFillingTriangle","aVertex","attribute","link","uniform","Texture2D","points","pointsOnSphere","samplerSize","sqrt","length","spherePoints","lights","pointsInLight","lights2","i2","light","RGB","data","encodeFloatArrayAndScale","format","Wizard","queryInternalTextureFormat","Precision","float","wrap","CLAMP_TO_EDGE","filter","NEAREST","FLOAT","encodeFloatArray","_defaultFBO","DefaultFramebuffer","Renderbuffer","Framebuffer","AccumulatePass","precision","_framePrecision","texture","BlitPass","readBuffer","drawBuffer","BACK","target","onDiscarded","alter","shuffle","deck","randomizedDeck","Array","array","slice","rIndex","push","splice","llf","urb","minN","min","create","max","size","subtract","r","ceil","step","scale","x","z","rand","numPoints","donkey","bound","y","normalize","fract","encode_float24x1_to_uint8x3","out","floats","byteEncodedArray","encodedVec3","CornellBoxDemo","_canvas","Canvas","framePrecision","frameScale","fromHex","_renderer","dispose"],"sourceRoot":""}