!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("gloperate"));else if("function"==typeof define&&define.amd)define(["gloperate"],e);else{var t="object"==typeof exports?e(require("gloperate")):e(n.gloperate);for(var i in t)("object"==typeof exports?exports:n)[i]=t[i]}}(self,(n=>(()=>{var e={18:(n,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.colors=e.indices=e.vertices=void 0,e.vertices=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,.988489,-1,-1,.976978,-1,1,1,1,-1,1,1,1,.043165,-1,-.592275,.043165,-.398688,-.592275,-.136691,-1,-.027182,-.136691,-.398688,-.027182,-.705036,-1,-.195279,-.705036,-.398688,-.195279,-.532374,-1,-.767525,-.532374,-.398688,-.767525,.521583,-1,-.116595,.521583,.202624,-.116595,.697842,-1,.452074,.697842,.202624,.452074,.129496,-1,.630901,.129496,.202624,.630901,-.046763,-1,.058655,-.046763,.202624,.058655]),e.indices=new Uint8Array([6,7,3,1,6,3,2,1,4,0,1,1,4,1,5,1,5,1,3,1,5,3,7,1,1,0,2,3,1,2,3,3,4,5,7,2,4,7,6,2,15,13,11,1,15,11,9,1,8,9,11,1,8,11,10,1,14,15,9,1,14,9,8,1,12,13,15,1,12,15,14,1,10,11,13,1,10,13,12,1,23,21,19,1,23,19,17,1,16,17,19,1,16,19,18,1,22,23,17,1,22,17,16,1,20,21,23,1,20,23,22,1,18,19,21,1,18,21,20,1]),e.colors=new Float32Array([0,0,0,.7295,.7355,.729,.611,.0555,.062,.117,.4125,.115,.062,.0555,.611])},526:(n,e,t)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Demo=void 0;const i=t(160);class r extends i.Initializable{showSpinner(){document.getElementsByClassName("spinner").item(0).style.display="inline"}hideSpinner(){document.getElementsByClassName("spinner").item(0).style.display="none"}expose(){window.canvas=this.canvas,window.context=this.canvas.context,window.controller=this.canvas.controller,window.renderer=this.renderer}initialize(n){const e=this.onInitialize(n);return this.renderer.loadingStatus$.subscribe((n=>{n===i.LoadingStatus.Finished?this.hideSpinner():n===i.LoadingStatus.Started&&this.showSpinner()})),this.expose(),e}uninitialize(){this.onUninitialize()}enableFullscreenOnCtrlClick(){const n=this.canvas.element;n.addEventListener("click",(e=>{e.ctrlKey&&i.viewer.Fullscreen.toggle(n)}))}}e.Demo=r},687:n=>{n.exports="\nprecision lowp float;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else\n    #define varying out\n#endif\n\n\n\n#if __VERSION__ == 100\n    attribute vec2 a_vertex;\n#else\n    layout(location = 0) in vec2 a_vertex;\n#endif\n\n\nuniform mat4 u_transform;\nuniform mediump vec3 u_eye;\nuniform vec2 u_ndcOffset;\n\nvarying mediump vec2 v_uv;\nvarying mediump vec4 v_ray;\n\nvoid main()\n{\n    v_uv = a_vertex * 0.5 + 0.5;\n    v_ray = u_transform * vec4(u_ndcOffset + a_vertex, 1.0, 1.0);\n\n    gl_Position = vec4(a_vertex, 1.0, 1.0);\n}\n"},721:n=>{n.exports="\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n#else\n    precision mediump float;\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_vertices; // 1D\nuniform sampler2D u_indices;  // 1D\nuniform sampler2D u_colors;   // 1D\nconst float NUM_VERTICES = 24.0;\nconst float NUM_TRIANGLES = 30.0;\nconst float NUM_COLORS = 5.0;\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nconst vec3 premultUint8x3 = vec3(255.0 / 256.0, 255.0 / 65536.0, 255.0 / 16777216.0);\nfloat uint8x3_to_float24x1(const in vec3 v) {\n    return dot(v, premultUint8x3); // a1 * b1 + a2 * b2 + a3 * b3  ;)\n}\n\nvec3 vertexFetch(const in float index) {\n    // *3 because every vertex has 3 floats\n    float realIndex = index * 3.0;\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_VERTICES* 3.0 - 1.0), 0);\n    // read and scale from [0..1] to [-1..+1]\n    float x = uint8x3_to_float24x1(texture(u_vertices, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_vertices, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_vertices, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\nvec4 indexFetch(const in float index) {\n    // * 255 because openGL scales to [0..1]\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\n}\n\nvec3 colorFetch(const in float index) {\n    // *3 because every color has 3 floats\n    float realIndex = index * 3.0;\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex      ) / (NUM_COLORS* 3.0 - 1.0), 0);\n    vec2 floatIndex2 = vec2((realIndex + 1.0) / (NUM_COLORS* 3.0 - 1.0), 0);\n    vec2 floatIndex3 = vec2((realIndex + 2.0) / (NUM_COLORS* 3.0 - 1.0), 0);\n\n    float x = uint8x3_to_float24x1(texture(u_colors, floatIndex1).xyz);\n    float y = uint8x3_to_float24x1(texture(u_colors, floatIndex2).xyz);\n    float z = uint8x3_to_float24x1(texture(u_colors, floatIndex3).xyz);\n\n    return vec3(x,y,z);\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    // *3 because every vector has 3 floats\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (SPHERE_SAMPLER_SIZE * 3.0 - 1.0);\n\n    float x = uint8x3_to_float24x1(texture(u_hsphere, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_hsphere, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_hsphere, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\nvec3 lightFetch(const in vec2 index) {\n    // *3 because every vector has 3 floats\n    vec2 realIndex = vec2(index.x * 3.0, index.y);\n    // one lookup for each float; a float is encoded in 3 bytes (xyz)\n    vec2 floatIndex1 = vec2((realIndex.x      ), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex2 = vec2((realIndex.x + 1.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    vec2 floatIndex3 = vec2((realIndex.x + 2.0), realIndex.y) / (LIGHT_SAMPLER_SIZE * 3.0 - 1.0);\n    // read and scale from [0..1] to [-1..+1]\n    float x = uint8x3_to_float24x1(texture(u_lights, floatIndex1).xyz) * 2.0 - 1.0;\n    float y = uint8x3_to_float24x1(texture(u_lights, floatIndex2).xyz) * 2.0 - 1.0;\n    float z = uint8x3_to_float24x1(texture(u_lights, floatIndex3).xyz) * 2.0 - 1.0;\n\n    return vec3(x,y,z);\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},701:n=>{n.exports="\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n#else\n    precision mediump float;\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nuniform sampler2D u_vertices; // 1D\nuniform sampler2D u_indices;  // 1D\nuniform sampler2D u_colors;   // 1D\nconst float NUM_VERTICES = 24.0;\nconst float NUM_TRIANGLES = 30.0;\nconst float NUM_COLORS = 5.0;\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nvec3 vertexFetch(const in float index) {\n    return texture(u_vertices, vec2(index / (NUM_VERTICES-1.0), 0)).xyz;\n}\n\nvec4 indexFetch(const in float index) {\n    return texture(u_indices, vec2(index / (NUM_TRIANGLES-1.0), 0)) * 255.0;\n}\n\nvec3 colorFetch(const in float index) {\n    return texture(u_colors, vec2(index / (NUM_COLORS-1.0), 0)).xyz;\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\n}\n\nvec3 lightFetch(const in vec2 index) {\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},711:n=>{n.exports="\nprecision mediump float;\nprecision mediump usampler2D;\n\n\n#if __VERSION__ == 100\n    #define texture(sampler, coord) texture2D(sampler, coord)\n#else \n    #define varying in\n#endif\n\n\n#if __VERSION__ == 100\n    #define fragColor gl_FragColor\n    #extension GL_OES_standard_derivatives : enable\n#else\n    layout(location = 0) out vec4 fragColor;\n#endif\n\n\nconst int NUM_TRIANGLES = 30;\nconst int NUM_VERTICES = 24;\nconst int NUM_COLORS = 5;\n\nconst float vertices[NUM_VERTICES * 3] = float[NUM_VERTICES * 3]\n(   // room\n    -1.000000, -1.000000, -1.000000, -1.000000, -1.000000, +1.000000,\n    -1.000000, +1.000000, -1.000000, -1.000000, +1.000000, +1.000000,\n    +0.988489, -1.000000, -1.000000, +0.976978, -1.000000, +1.000000,\n    +1.000000, +1.000000, -1.000000, +1.000000, +1.000000, +1.000000,\n    // short block\n    +0.043165, -1.000000, -0.592275, +0.043165, -0.398688, -0.592275,\n    -0.136691, -1.000000, -0.027182, -0.136691, -0.398688, -0.027182,\n    -0.705036, -1.000000, -0.195279, -0.705036, -0.398688, -0.195279,\n    -0.532374, -1.000000, -0.767525, -0.532374, -0.398688, -0.767525,\n    // tall block\n    +0.521583, -1.000000, -0.116595, +0.521583, +0.202624, -0.116595,\n    +0.697842, -1.000000, +0.452074, +0.697842, +0.202624, +0.452074,\n    +0.129496, -1.000000, +0.630901, +0.129496, +0.202624, +0.630901,\n    -0.046763, -1.000000, +0.058655, -0.046763, +0.202624, +0.058655\n);\n\n// v0, v1, v2, color\nconst int indices[NUM_TRIANGLES * 4] = int[NUM_TRIANGLES * 4]\n(\n    // room ceiling\n    6, 7, 3, 1,\n    6, 3, 2, 1,\n    // room floor\n    4, 0, 1, 1,\n    4, 1, 5, 1,\n    // room front wall\n    // 6, 2, 0, 1,\n    // 6, 0, 4, 1,\n    // room back wall\n    5, 1, 3, 1,\n    5, 3, 7, 1,\n    // room right wall\n    1, 0, 2, 3,\n    1, 2, 3, 3,\n    // room left wall\n    4, 5, 7, 2,\n    4, 7, 6, 2,\n    // short block\n    15, 13, 11, 1,\n    15, 11,  9, 1,\n     8,  9, 11, 1,\n     8, 11, 10, 1,\n    14, 15,  9, 1,\n    14,  9,  8, 1,\n    12, 13, 15, 1,\n    12, 15, 14, 1,\n    10, 11, 13, 1,\n    10, 13, 12, 1,\n    // tall block\n    23, 21, 19, 1,\n    23, 19, 17, 1,\n    16, 17, 19, 1,\n    16, 19, 18, 1,\n    22, 23, 17, 1,\n    22, 17, 16, 1,\n    20, 21, 23, 1,\n    20, 23, 22, 1,\n    18, 19, 21, 1,\n    18, 21, 20, 1\n);\n\nconst float colors[NUM_COLORS * 3] = float[NUM_COLORS * 3]\n(\n    0.0000, 0.0000, 0.0000,  // 0 black\n    0.7295, 0.7355, 0.7290,  // 1 white\n    0.6110, 0.0555, 0.0620,  // 2 red\n    0.1170, 0.4125, 0.1150,  // 3 green\n    0.0620, 0.0555, 0.6110   // 4 blue\n);\n\n\nuniform sampler2D u_hsphere;\nuniform sampler2D u_lights;\nconst vec2 SPHERE_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_hsphere, 0);\nconst vec2 LIGHT_SAMPLER_SIZE = vec2(32, 32); // textureSize(u_lights, 0);\n\n\nvec3 vertexFetch(const in float index) {\n    return vec3(\n        vertices[int(round(index)) * 3 + 0],\n        vertices[int(round(index)) * 3 + 1],\n        vertices[int(round(index)) * 3 + 2]\n    );\n}\n\nvec4 indexFetch(const in float index) {\n    return vec4(\n        indices[int(round(index)) * 4 + 0],\n        indices[int(round(index)) * 4 + 1],\n        indices[int(round(index)) * 4 + 2],\n        indices[int(round(index)) * 4 + 3]\n    );\n}\n\nvec3 colorFetch(const in float index) {\n    return vec3(\n        colors[int(round(index)) * 3 + 0],\n        colors[int(round(index)) * 3 + 1],\n        colors[int(round(index)) * 3 + 2]\n    );\n}\n\nvec3 hsphereFetch(const in vec2 index) {\n    return texture(u_hsphere, index / (SPHERE_SAMPLER_SIZE-1.0)).xyz;\n}\n\nvec3 lightFetch(const in vec2 index) {\n    return texture(u_lights, index / (LIGHT_SAMPLER_SIZE-1.0)).xyz;\n}\n\n\n\n/*\nneeds version specific stuff:\nlayout(location = 0) out vec4 fragColor;\n\nconst float NUM_TRIANGLES\nconst vec2 SPHERE_SAMPLER_SIZE\nconst vec2 LIGHT_SAMPLER_SIZE\n\n// functions to access the static data (vertices, indices, colors, hsphere samples, light samples):\nvec3 vertexFetch(const in float index) {}\nvec4 indexFetch(const in float index) {}\nvec3 colorFetch(const in float index) {}\nvec3 hsphereFetch(const in vec2 index) {}\nvec3 lightFetch(const in vec2 index) {}\n*/\n\nuniform int u_frame;\nuniform int u_rand;\nuniform vec3 u_eye;\nuniform vec4 u_viewport;\n\nvarying vec2 v_uv;\nvarying vec4 v_ray;\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec4 SPHERE = vec4(-0.5, +0.0, +0.5, 0.25); // center, radius\nconst vec3 LIGHT_COLOR = vec3(1.0, 10.76 / 16.86, 3.7 / 16.86);\n\nconst float EPSILON  = 1e-6;\nconst float INFINITY = 1e+4;\n\nconst int BOUNCES = 4;\nconst float EXPOSURE = 4.0;\nconst float GAMMA = 2.1;\n\n\n\n// intersection with triangle\nbool intersectionTriangle(\n\tconst in vec3  triangle[3]\n,\tconst in vec3  origin\n,\tconst in vec3  ray\n,\tconst in float t_min\n,   out float t)\n{\n    vec3 e0 = triangle[1] - triangle[0];\n\tvec3 e1 = triangle[2] - triangle[0];\n\n\tvec3  h = cross(ray, e1);\n\tfloat a = dot(e0, h);\n\n\t// if(a > -EPSILON && a < EPSILON) // backface culling off\n\tif(a < EPSILON) // backface culling on\n\t\treturn false;\n\n\tfloat f = 1.0 / a;\n\n\tvec3  s = origin - triangle[0];\n\tfloat u = f * dot(s, h);\n\n\tif(u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tvec3  q = cross(s, e0);\n\tfloat v = f * dot(ray, q);\n\n\tif(v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\tt = f * dot(e1, q);\n\n\treturn EPSILON < t && t < t_min;\n}\n\nbool intersectionSphere(\n    const in vec4  sphere\n,   const in vec3  origin\n,   const in vec3  ray\n,   const in float t_min\n,   out float t)\n{\n    float radius = sphere.w;\n    vec3 center = sphere.xyz; \n    vec3 rayOriginToSphereCenter = origin - center;\n    float dist = length(rayOriginToSphereCenter);\n    float dot_term = dot(ray, rayOriginToSphereCenter);\n    float someVar = dot_term * dot_term - dist * dist + radius * radius;\n    if (someVar < EPSILON) { // no intersection\n        return false;\n    }\n    t = -dot_term - sqrt(someVar);\n    return EPSILON < t && t < t_min;\n}\n\n// intersection with scene geometry\nfloat intersection(\n    const in vec3 origin\n,   const in vec3 ray\n,   out vec3 normal\n,   out vec3 color\n,   out bool reflecting)\n{\n    float t_min = INFINITY;\n    float t = INFINITY;\n\n    float colorIndex;\n\n    // intersection with triangles\n\tfor(int i = 0; i < int(NUM_TRIANGLES); ++i)\n\t{\n        vec3 triangle[3];\n        vec4 triangleIndices = indexFetch(float(i));\n\t\ttriangle[0] = vertexFetch(triangleIndices[0]);\n\t\ttriangle[1] = vertexFetch(triangleIndices[1]);\n\t\ttriangle[2] = vertexFetch(triangleIndices[2]);\n\n\t\tif(intersectionTriangle(triangle, origin, ray, t_min, t))\n\t\t{\n\t\t\tnormal = normalize(cross(\n                triangle[1] - triangle[0],\n                triangle[2] - triangle[0]\n            ));\n\t\t\tcolorIndex = triangleIndices[3];\n\t\t\tt_min = t;\n            reflecting = colorIndex == 5.0;\n\t\t}\n\t}\n\n    // intersection with sphere\n    if(intersectionSphere(SPHERE, origin, ray, t_min, t))\n    {\n        vec3 intersectionPoint = origin + ray*t;\n        normal = normalize(intersectionPoint - SPHERE.xyz);\n        colorIndex = 4.0;\n        t_min = t;\n        reflecting = true;\n    }\n\n    color = colorFetch(colorIndex);\n\n    return t_min;\n}\n\nvec3 randomPointOnHemisphere(const in int fragID)\n{\n\tfloat i = mod(float(fragID), (SPHERE_SAMPLER_SIZE[0] * SPHERE_SAMPLER_SIZE[1]));\n\n    float x = mod(i, SPHERE_SAMPLER_SIZE[0]);\n    float y = i / SPHERE_SAMPLER_SIZE[0];\n\n\treturn hsphereFetch(vec2(x,y));\n}\n\nvec3 randomPointInLight(const in int fragID)\n{\n\tfloat i = mod(float(fragID), LIGHT_SAMPLER_SIZE[0] * LIGHT_SAMPLER_SIZE[1]);\n\n    float x = mod(i, LIGHT_SAMPLER_SIZE[0]);\n    float y = i / LIGHT_SAMPLER_SIZE[0];\n\n\treturn lightFetch(vec2(x,y));\n}\n\n// intersection with scene geometry\nfloat shadow(\n\tconst in int fragID\n,\tconst in vec3 origin\n,\tconst in vec3 normal\n,   out float sqDistToLight)\n{\n    vec3 pointInLight = randomPointInLight(fragID);\n    float distToLight = distance(pointInLight, origin);\n\n\tvec3 ray_direction = normalize(pointInLight - origin);\n\n\tfloat a = dot(ray_direction, normal);\n\tif(a < EPSILON)\n\t \treturn 0.0;\n\n    vec3 v1,v2; bool r; // unused\n    float dist = intersection(origin, ray_direction, v1, v2, r);\n    if(EPSILON < dist && dist <= distToLight)\n        return 0.0;\n        \n    sqDistToLight = distToLight * distToLight;\n\treturn a;\n}\n\nmat3 computeTbn(in vec3 normal)\n{\n    vec3 arbNormal = vec3(-1.241284e-02, -7.011432e-01, +2.043006e-01);\n    arbNormal = mix(arbNormal, vec3(+2.019038e-01, +9.717299e-01, +1.223763e-01), \n        step(0.0, abs(dot(arbNormal, normal))));\n\n    vec3 e0 = cross(arbNormal, normal);\n\tvec3 e1 = cross(e0, normal);\n\n    return mat3(e0, normal, e1);\n}\n\n// http://gpupathtracer.blogspot.de/\n// http://www.iquilezles.org/www/articles/simplepathtracing/simplepathtracing.htm\n// http://undernones.blogspot.de/2010/12/gpu-ray-tracing-with-glsl.html\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n// http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\n\nvoid main()\n{\n    vec3 ray_origin = u_eye;\n    vec3 ray_direction = normalize((v_ray.xyz / v_ray.w) - ray_origin);\n\n    // fragment index for random variation\n\tvec2 xy = v_uv * vec2(u_viewport[0], u_viewport[1]);\n\tint fragID = int(xy.y * u_viewport[0] + xy.x + float(u_frame) + float(u_rand));\n\n\t// path color accumulation\n\tvec3 maskColor = vec3(1.0);\n\tvec3 pathColor = vec3(0.0);\n\n    // fragment is transparent before any intersection\n    float alpha = 0.0;\n\n\tfor(int bounce = 0; bounce < BOUNCES; ++bounce)\n\t{\n        // check intersection with scene geometry\n        vec3 normal;\n        vec3 color;\n        bool reflecting;\n        float dist = intersection(ray_origin, ray_direction, normal, color, reflecting); \n\n        if(dist == INFINITY)\n            break; // TODO: break on no intersection, with correct path color weight?\n\n        // update ray for next bounce\n        ray_origin = ray_origin + ray_direction * dist;\n        if(reflecting){\n            ray_direction = reflect(ray_direction, normal);\n            if(bounce == 0) {\n                alpha = 1.0;\n            }\n            continue;\n        }\n        ray_direction = computeTbn(normal) * randomPointOnHemisphere(fragID + bounce);\n\n        // compute lighting and color\n        alpha = 1.0;\n        float squaredDistToLight = 1.0;\n  \t\tfloat lighting = shadow(fragID + bounce, ray_origin, normal, squaredDistToLight);\n  \t    maskColor *= color;\n  \t\tpathColor += maskColor * LIGHT_COLOR * lighting / squaredDistToLight;\n    }\n\n    fragColor = vec4(pow(EXPOSURE * pathColor, vec3(1.0 / GAMMA)), alpha);\n}\n\n"},160:e=>{"use strict";e.exports=n}},t={};function i(n){var r=t[n];if(void 0!==r)return r.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,i),o.exports}var r={};return(()=>{"use strict";var n=r;Object.defineProperty(n,"__esModule",{value:!0}),n.CornellBoxDemo=n.CornellBoxRenderer=void 0;const e=i(160),t=i(160),o=i(526),a=i(18),c=e.vec3.fromValues(0,.005102,-3.86123),s=e.vec3.fromValues(0,0,0),l=e.vec3.fromValues(0,1,0),_=e.vec3.fromValues(-.233813,.98,-.188126),h=e.vec3.fromValues(.233813,.8,.187411);class f extends t.Renderer{constructor(){super(...arguments),this._extensions=!1}onUpdate(){return this._navigation.update(),this._altered.any||this._camera.altered}onPrepare(){const n=this._context.gl,e=this._context.gl2facade;this._intermediateFBO.initialized||(this._colorRenderTexture.initialize(this._frameSize[0],this._frameSize[1],this._context.isWebGL2?n.RGBA8:n.RGBA,n.RGBA,n.UNSIGNED_BYTE),this._depthRenderbuffer.initialize(this._frameSize[0],this._frameSize[1],n.DEPTH_COMPONENT16),this._intermediateFBO.initialize([[e.COLOR_ATTACHMENT0,this._colorRenderTexture],[n.DEPTH_ATTACHMENT,this._depthRenderbuffer]])),this._altered.frameSize&&(this._intermediateFBO.resize(this._frameSize[0],this._frameSize[1]),this._camera.viewport=[this._frameSize[0],this._frameSize[1]]),this._altered.canvasSize&&(this._camera.aspect=this._canvasSize[0]/this._canvasSize[1]),this._altered.clearColor&&this._intermediateFBO.clearColor(this._clearColor),this._altered.multiFrameNumber&&(this._ndcOffsetKernel=new t.AntiAliasingKernel(this._multiFrameNumber)),this._accumulate.update(),this._camera.altered&&(this._program.bind(),n.uniformMatrix4fv(this._uTransform,!1,this._camera.viewProjectionInverse),n.uniform3fv(this._uEye,this._camera.eye),n.uniform4f(this._uViewport,this._camera.viewport[0],this._camera.viewport[1],1/this._camera.viewport[0],1/this._camera.viewport[1])),this._altered.reset(),this._camera.altered=!1}onFrame(n){const e=this._context.gl;e.viewport(0,0,this._frameSize[0],this._frameSize[1]),this._intermediateFBO.bind(),this._intermediateFBO.clear(e.COLOR_BUFFER_BIT,!1,!1);const t=this._ndcOffsetKernel.get(n);t[0]=2*t[0]/this._frameSize[0],t[1]=2*t[1]/this._frameSize[1],this._program.bind(),e.uniform1i(this._uFrame,n),e.uniform1i(this._uRand,Math.floor(1e6*Math.random())),e.uniform2fv(this._uNdcOffset,t),this._hsphereImage.bind(e.TEXTURE0),this._lightsImage.bind(e.TEXTURE1),this._context.isWebGL1&&(this._verticesImage.bind(e.TEXTURE2),this._indicesImage.bind(e.TEXTURE3),this._colorsImage.bind(e.TEXTURE4)),this._ndcTriangle.bind(),this._ndcTriangle.draw(),this._ndcTriangle.unbind(),this._intermediateFBO.unbind(),this._accumulate.frame(n)}onSwap(){this._accumulate.framebuffer?this._blit.framebuffer=this._accumulate.framebuffer:this._blit.framebuffer=this._intermediateFBO,this._blit.frame()}onInitialize(n,r,o){const f=this._context.gl,d=this._context.gl2facade;!1===this._extensions&&this._context.isWebGL1&&(e.auxiliaries.assert(this._context.supportsStandardDerivatives,"expected OES_standard_derivatives support"),this._context.standardDerivatives,this._extensions=!0),void 0===this._camera&&(this._camera=new t.Camera,this._camera.eye=c,this._camera.center=s,this._camera.up=l,this._camera.near=.1,this._camera.far=4),this._navigation=new t.Navigation(r,o),this._navigation.camera=this._camera;const u=new t.Shader(this._context,f.VERTEX_SHADER,"cornell.vert");u.initialize(i(687));const m=new t.Shader(this._context,f.FRAGMENT_SHADER,"cornell.frag");m.initialize(i(this._context.isWebGL1?this._context.supportsTextureFloat?701:721:711)),this._program=new t.Program(this._context),this._program.initialize([u,m],!1),this._ndcTriangle=new t.NdcFillingTriangle(this._context);const v=this._program.attribute("a_vertex",0);this._program.link(),this._uTransform=this._program.uniform("u_transform"),this._uFrame=this._program.uniform("u_frame"),this._uRand=this._program.uniform("u_rand"),this._uEye=this._program.uniform("u_eye"),this._uViewport=this._program.uniform("u_viewport"),this._program.bind(),f.uniform1i(this._program.uniform("u_hsphere"),0),f.uniform1i(this._program.uniform("u_lights"),1),this._program.unbind(),this._ndcTriangle.initialize(v),this._hsphereImage=new t.Texture2D(this._context,"hsphereImage"),this._lightsImage=new t.Texture2D(this._context,"lightsImage");const g=this.pointsOnSphere(1024),x=Math.floor(Math.sqrt(g.length)),p=new Float32Array(x*x*3);for(let n=0;n<x*x;++n)p[3*n+0]=g[n][0],p[3*n+1]=g[n][1],p[3*n+2]=g[n][2];const I=this.pointsInLight(_,h,1024),E=new Float32Array(3*I.length);let S=0;for(const n of I)E[S++]=n[0],E[S++]=n[1],E[S++]=n[2];if(this._context.isWebGL1&&!this._context.supportsTextureFloat)this._hsphereImage.initialize(96,32,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._hsphereImage.data(this.encodeFloatArrayAndScale(p)),this._lightsImage.initialize(96,32,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._lightsImage.data(this.encodeFloatArrayAndScale(E));else{const n=t.Wizard.queryInternalTextureFormat(this._context,f.RGB,t.Wizard.Precision.float);this._hsphereImage.initialize(x,x,n[0],f.RGB,n[1]),this._hsphereImage.data(p),this._lightsImage.initialize(32,32,n[0],f.RGB,n[1]),this._lightsImage.data(E)}return this._hsphereImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._hsphereImage.filter(f.NEAREST,f.NEAREST),this._lightsImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._lightsImage.filter(f.NEAREST,f.NEAREST),this._context.isWebGL1&&(this._program.bind(),f.uniform1i(this._program.uniform("u_vertices"),2),f.uniform1i(this._program.uniform("u_indices"),3),f.uniform1i(this._program.uniform("u_colors"),4),this._program.unbind(),this._verticesImage=new t.Texture2D(this._context,"verticesImage"),this._indicesImage=new t.Texture2D(this._context,"indicesImage"),this._colorsImage=new t.Texture2D(this._context,"colorsImage"),this._indicesImage.initialize(a.indices.length/4,1,f.RGBA,f.RGBA,f.UNSIGNED_BYTE),this._indicesImage.data(a.indices),n.supportsTextureFloat?(this._verticesImage.initialize(a.vertices.length/3,1,f.RGB,f.RGB,f.FLOAT),this._verticesImage.data(a.vertices),this._colorsImage.initialize(a.colors.length/3,1,f.RGB,f.RGB,f.FLOAT),this._colorsImage.data(a.colors)):(this._verticesImage.initialize(a.vertices.length/3*3,1,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._verticesImage.data(this.encodeFloatArrayAndScale(a.vertices)),this._colorsImage.initialize(a.colors.length/3*3,1,f.RGB,f.RGB,f.UNSIGNED_BYTE),this._colorsImage.data(this.encodeFloatArray(a.colors))),this._verticesImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._verticesImage.filter(f.NEAREST,f.NEAREST),this._indicesImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._indicesImage.filter(f.NEAREST,f.NEAREST),this._colorsImage.wrap(f.CLAMP_TO_EDGE,f.CLAMP_TO_EDGE),this._colorsImage.filter(f.NEAREST,f.NEAREST)),this._uNdcOffset=this._program.uniform("u_ndcOffset"),this._defaultFBO=new t.DefaultFramebuffer(this._context,"DefaultFBO"),this._defaultFBO.initialize(),this._colorRenderTexture=new t.Texture2D(this._context,"ColorRenderTexture"),this._depthRenderbuffer=new t.Renderbuffer(this._context,"DepthRenderbuffer"),this._intermediateFBO=new t.Framebuffer(this._context,"IntermediateFBO"),this._accumulate=new t.AccumulatePass(this._context),this._accumulate.initialize(this._ndcTriangle),this._accumulate.precision=this._framePrecision,this._accumulate.texture=this._colorRenderTexture,this._blit=new t.BlitPass(this._context),this._blit.initialize(this._ndcTriangle),this._blit.readBuffer=d.COLOR_ATTACHMENT0,this._blit.drawBuffer=f.BACK,this._blit.target=this._defaultFBO,!0}onUninitialize(){this._program.uninitialize(),this._ndcTriangle.uninitialize(),this._hsphereImage.uninitialize(),this._lightsImage.uninitialize(),this._context.isWebGL1&&(this._verticesImage.uninitialize(),this._indicesImage.uninitialize(),this._colorsImage.uninitialize()),this._intermediateFBO.uninitialize(),this._defaultFBO.uninitialize(),this._colorRenderTexture.uninitialize(),this._depthRenderbuffer.uninitialize(),this._blit.uninitialize()}onDiscarded(){this._altered.alter("canvasSize"),this._altered.alter("clearColor"),this._altered.alter("frameSize"),this._altered.alter("multiFrameNumber")}shuffle(n){const e=Array(),t=n.slice();for(;0!==t.length;){const n=Math.floor(t.length*Math.random());e.push(t[n]),t.splice(n,1)}return e}pointsInLight(n,t,i){const r=Array(),o=e.vec3.min(e.vec3.create(),n,t),a=e.vec3.max(e.vec3.create(),n,t),c=e.vec3.subtract(e.vec3.create(),a,o),s=Math.ceil(Math.sqrt(1*i)),l=e.vec3.scale(e.vec3.create(),c,.9999/(s-1));for(let n=o[0];n<=a[0];n+=l[0])for(let t=o[2];t<=a[2];t+=l[2])r.push(e.vec3.fromValues(n,e.auxiliaries.rand(o[1],a[1]),t));return this.shuffle(r)}pointsOnSphere(n){const t=new Array(n);for(let n=0;n<t.length;++n){const i=.9999,r=e.auxiliaries.rand(-i,i),o=e.auxiliaries.rand(-i,i),a=Math.sqrt(Math.max(1-r*r-o*o,1e-4));t[n]=e.vec3.normalize(e.vec3.create(),e.vec3.fromValues(r,a,o))}return t}fract(n){return n>0?n-Math.floor(n):n-Math.ceil(n)}encode_float24x1_to_uint8x3(n,e){return n[0]=Math.floor(255*e),n[1]=Math.floor(255*this.fract(255*e)),n[2]=Math.floor(255*this.fract(65536*e)),n}encodeFloatArray(n){const t=new Uint8Array(3*n.length);for(let i=0;i<n.length;i++){const r=this.encode_float24x1_to_uint8x3(e.vec3.create(),n[i]);t[3*i+0]=r[0],t[3*i+1]=r[1],t[3*i+2]=r[2]}return t}encodeFloatArrayAndScale(n){const t=new Uint8Array(3*n.length);for(let i=0;i<n.length;i++){const r=this.encode_float24x1_to_uint8x3(e.vec3.create(),.5*n[i]+.5);t[3*i+0]=r[0],t[3*i+1]=r[1],t[3*i+2]=r[2]}return t}}n.CornellBoxRenderer=f;class d extends o.Demo{onInitialize(n){return this._canvas=new t.Canvas(n),this._canvas.controller.multiFrameNumber=1,this._canvas.framePrecision=t.Wizard.Precision.float,this._canvas.frameScale=[.3333,.3333],this._canvas.clearColor.fromHex("d6d8db"),this._canvas.controller.multiFrameNumber=1024,this._canvas.element.addEventListener("click",(()=>{this._canvas.controller.update()})),this._renderer=new f,this._canvas.renderer=this._renderer,!0}onUninitialize(){this._canvas.dispose(),this._renderer.uninitialize()}get canvas(){return this._canvas}get renderer(){return this._renderer}}n.CornellBoxDemo=d})(),r})()));
//# sourceMappingURL=cornell-box.js.map